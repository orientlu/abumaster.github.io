<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2017-09-20T09:14:32.366Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一面攒人品-趋势科技</title>
    <link href="http://abumaster.com/2017/09/19/%E4%B8%80%E9%9D%A2%E6%94%92%E4%BA%BA%E5%93%81-%E8%B6%8B%E5%8A%BF%E7%A7%91%E6%8A%80/"/>
    <id>http://abumaster.com/2017/09/19/一面攒人品-趋势科技/</id>
    <published>2017-09-19T11:16:01.000Z</published>
    <updated>2017-09-20T09:14:32.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>趋势科技面试题目汇总，不是太难，面试官人很好，基础还是很薄弱的，好多东西都忘了。</p>
</blockquote>
<a id="more"></a>
<p><strong>1.知道迭代器吗，迭代器失效</strong><br>我回答了迭代器是一个指针，vector在插入和删除会引起迭代器的失效，记得在stl源码剖析中看到过，但是没有系统的回答出来。<br>标准回答：<br>vector在进行插入和删除操作后会使部分或者全部的迭代器失效，因为vector是顺序存储的，当容量不够时会删除原有的旧空间，然后将元素拷贝到新的空间中，导致所有的原空间上的迭代器失败。删除操作后，指向删除点的迭代器和其后的迭代器全部失效。<br>deque容器在首部尾部插入迭代器不会失效，首部和尾部删除元素会使删除元素的迭代器失效，在中间删除元素会使所有的迭代器失效。<br>list很少失效，只有删除的元素的迭代器失效。  </p>
<p><strong>2.删除容器中值为2的元素</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.begin(); it != vec.end();)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (*it == <span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            it = vec.erase(it);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            ++it;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.进程同步，共享存储在一个进程失效后，会如何回收</strong><br><a href="http://blog.chinaunix.net/uid-26833883-id-3230564.html">共享内存</a><br>共享内存的介绍：共享内存是一种高效的进程间通信，直接读写内存是一种高效的数据拷贝；内核中专门开辟一块内存区，进程直接映射到自己的私有地址空间中，直接读取不需要拷贝，所以更加高效；多个进程共享这块内存，所以需要一种同步机制。<br>流程：  </p>
<ul>
<li>创建或者打开共享存储；  </li>
<li>映射共享内存，将指定的内存映射到进程地址空间便于访问；  </li>
<li>撤销共享内存的映射；  </li>
<li>删除共享内存对象。<br>控制共享内存：  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</div><div class="line"><span class="comment">//shmid 共享内存标识</span></div><div class="line"><span class="comment">//cmd :IPC_STAT 得到共享内存的状态；IPC_SET 改变共享内存的状态；IPC_RMID 删除共享内存</span></div><div class="line"><span class="comment">//buf  是一个结构体指针。IPC_STAT的时候，取得的状态放在这个结构体中。如果要改变共享内存的状态，用这个结构体指定；</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>IPC_RMID命令实际上不从内核删除一个段，而是仅仅把这个段标记为删除，实际的删除发生最后一个进程离开这个共享段时。<br>当cmd为IPC_RMID时，第三个参数应为NULL。呵呵，大部分我们都是这样做,用这个函数删除共享内存。  </p>
<p><strong>4.程序崩溃</strong><br>一种方法，程序崩溃一般通过COREDUMP文件进行调试，在windows下面这部分需要自己在程序中添加代码，网上有源代码，添加到程序中即可。程序崩溃是点击COREDUMP文件，运行VS2010即可快速定位。  </p>
<p>另外一种方法，没有COREDUMP时，先运行程序，然后在VS2010中，把工程附加到进程，注意工程中运行涉及的所有文件必须是VS2010最新代码编译的。这种情况下，VS2010工程中不需要打断点，当程序运行出现崩溃时，自动跳转VS2010的代码中。这种情况非常适合服务器程序，尤其是崩溃发生的条件不清楚，无法再现的情况。尤其服务器运行几天后，崩溃，这种情况非常有用。  </p>
<p><strong>5.sql数据库加锁</strong><br><a href="http://blog.csdn.net/gz2008gz/article/details/5398529">数据库加锁</a><br>处理多用户并发访问的方法是加锁。锁是防止其他事务访问指定的资源控制、实现并发控制的一种主要手段。当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象。加锁对并发访问的影响体现在锁的粒度上。为了控制锁定的资源，应该首先了解系统的空间管理。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;趋势科技面试题目汇总，不是太难，面试官人很好，基础还是很薄弱的，好多东西都忘了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>硬币找零问题—动态规划</title>
    <link href="http://abumaster.com/2017/09/15/%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://abumaster.com/2017/09/15/硬币找零问题—动态规划/</id>
    <published>2017-09-15T00:32:53.000Z</published>
    <updated>2017-09-15T04:00:01.663Z</updated>
    
    <content type="html"><![CDATA[<p>硬币找零问题主要分为求最少硬币找零和最多组合数找零，一个是求用最少的硬币来达到目标，一个是达到目标的组合数。<br><a id="more"></a></p>
<h4 id="最少硬币找零问题"><a href="#最少硬币找零问题" class="headerlink" title="最少硬币找零问题"></a>最少硬币找零问题</h4><p><strong>问题描述</strong><br>给不同面值的硬币若干种（每种硬币个数无限多），用这若干种硬币组合为某种面额的钱，使用的硬币的个数最少。<br><strong>分析</strong>
贪心策略往往不是最优的。这时用到动态规划，假设硬币面值为<code>{v1,v2,v3,...,vn}</code>，纸币金额为<code>sum</code>，可以假设<code>dp[i]</code>表示面值为i的纸币所需的最少硬币个数，然后对于每个i遍历所有的硬币数目，更新最小值。如何转移？对于第i面值的纸币，遍历每个硬币，如果当前硬币的值小于，则可以分解为子问题，+1，更新最小值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">coinsUsed[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cents = <span class="number">1</span>; cents &lt;= money; cents++) &#123;  </div><div class="line">    <span class="comment">// 当用最小币值的硬币找零时，所需硬币数量最多  </span></div><div class="line">    <span class="keyword">int</span> minCoins = cents;  </div><div class="line"></div><div class="line">    <span class="comment">// 遍历每一种面值的硬币，看是否可作为找零的其中之一  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kind = <span class="number">0</span>; kind &lt; valueKinds; kind++) &#123;               </div><div class="line">        <span class="comment">// 若当前面值的硬币小于当前的cents则分解问题并查表  </span></div><div class="line">        <span class="keyword">if</span> (values[kind] &lt;= cents) &#123;  </div><div class="line">            <span class="keyword">int</span> temp = coinsUsed[cents - values[kind]] + <span class="number">1</span>;  </div><div class="line">            <span class="keyword">if</span> (temp &lt; minCoins) &#123;  </div><div class="line">                minCoins = temp;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 保存最小硬币数  </span></div><div class="line">coinsUsed[cents] = minCoins;</div></pre></td></tr></table></figure></p>
<h4 id="硬币面值组合问题"><a href="#硬币面值组合问题" class="headerlink" title="硬币面值组合问题"></a>硬币面值组合问题</h4><p><strong>问题描述</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">假设我们有8种不同面值的硬币｛1，2，5，10，20，50，100，200｝，用这些硬币组合够成一个给定的数值n。例如n=200，那么一种可能的组合方式为 200 = 3 * 1 + 1＊2 + 1＊5 + 2＊20 + 1 * 50 + 1 * 100. 问总过有多少种可能的组合方式？</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/python27/archive/2013/09/05/3303721.html">参考</a><br>定义 <code>dp[i][m]</code>表示前i种硬币构成m的组合数，对于第i个硬币可以用<code>{0,1,...,m/coins[i]}</code>个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][sum] = dp[i-1][sum - 0*Vm] + dp[i-1][sum - 1*Vm]+ dp[i-1][sum - 2*Vm] + ... + dp[i-1][sum - K*Vm]; 其中K = sum / Vm</div></pre></td></tr></table></figure></p>
<p>关键代码
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncoins; ++i)<span class="comment">//硬币种类数</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)<span class="comment">//兑换的面值</span></div><div class="line">        &#123;</div><div class="line">            dp[i][j] = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j / arr[i - <span class="number">1</span>]; ++k)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - k*arr[i - <span class="number">1</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="限制级的找零"><a href="#限制级的找零" class="headerlink" title="限制级的找零"></a>限制级的找零</h4><p>找零问题，限制硬币的个数，硬币的面值，如腾讯2018秋招的笔试题大意为：拥有硬币面值为<code>2^k</code>，数量各为两个，求拼凑出num的硬币组合数，如拼凑出6的组合数为：<code>{4,2},{4,1,1},{2,2,1,1}</code>，拥有的硬币面值为1,2,4,8,16,…各位2个。<br>与第一个问题类似，只不过限定了硬币用的个数k，以及硬币的面值，所以根据给定的兑换金额可以确定硬币的面值序列，每个面值最多用2个，然后问题就简单了，代码如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//兑换sum元的组合数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LimitCoinsComb</span><span class="params">(<span class="keyword">int</span> sum)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">//硬币的面值为：1,2,4,8,16...2^k 各位2个</span></div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">log</span>(sum) / <span class="built_in">log</span>(<span class="number">2</span>);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = <span class="built_in">pow</span>(<span class="number">2</span>, i);</div><div class="line">        coins.push_back(temp);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        dp[i].resize(sum + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化，sum==0时只有一种组合，其它初始为0中组合</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j / coins[i - <span class="number">1</span>], <span class="number">2</span>); ++k)<span class="comment">//最多用2个或者j/coins[i]个，最小值</span></div><div class="line">            &#123;</div><div class="line">                dp[i][j] += dp[i<span class="number">-1</span>][j - k*coins[i - <span class="number">1</span>]];<span class="comment">//递推公式</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n+<span class="number">1</span>][sum];<span class="comment">//返回结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬币找零问题主要分为求最少硬币找零和最多组合数找零，一个是求用最少的硬币来达到目标，一个是达到目标的组合数。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="动态规划" scheme="http://abumaster.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>常见算法模板</title>
    <link href="http://abumaster.com/2017/09/06/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <id>http://abumaster.com/2017/09/06/常见算法模板/</id>
    <published>2017-09-06T13:12:25.000Z</published>
    <updated>2017-09-15T06:43:57.848Z</updated>
    
    <content type="html"><![CDATA[<p>常见的算法模板，如并查集、字典树等。
<a id="more"></a></p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p><strong>定义</strong>：并查集是一种树型结构，又叫“不相交集合”，保持了一组不相交的动态集合，每个集合有一个代表标识着集合，通常用根节点表示。<br><strong>三种基本操作</strong><br>1.初始化 <code>Make_Set(x)</code> ，建立一个新的集合，集合中只有一个元素x，因此x代表整个集合，要求集合不相交，因此x不会出现在其他集合中。<br>2.查找代表 <code>Find_Set(x)</code> 查找可以代表x的集合的代表，返回x所在集合的根节点；<br>3.合并集合 <code>Union(x, y)</code> 合并x和y代表的集合，查找两个集合的根节点，相同则不必合并，不同则需要合并。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立一个新的集合，每一个子节点就是一个数，本身就是他的根节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Make_Set</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    father[x] = x;</div><div class="line">    R[x] = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过递归向上查找根节点，回溯时改变当前节点的父节点，直接指向根节点。</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Set</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x != father[x])</div><div class="line">        father[x] = Find_set(father[x]);</div><div class="line">    <span class="keyword">return</span> father[x];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将根节点设置为-1的非递归方法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Set2</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> y = x;</div><div class="line">    <span class="keyword">while</span>(y!= <span class="number">-1</span>)</div><div class="line">        y = father[y];</div><div class="line">    <span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//两个集合的合并算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> GrandX = Find_set(x);</div><div class="line">    <span class="keyword">int</span> GrandY = Find_set(y);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(GrandX == GrandY)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(R[GrandX] &lt; R[GrandY])</div><div class="line">        father[GrandX] = GrandY;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(R[GrandX] == R[GrandY])</div><div class="line">            R[GrandX]++;</div><div class="line">        father[GrandY] = GrandX;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h4><p><a href="http://www.cnblogs.com/tanky_woo/archive/2010/09/24/1833717.html">字典树</a>又称 <em>单词查找树</em>，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br>类似于字典，将一个字符串对应到一棵树上，第一个字母为第一层，第二个字母为第二层，依次向下走。<br>数据结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Trie   </div><div class="line">&#123;   </div><div class="line">    Trie *next[MAX];<span class="comment">//元素的个数，小写字母26个</span></div><div class="line">    <span class="keyword">int</span> v;   <span class="comment">//根据需要变化</span></div><div class="line">&#125;;   </div><div class="line"> </div><div class="line">Trie *root;</div></pre></td></tr></table></figure></p>
<p>支持的操作：<br>创建字典树，动态分配空间，对于给定的字符串中的每一个字符，查找树对应的层，如果为空，那么申请一个新的节点，下一个指针为空，如果存在值加1，指向下一层。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTrie</span><span class="params">(<span class="keyword">char</span> *str)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</div><div class="line">    Trie *p = root, *q;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> id = str[i]-<span class="string">'0'</span>;</div><div class="line">        <span class="keyword">if</span>(p-&gt;next[id] == <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            q = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</div><div class="line">            q-&gt;v = <span class="number">1</span>;    <span class="comment">//初始v==1</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAX; ++j)</div><div class="line">                q-&gt;next[j] = <span class="literal">NULL</span>;</div><div class="line">            p-&gt;next[id] = q;</div><div class="line">            p = p-&gt;next[id];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            p-&gt;next[id]-&gt;v++;</div><div class="line">            p = p-&gt;next[id];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    p-&gt;v = <span class="number">-1</span>;   <span class="comment">//若为结尾，则将v改成-1表示</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查找一段字符串是否是其中的一个前缀字符串，按层次搜索，如果从中间的某一层没有查到，那么查找失败返回0，成功放回-1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTrie</span><span class="params">(<span class="keyword">char</span> *str)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</div><div class="line">    Trie *p = root;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> id = str[i]-<span class="string">'a'</span>;</div><div class="line">        p = p-&gt;next[id];</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)   <span class="comment">//若为空集，表示不存以此为前缀的串</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(p-&gt;v == <span class="number">-1</span>)   <span class="comment">//字符集中已有串是此串的前缀</span></div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//此串是字符集中某串的前缀</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的算法模板，如并查集、字典树等。
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>知识点</title>
    <link href="http://abumaster.com/2017/09/04/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://abumaster.com/2017/09/04/知识点/</id>
    <published>2017-09-04T05:54:29.000Z</published>
    <updated>2017-09-26T13:37:47.141Z</updated>
    
    <content type="html"><![CDATA[<p>总结前辈们面试知识点，备忘。<br><a id="more"></a></p>
<h4 id="C-语言特性"><a href="#C-语言特性" class="headerlink" title="C++语言特性"></a>C++语言特性</h4><h5 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h5><p>可以参考<a href="http://www.cnblogs.com/Azhu/p/4436531.html">博文</a>。<br>内存划分：<br>在C++中，内存分成5个区，他们分别是 <strong>堆</strong>、<strong>栈</strong>、<strong>自由存储区</strong>、<strong>全局/静态存储区</strong>和 <strong>常量存储区</strong>。<br><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br><strong>堆</strong>：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br><strong>自由存储区</strong>：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。<br><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。<br><strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。<br>分配和释放：<br>C++中使用<code>new</code>和<code>delete</code>运算符用于申请和释放内存块，要配对使用。对于对象来说，可以调用默认构造函数。栈是由编译器自动管理，堆由程序员控制；栈的空间小速度快，堆的空间大，速度相对慢；生长方向，堆是向地址增大的方向，栈是向地址减小的方向。  </p>
<p><strong>注意问题</strong><br>1.指向常量字符串的指针，不能修改，如果尝试修改，编译期间没毛病，会出现运行错误。如
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p=<span class="string">"hello"</span>;</div><div class="line">p[<span class="number">0</span>]=<span class="string">'H'</span>;<span class="comment">//编译器发现不了这个错误，p[0]='H';没毛病</span></div></pre></td></tr></table></figure></p>
<p>2.指针和数组，数组名不是指针，只是在一定的情况下退化为指针（数组名作为参数传递）。同样数组名也不可以直接赋值给一个指针，或者比较，要用标准函数<code>strcpy strcmp</code>。  </p>
<h5 id="C-多态或虚函数实现机制"><a href="#C-多态或虚函数实现机制" class="headerlink" title="C++多态或虚函数实现机制"></a>C++多态或虚函数实现机制</h5><p>C++多态是通过虚函数实现的。<a href="http://www.cnblogs.com/malecrab/p/5572730.html">C++虚函数的实现的基本原理</a>。<br><strong>虚函数</strong>的实现：虚函数表和虚表指针。<br>虚函数表，就是在一个类的内存分布上起始地址是一个虚表指针，指向虚函数的表。虚函数表是在构造函数时产生，所以构造函数不能为虚函数。例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funa</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funb</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**内存分布          虚表</div><div class="line">|   *pvtable |--&gt;| funa | funb |</div><div class="line">|      a     |</div><div class="line">***/</span></div></pre></td></tr></table></figure></p>
<p>如果实例一个Base类对象，<code>Base b</code>，然后，虚表指针为 <code>(int *)(&amp;b)</code> 将地址转换成4字节的地址就位虚指针，第一个虚函数的地址为<code>(int *)*(int *)(&amp;b)</code>。<br>当继承时，子类也继承了父类的虚表并在其中重写虚函数或增加虚函数。动态绑定 <code>Base *pb= new Derive();</code> ，然后调用虚函数，偏移地址是一定的，如果子类重写了虚函数，那么会调用子类的虚函数，完成动态绑定，实现了多态。<br><em>引用和指针都可以实现动态绑定，是实现多态的两种方式。</em><br>多继承的时候，会产生多个虚表，分别对应于各个父类。  </p>
<h5 id="虚构造函数和虚析构函数"><a href="#虚构造函数和虚析构函数" class="headerlink" title="虚构造函数和虚析构函数"></a>虚构造函数和虚析构函数</h5><p>构造函数和析构函数不能被继承。<br>构造函数不能声明为虚函数，构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数。构造函数后才会产生虚表。<br><strong>虚析构函数</strong>是为了使子类调用自己的析构函数来释放内存空间，而不是单纯调用父类的构造函数，造成内存泄漏。<br>如<code>Base *pb=new Derive(); delete pb;</code>，如果基类的析构函数不是虚函数的话，delete操作只调用了父类的析构函数，子类的构造函数没有调用，造成了内存泄漏。<br><em>析构函数的执行不应该抛出异常，如果有异常，最好不要抛出函数之外。</em><br>静态成员函数不能是虚函数，<em>虚函数</em>是一种特殊的成员函数，为了实现运行时多态，<em>静态函数</em>和类不相关，是一种限定了命名空间的特殊函数，所以。  </p>
<h5 id="构造函数和析构函数抛出异常"><a href="#构造函数和析构函数抛出异常" class="headerlink" title="构造函数和析构函数抛出异常"></a>构造函数和析构函数抛出异常</h5><p><em>构造函数抛出异常</em><br>不建议构造函数抛出异常；<br>构造函数抛出异常时，析构函数将不会被执行。<br><em>析构函数抛出异常</em><br>析构函数不应该抛出异常；<br>可能发生异常时，将异常封装到析构函数之内；<br>当处理另一个异常过程中，不要从析构函数抛出异常。  </p>
<h5 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h5><p>方法的重写（Overriding）和重载（overloading）是多态性的不同表现。<br>重写是父类和子类之间多态性的一种表现，重载是一个类中多态的表现。<br>如果父类定义了一个虚函数，子类定义了同名的函数，且函数参数以及返回值都相同，那么称为重写，父类中的定义被覆盖了；如果在一个类中定义了多个同名的方法，它们的区别在于参数的个数和类型，并且返回值也可以不同，那么这就是重载了。  </p>
<h5 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h5><p><code>auto_ptr</code> 废弃了。<code>shared_ptr</code> 类允许多个指针指向同一个对象，有一个引用计数；<code>unique_ptr</code> 则独占所指向的对象；<code>weak_ptr</code> 弱引用指向<code>shared_ptr</code> 指向的对象。  </p>
<h5 id="C-模板的作用"><a href="#C-模板的作用" class="headerlink" title="C++模板的作用"></a>C++模板的作用</h5><p><strong>优点：</strong>  </p>
<ul>
<li>编译时检查数据类型，而不是运行时检查，保证了类型安全；  </li>
<li>与平台无关，移植性好；  </li>
<li>与类型无关，代码复用性好；  </li>
<li>动态增长和减少的数据结构。<br><strong>缺点：</strong>  </li>
<li>易读性比较差，调试比较困难；  </li>
<li>模板的数据类型在编译期才能确定；  </li>
<li>模板的实现在整个头文件中，工程比较大的时候编译时间会比较长。  </li>
</ul>
<h5 id="动态链接库和静态链接库"><a href="#动态链接库和静态链接库" class="headerlink" title="动态链接库和静态链接库"></a>动态链接库和静态链接库</h5><p><strong>优缺点：</strong><br>动态链接库节省内存和减少页面的交换，dll与可执行文件相互独立，只有遵循接口定义则更换dll不会影响程序的运行；不同编程语言都可以调用，程序的契合度小模块化。缺点：动态加载时，如果不存在，程序终止出错，运行时加载，不存在，调用不存在的函数，出错。<br>静态链接库代码执行速度快，运行速度也略快，链接到到程序中，发行版本不再需要。但是程序的可执行文件大，代码重复多，可重用性低。<br><strong>使用方法：</strong><br>静态链接库的使用：使用静态链接库，需要包含<code>.h</code>文件和<code>#pragma comment(lib,&quot;**.lib&quot;)</code>编译开关，就可以直接用链接库中的文件了。<br>动态链接库的使用：一种静态连接，启动前加入<code>#pragmaa comment(lib,&quot;**.lib&quot;)</code>编译开关，声明链接库中的函数，可以直接用；动态加载，用时加载<code>LoadLibrary(&quot;.dll&quot;)</code>，然后声明导出函数指针并获得函数的指针，用完释放。  </p>
<h4 id="STL相关和数据结构"><a href="#STL相关和数据结构" class="headerlink" title="STL相关和数据结构"></a>STL相关和数据结构</h4><h5 id="红黑树的特性及其应用"><a href="#红黑树的特性及其应用" class="headerlink" title="红黑树的特性及其应用"></a>红黑树的特性及其应用</h5><p>满足下列条件的二叉搜索树是红黑树<br>性质1. 节点是红色或黑色<br>性质2. 根是黑色<br>性质3. 所有叶子都是黑色（叶子是Null节点）<br>性质4. 如果一个节点是红的，则它的两个儿子都是黑的<br>性质5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。<br><a href="http://abumaster.com/2017/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91/">调整详细</a>。<br>STL中<code>set、multiset、map、multimap</code>底层是红黑树实现的，而<code>unordered_map</code>、<code>unordered_set</code> 底层是哈希表实现的。  </p>
<h5 id="手写实现智能指针"><a href="#手写实现智能指针" class="headerlink" title="手写实现智能指针"></a>手写实现智能指针</h5><p>智能指针不用显示调用delete来清理内存。
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">class auto_ptr &#123;</div><div class="line">public:</div><div class="line">    explicit auto_ptr(T *p=0):pointer(p)&#123;&#125;</div><div class="line">    ~auto_ptr()&#123;delete pointer;&#125;//析构函数自动调用用来清理内存</div><div class="line">    T&amp; operator*() const &#123;return *pointer;&#125;//解指针</div><div class="line">    T* operator-&gt;() const &#123;return pointer;&#125;</div><div class="line">private:</div><div class="line">    T* pointer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="Bloom过滤器"><a href="#Bloom过滤器" class="headerlink" title="Bloom过滤器"></a>Bloom过滤器</h5><p><a href="https://segmentfault.com/a/1190000002729689">Bloom布隆过滤器</a>是一种空间效率很高的数据结构。<br>相当于一个哈希表，将一个大的数据集通过hash函数映射到小的集合上，比hash表更节省空间，但是也带来了一定的错误率。通常用于实现数据字典，快速查询，数据的去重，集合求交集等。<br>如何实现？m位数的数组，全置为0，和k个hash函数，当有一个数字，经过每一个hash函数，映射到对应位数的数组中，置为1。查询时，如果通过hash函数计算的每一位都为1，则认为这个数字使存在的，否则不存在。问题：一个数不存在，可能会被认为存在。<br>可以快速识别一个元素是否为一个集合中的元素，如将url映射为1bit，用来识别恶意链接，检测辣鸡邮箱。<br><div class="note info"><p>A,B 两个文件，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4G，让你找出 A,B 文件共同的 URL。如果是三个乃至 n 个文件呢？<br>分析 ：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿 bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。  </p>
</div>  </p>
<h5 id="B树家族"><a href="#B树家族" class="headerlink" title="B树家族"></a>B树家族</h5><p><a href="http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html">参考</a>。<br><strong>B树</strong> 二叉搜索树，非叶子节点至多拥有两个儿子，所有节点存放着一个关键字，左子树比父节点小，右子树比父节点元素大。搜索类似二分查找，若树不平衡则退化为顺序查找。所以有时加一个平衡条件，称为平衡二叉树。<br><strong>B-树</strong>  多路搜索树，通常用于数据库索引的底层实现。<br><strong>B+树</strong><br><strong>B*树</strong>   </p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h5 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h5><p><a href="http://www.tuicool.com/articles/IvyQry">卡特兰数</a>，<a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin">百度百科</a><br>用来解决常见的问题，一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?<br>将问题转化为：入栈的数的个数总是要大于或者等于出栈数的个数。 <code>C(2n，n)-C(2n，n-1)</code><br>在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？<br>将问题转化为：还书的人总是要大于或等于借书的人，即<code>C(6，3)-C(6，2)</code>  </p>
<h5 id="贪心算法及其弊端"><a href="#贪心算法及其弊端" class="headerlink" title="贪心算法及其弊端"></a>贪心算法及其弊端</h5><p>在对问题求解时总是做出在当前看来是最好的选择，不是从整体上考虑而是从局部达到最优解。<br>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。  </p>
<h5 id="01背包问题的详细解释"><a href="#01背包问题的详细解释" class="headerlink" title="01背包问题的详细解释"></a>01背包问题的详细解释</h5><p><a href="http://blog.csdn.net/ling_du/article/details/41594767">参看背包九讲</a>  </p>
<h4 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h4><h5 id="Linux下的程序编译命令"><a href="#Linux下的程序编译命令" class="headerlink" title="Linux下的程序编译命令"></a>Linux下的程序编译命令</h5><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-25/70062040.jpg" alt=""><br><strong>gcc的编译过程</strong>分为四个部分：预处理、编译、汇编、链接。  </p>
<ul>
<li>预处理，命令<code>gcc -E -o test.i test.c</code>，生成了预处理后的文件；  </li>
<li>编译，命令 <code>gcc -S test.i -o test.s</code> ，生成了汇编程序；  </li>
<li>汇编，命令 <code>gcc -c test.s -o test.o</code> ，生成了目标文件；  </li>
<li>链接，将目标文件和所需的外部文件（动态链接库和静态链接库）一块链接成可执行文件。    </li>
</ul>
<h5 id="Linux下的IO模型"><a href="#Linux下的IO模型" class="headerlink" title="Linux下的IO模型"></a>Linux下的IO模型</h5><p><a href="http://www.cnblogs.com/chy2055/p/5220793.html">IO模型</a>。<br>　IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：<br>（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。<br>（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。<br>（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。<br>（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。<br>（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。<br>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。  </p>
<h5 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h5><p>进程间通信主要分为以下几种：匿名管道、命名管道、共享内存、消息队列、信号量、套接字。  </p>
<ul>
<li>匿名管道：是一种半双工的，有读写端，用于有亲缘关系的进程之间通信（父子、兄弟），相当于一个文件可以直接调用<code>write</code>和<code>read</code>进行读写，只存在于内存中；  </li>
<li>命名管道：FIFO，无亲缘关系的进程之间可以相互通信；  </li>
<li>消息队列：存放在内核中的一个消息链，一个消息队列由一个标识符来标识，独立于发送和接收进程，可以实现消息的随机读取或者按消息的类型进行读取；  </li>
<li>信号量用于进程之间的同步，而不是用于存储进程之间的通信数据，基于操作系统的PV操作；  </li>
<li>共享内存：多个进程共享一块内存区，速度最快的IPC，多个进程共享一块，因此需要借助信号量来同步；  </li>
<li>套接字：不同机器进程可以进行通信。  </li>
</ul>
<h5 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h5><p><strong>线程池</strong>就是一堆事先创建好的线程，数量固定，一开始这一堆线程都处于空闲状态，当有一个任务到来的时候，线程池管理函数会为任务分一个空闲的线程来执行这个任务，当这个任务完成后，会把线程从新放入到线程池中。充分利用了线程的可重用性，并且避免了频繁的线程的创建和销毁开销。<br>线程池的构成：  </p>
<ul>
<li>线程池管理器：用于创建和管理线程池；  </li>
<li>工作线程：线程池中实际执行任务的线程，固定数目，一开始空闲状态；  </li>
<li>任务接口：每个任务必须实现的接口，当线程池的任务队列中有可执行任务时，被空闲的工作线程调去执行（线程的闲与忙是通过互斥量实现的，跟前面文章中的设置标志位差不多），把任务抽象出来形成接口，可以做到线程池与具体的任务无关。  </li>
<li>任务队列：用来存放没有处理的任务，提供一种缓冲机制，实现这种结构有好几种方法，常用的是队列，主要运用先进先出原理，另外一种是链表之类的数据结构，可以动态的为它分配内存空间，应用中比较灵活。<br>具体代码。  </li>
</ul>
<h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>线程同步的几种方式：互斥锁、条件变量、信号量：  </p>
<ul>
<li>互斥锁mutex，在c++11标准中提供了mutex头文件，其中定义为<code>mutex mtx;</code>加锁和释放锁的操作为<code>mtx.lock(); mtx.unlock()</code>。另外还提供了一个尝试获取锁，但是不阻塞的操作<code>mtx.try_lock();</code>。  </li>
<li>条件变量，用来等待而不是加锁。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。  </li>
<li>临界区对象，多个线程访问独享一块临界区资源，用完后释放，如互斥锁一样的存在。  </li>
<li>事件机制，允许一个线程完成任务后去通知另一个线程，如网络应用中，一个线程负责监听端口，另一个线程负责更新数据，这个时候则可以使监听完成后直接通知另一个线程更新数据。  </li>
</ul>
<h5 id="epoll-和-select"><a href="#epoll-和-select" class="headerlink" title="epoll 和 select"></a>epoll 和 select</h5><p>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024<br>epoll避免了这些缺点，进行一次拷贝，不需要重复拷贝，另外没有描述符数量的限制，另外将已经就绪的描述符加入到描述符链表中。  </p>
<h5 id="awk和sed命令"><a href="#awk和sed命令" class="headerlink" title="awk和sed命令"></a>awk和sed命令</h5><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。  </p>
<h4 id="网络和数据库"><a href="#网络和数据库" class="headerlink" title="网络和数据库"></a>网络和数据库</h4><p><a href="https://zhuanlan.zhihu.com/p/24001696">网络常考知识点</a>  </p>
<h5 id="TCP连接和断开的握手"><a href="#TCP连接和断开的握手" class="headerlink" title="TCP连接和断开的握手"></a>TCP连接和断开的握手</h5><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-17/13917292.jpg" alt=""><br>状态描述：<br>CLOSED：没有任何连接请求终止或开始状态；<br>LISTEN：被动打开，侦听来自远端的TCP连接请求；<br>SYN_SEND：在发送连接请求后等待匹配的连接请求；<br>SYN_RCVD：在收到和发送一个连接请求后等待确认；<br>ESTABLISH：代表一个连接已经建立进入数据传送状态；<br>FIN_WAIT_1：主动关闭连接后，等待对方连接中断；<br>FIN_WAIT_2：从远程TCP等待连接中断请求；<br>CLOSE_WAIT：等待从本地用户发起的连接中断请求；<br>CLOSING：等待远程TCP对连接中断请求；<br>LAST_ACK：等待原来发向远程TCP的连接中断请求的确认；
TIME_WAIT：等待足够的时间确保远程TCP接收到连接中断请求的确认。<br><strong>TCP连接的三次握手：</strong><br>连接前服务器已经做好接收外界连接的准备，<code>socket,bind,listen</code>函数等待。<br>客户端主动打开，导致tcp发送一个syn分节，告诉服务器在将建立连接中发送数据的初始序列号；服务器必须确认客户的syn，并且发送一个自己的syn；客户必须再一次确认服务器的syn。<br>为什么要三次握手，<em>为了防止一个失效的报文段再一次传送到了服务器，服务器以为一个新的连接请求，那么发送确认，两次握手的话，服务器会直接进入阻塞等待客户端数据，但是客户并没有发送连接请求，当然不会发送数据，这样就造成了服务器一直等待，资源的浪费。所以三次握手，保证连接是客户端想要创建的</em>。<br><strong>TCP断开的四次握手</strong><br>某个应用进程先调用closed主动关闭连接，发送一个FIN表示没有数据想要发送了；接收到fin的那一端，执行被动关闭，表明再无额外的数据可以接收，发送一个ack给对方，说我知道了；等一段时间，接收到fin的这一端关闭自己的套接字，导致tcp又向对方发送一个fin；接收到fin的原发送端的tcp确认这个fin。tcp连接终止完成。  </p>
<h5 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h5><p>主要区别如下：  </p>
<ul>
<li>TCP面向连接的字节流可靠的传输；UDP是面向无连接的报文不可靠的传输；  </li>
<li>TCP的传输速度慢，UDP的传输速度快；  </li>
</ul>
<h5 id="常用的端口号"><a href="#常用的端口号" class="headerlink" title="常用的端口号"></a>常用的端口号</h5><p>图片来源知乎<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-23/16087893.jpg" alt="">  </p>
<h5 id="浏览器输入网址后发生的情况"><a href="#浏览器输入网址后发生的情况" class="headerlink" title="浏览器输入网址后发生的情况"></a>浏览器输入网址后发生的情况</h5><ul>
<li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器</li>
<li>浏览器向IP对应的web服务器发送一个HTTP请求</li>
<li>服务器响应请求，发回网页内容</li>
<li>浏览器解析网页内容</li>
</ul>
<h5 id="服务器并发是如何实现的？"><a href="#服务器并发是如何实现的？" class="headerlink" title="服务器并发是如何实现的？"></a>服务器并发是如何实现的？</h5><p>服务器是可以同时执行多个进程的，并发服务器在同一时刻可以处理多个客户的连接，实现主要分三种方式：多进程并发服务器，多线程并发服务器，I/O复用并发服务器。</p>
<h5 id="MySQL数据库复制关系"><a href="#MySQL数据库复制关系" class="headerlink" title="MySQL数据库复制关系"></a>MySQL数据库复制关系</h5><p>master将改变记录到二进制日志文件中；slave将master的二进制日志拷贝到它的中继日志中；slave重做中继日志中的事件，将改变反映它自己的数据。<br>MySQL Binlog 有三种格式，分别是Statement(语句)、Row(行)、Mixd(混合)。<br>Statement记录了用户执行的原始SQL，而Row则是记录了行的修改情况，在MySQL 5.6以上的版本默认是Mixd格式，但为了保证复制数据的完整性，建议生产环境都使用Row格式，就前面所说的Row记录的是行数据的修改情况，而不是原始SQL。<br><a href="http://blog.csdn.net/nanamasuda/article/details/52089499">详细</a>  </p>
<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><p>提高数据库表的数据访问速度。特点：<br>避免对数据库进行全表扫描，只需扫描少量的索引页就能得出数据；<br>聚集索引可以避免数据插入操作，集中于表的最后一个数据页面；<br>在某些情况下，索引可以避免排序操作。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结前辈们面试知识点，备忘。&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="知识点" scheme="http://abumaster.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>最后一年</title>
    <link href="http://abumaster.com/2017/09/01/%E6%9C%80%E5%90%8E%E4%B8%80%E5%B9%B4/"/>
    <id>http://abumaster.com/2017/09/01/最后一年/</id>
    <published>2017-09-01T11:45:13.000Z</published>
    <updated>2017-09-01T12:51:28.528Z</updated>
    
    <content type="html"><![CDATA[<div class="note sucess"><p>春未老， 风细柳斜斜。 试上超然台上望， 半壕春水一城花。 烟雨暗千家。<br>寒食后， 酒醒却咨嗟。 休对故人思故国， 且将新火试新茶。 诗酒趁年华。  </p>
</div>  
<a id="more"></a>
<blockquote class="blockquote-center"><p><strong>愿你出走半生，归来仍是少年</strong></p>
</blockquote>  
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-1/12545054.jpg" alt=""><br>时间在指尖匆匆流逝，人也变得愈加手足无措，烦躁不安了。焦虑着毕业，焦虑着工作，焦虑着未来的何去何从…再无当年的淡定自若，宠辱不惊了。<br><strong>懒惰</strong>是何时成为了我的习惯，我是何时变得如此懒惰，无论是身体上还是心理上，似乎早已经适应了懒惰，懒得动，懒得想，懒得只想宅在凳子上。这也带来了身体上的变化，体重增加，眼睛近视加深，动不动生病。以前的早睡早起，现在的经常熬夜睡懒觉，这个变化仿佛是不知不觉地形成的。而我也尝到了坏习惯的苦果。我是真的很忙？忙的没有时间锻炼？忙的没有时间睡觉？这一切不过是借口罢了。睡得晚是因为在玩游戏、在看电视，牺牲的大把时间不过是放在娱乐上面罢了，而这种娱乐能让我休息？能活跃我的思维？当然只是来腐蚀着我的思考能力。看所谓的新闻等等，完全是看着新鲜，真的从中收获了多少，思考了多少，不过是看看别人的评论，人云亦云而已；玩游戏，用太多时间，也不过是过眼云烟，就算玩的再好又能如何。<br>所谓的忙，不过是自己找的借口罢了，学海无涯，确实如此，但是学习的过程中离不了 <strong>思考总结</strong>，耗费太多的时间只去学，不去思考是完全没有用的。在过去的一两年时间里，我暴露了太多的缺点。多了几本书，却没能完全消化掉这些知识，其根本原因是很少总结，很少思考，不问为什么，只顾着不断学进去，然后忘掉。这就是为什么花费了大把的时间，却没有成效的原因吧。<br>从小学开始记的日记，到现在也渐渐落下了。记得高三的时候，是那么的忙，每天还要抽出放学后的几分钟记一下今天的心路历程，学习感悟。不曾想，现在有太多的时间可以用，却不写了。那是记日记成了一种繁忙，压力生活的一种放松时间，现在反而成了一种负担，自己想着就是搞笑。可能敲键盘多了，你会忘记自己写字的技能吧。可恨！可恶至极！<br><strong>我已不在是少年</strong>，我已无梦想，甘愿做一平凡人。但愿<code>一席一茶观明月，一花一湖澈是非。今生的一切努力是要朝着花开的方向。</code>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note sucess&quot;&gt;&lt;p&gt;春未老， 风细柳斜斜。 试上超然台上望， 半壕春水一城花。 烟雨暗千家。&lt;br&gt;寒食后， 酒醒却咨嗟。 休对故人思故国， 且将新火试新茶。 诗酒趁年华。  &lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://abumaster.com/categories/life/"/>
    
    
      <category term="随笔" scheme="http://abumaster.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2018秋招-360</title>
    <link href="http://abumaster.com/2017/08/27/2018%E7%A7%8B%E6%8B%9B-360/"/>
    <id>http://abumaster.com/2017/08/27/2018秋招-360/</id>
    <published>2017-08-27T09:09:54.000Z</published>
    <updated>2017-08-28T09:15:22.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>360 2018秋招笔试编程题目解析。</p>
</blockquote>
<a id="more"></a>
<h4 id="卖粉笔问题"><a href="#卖粉笔问题" class="headerlink" title="卖粉笔问题"></a>卖粉笔问题</h4><p>有彩色粉笔<code>n</code>个，白色粉笔<code>m</code>个，<code>a</code>个彩色粉笔和<code>b</code>个白色粉笔打包可以卖<code>x</code>元，<code>c</code>个白色粉笔可以卖<code>y</code>元，<code>d</code>个彩色粉笔可以卖<code>z</code>元，问可以获得的最大收益。  </p>
<p><strong>解题思路1：</strong><br>首先想到的是动态规划问题，对于有<code>i</code>个彩色粉笔和<code>j</code>个白色粉笔，<code>dp[i][j]</code>表示可以卖到的最大值，那么这个最大值是如何求出的呢？<br>状态转移有以下几种情况：  </p>
<ul>
<li>只卖白色，<code>dp[i][j] = dp[i][j-c] + y</code>；  </li>
<li>只卖彩色，<code>dp[i][j] = dp[i-d][j] + z</code>；  </li>
<li>组合卖，<code>dp[i][j] = dp[i-a][j-b] + x</code>。<br>取三种情况的最大值，最后<code>dp[n][m]</code>就是所求的结果。<br>分析，双层循环，复杂度的<code>O(N*M)</code>。  </li>
</ul>
<p><strong>解题思路2：</strong><br>相对于动态规划要简单许多，要获得最大利润，最终的粉笔肯定有一个组合，假设为<code>x</code>对组合卖掉，那么白色粉笔还剩余<code>m-b*x</code>个，白色粉笔可以最多卖的钱数为<code>(m-b*x)/c * y</code>，同理可以得到彩色的所卖钱数。对于最终组合，其他的组合都不是最优的结果，所以，可以用组合卖的粉笔组数来进行最优解选择。<br>代码如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//最大收益</span></div><div class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//组合卖的盒数</span></div><div class="line"><span class="keyword">while</span> (index*a &lt;= n &amp;&amp; index*b &lt;= m)<span class="comment">//可以组合来卖</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp = index*x;<span class="comment">//组合卖的收益</span></div><div class="line">    temp += ((m - index*b) / c)*y;<span class="comment">//白色粉笔单独卖的收益</span></div><div class="line">    temp += ((n - index*a) / d)*z;<span class="comment">//彩色粉笔单独卖的收益</span></div><div class="line">    ans = (ans &gt; temp) ? ans : temp;<span class="comment">//更新收益最大值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>复杂度仅为<code>O(n)</code>性能得到了很大的提升。启示：想到最终状态，然后再步步推。  </p>
<h4 id="统计数组中前面比自己小的数字个数"><a href="#统计数组中前面比自己小的数字个数" class="headerlink" title="统计数组中前面比自己小的数字个数"></a>统计数组中前面比自己小的数字个数</h4><p>类似于这样的题：给定一个整数数组（下标由 <code>0</code> 到 <code>n-1</code>， <code>n</code> 表示数组的规模，取值范围由 0 到10000）。对于数组中的每个 <code>ai</code> 元素，请计算 <code>ai</code> 前的数中比它小的元素的数量。    </p>
<p><strong>思路1：</strong><br>暴力求解，复杂度太高，无法完全通过。  </p>
<p><strong>思路2：</strong><br><div class="note info"><p>分析：求ai前的数中比他小的元素数量，即，在<code>ai</code>之前的元素中区间<code>[0, ai-1]</code>的元素数量<br>构建线段树，节点中包含元素出现的次数，所有<code>count&gt;0</code> 的叶子结点表示元素存在；依次更新结点计数，所以后面的元素不影响前面的元素计数。</p>
</div><br><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5%E6%A0%91/10983506?fr=aladdin">线段树</a>是一种数据结构，是一种二叉搜索树，每个叶节点表示一个单元区间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> XianDuanTree</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> Node<span class="comment">//线段树的节点</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">int</span> start, end, count;</div><div class="line">        Node *left, *right;</div><div class="line">        Node(<span class="keyword">int</span> start, <span class="keyword">int</span> end) :start(start), end(end), count(<span class="number">0</span>), right(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//创建线段树，返回根节点</span></div><div class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="comment">//递归创建，返回条件</span></div><div class="line">        <span class="keyword">if</span> (start &gt; end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</div><div class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">            root-&gt;left = build(start, mid);</div><div class="line">            root-&gt;right = build(mid + <span class="number">1</span>, end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在线段树中查找区间</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (start &gt; end || root-&gt;start &gt; end || root-&gt;end &lt; start) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end) <span class="keyword">return</span> root-&gt;count;<span class="comment">//查找的区间包含root所指区间</span></div><div class="line">        <span class="keyword">int</span> mid = (root-&gt;start + root-&gt;end) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> leftCount = query(root-&gt;left, start, min(mid, end));</div><div class="line">        <span class="keyword">int</span> rightCount = query(root-&gt;right, max(mid, start), end);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> leftCount + rightCount;<span class="comment">//返回左右子树的查找数量</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//像线段树中插入value</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inset</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (root-&gt;left == root-&gt;right &amp;&amp; root-&gt;start == value)</div><div class="line">        &#123;</div><div class="line">            root-&gt;count += <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//递归查找合适的插入位置</span></div><div class="line">        <span class="keyword">int</span> mid = (root-&gt;start + root-&gt;end) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (value &lt;= mid)</div><div class="line">        &#123;</div><div class="line">            inset(root-&gt;left, value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            inset(root-&gt;right, value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//回溯自下而上更新count//右子树不一定存在所以进行判断</span></div><div class="line">        root-&gt;count = root-&gt;left-&gt;count + (root-&gt;right ? root-&gt;right-&gt;count : <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSamllerNum()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">        Node *root = build(<span class="number">0</span>, <span class="number">10005</span>);</div><div class="line">        <span class="keyword">int</span> n,temp;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</div><div class="line">            <span class="keyword">int</span> cnt = query(root, temp+<span class="number">1</span>, <span class="number">10005</span>);<span class="comment">//前面比他大的数，区间为[temp+1,maxn]，的数的数量</span></div><div class="line">            vec.push_back(cnt);</div><div class="line">            inset(root, temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> vec;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="简单数列"><a href="#简单数列" class="headerlink" title="简单数列"></a>简单数列</h4><p>题目描述见图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-28/45707399.jpg" alt=""><br><a href="http://www.cnblogs.com/qscqesze/p/5217014.html">类似的题目地址</a><br>思路：<br>交换0次和交换一次，显然可以直接暴力出来<br>现在考虑交换两次的情况，交换两次之后，答案为<code>s-2*a[i]-2*a[j]+2*b[i]+2*b[j]</code>（s为原来未交换的时候，两个数组的差值。我们把所有的<code>(a[i],a[j])</code>都存起来，为了使两数组之差最小，显然<code>2*(b[i]+b[j])</code>应该找到大于等于<code>(2*(a[i]+a[j])-s)</code>的第一个数然后这个东西直接二分就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2050</span>;</div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"><span class="keyword">int</span> b[maxn];</div><div class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span> ,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;two[maxn*maxn+<span class="number">5</span>];</div><div class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),s+=a[i];</div><div class="line">    <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]),s-=b[i];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s2 = <span class="number">1e18</span>;</div><div class="line">    <span class="comment">//交换一次后的结果</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="built_in">abs</span>(s + <span class="number">2</span>*b[j] - <span class="number">2</span>*a[i]);</div><div class="line">            <span class="keyword">if</span>(cur&lt;s2)</div><div class="line">            &#123;</div><div class="line">                s2 = cur;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">            two[++tot]=make_pair(<span class="number">2l</span>l*b[i]+<span class="number">2l</span>l*b[j],make_pair(i,j));</div><div class="line">    sort(two+<span class="number">1</span>,two+<span class="number">1</span>+tot);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s3 = <span class="number">1e18</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">2l</span>l*a[i]+<span class="number">2l</span>l*a[j]-s;</div><div class="line">            <span class="keyword">int</span> p = lower_bound(two+<span class="number">1</span>,two+<span class="number">1</span>+tot,make_pair(tmp,make_pair(<span class="number">0</span>,<span class="number">0</span>)))-two;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=max(<span class="number">1</span>,p<span class="number">-2</span>);t&lt;=min(tot,p+<span class="number">2</span>);t++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="built_in">abs</span>(s+two[t].first<span class="number">-2</span>ll*a[i]<span class="number">-2</span>ll*a[j]);</div><div class="line">                <span class="keyword">if</span>(cur&lt;s3)</div><div class="line">                &#123;</div><div class="line">                    s3 = cur;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = min(min(<span class="built_in">abs</span>(s),<span class="built_in">abs</span>(s2)),<span class="built_in">abs</span>(s3));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;360 2018秋招笔试编程题目解析。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="笔试" scheme="http://abumaster.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2018秋招-今日头条</title>
    <link href="http://abumaster.com/2017/08/27/2018%E7%A7%8B%E6%8B%9B-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    <id>http://abumaster.com/2017/08/27/2018秋招-今日头条/</id>
    <published>2017-08-27T09:09:22.000Z</published>
    <updated>2017-08-30T07:31:54.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今日头条2018秋招笔试，编程题目笔记。</p>
</blockquote>
<a id="more"></a>
<h4 id="第二题，求区间内最小值和区间元素和之间的乘积最大值"><a href="#第二题，求区间内最小值和区间元素和之间的乘积最大值" class="headerlink" title="第二题，求区间内最小值和区间元素和之间的乘积最大值"></a>第二题，求区间内最小值和区间元素和之间的乘积最大值</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/36221200.jpg" alt="">  </p>
<p>暴力解法，不可行。看了网上大神的分析，用 <strong>单调栈</strong> 的方法。<br><strong>单调栈</strong><br>单调栈是一个特殊的栈，栈中的元素大小按照其在栈中的位置，满足一定的单调性。<br>基本思想：<br><a href="http://blog.csdn.net/u013616945/article/details/77508372">参考</a>  </p>
<ul>
<li>将数组的每个值作为最小值，找到以此最小值的区间，统计区间和与此值的乘积，假设当前最小值 <code>num[k]</code> ，那么找到最左边小于该值的下标 <code>i</code> ，找到最右边小于该值的值的下标 <code>j</code> ，那么 <code>[i+1, j-1]</code> 是以 <code>num[k]</code> 为最小值所能达到的最大区间，那么计算 <code>Sum(i+1, j-1) * num[k]</code> 。  </li>
<li>按照上述遍历数组中的每一个值，（单调栈实现），维护一个最大值 <code>maxSum</code> 遍历完数组后，可解。  </li>
</ul>
<p>单调栈的实现：栈s<br>数组中元素入栈和出栈的规则如下：  </p>
<ol>
<li>s为空，或者当前元素 <code>num[i]</code> 的值大于等于当前栈顶元素，直接将 <code>num[i]</code> 的下标 <code>i</code> 压入栈；</li>
<li>当s不为空，且当前元素 <code>num[i]</code> 的值小于等于栈顶元素，那么依次从栈中弹出元素，直到 <code>num[i]</code> 大于栈顶元素，并在弹出过程中计算每一个数作为最小值区间的计算结果；  </li>
<li>如果数组遍历完成，但是栈非空，重复步骤2，直到栈空。  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">incr_stack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</div><div class="line">    <span class="keyword">int</span> n = num.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s.empty() || num[i] &gt;=num[s.top()]) &#123;<span class="comment">//规则1</span></div><div class="line">            s.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; num[s.top()] &gt;=num[i]) &#123;<span class="comment">//规则2</span></div><div class="line">                <span class="keyword">int</span> top = s.top();</div><div class="line">                s.pop();</div><div class="line">                <span class="keyword">int</span> tmp=s.empty()? vecSum(num, <span class="number">0</span>, i<span class="number">-1</span>) : vecSum(num, s.top()+ <span class="number">1</span>, i - <span class="number">1</span>);</div><div class="line">                <span class="keyword">int</span> curSum = num[top]*tmp;</div><div class="line">                maxSum = max(curSum, maxSum);</div><div class="line">            &#125;</div><div class="line">            s.push(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;<span class="comment">//规则3</span></div><div class="line">        <span class="keyword">int</span> top = s.top();</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">int</span> tmp=s.empty()? vecSum(num, <span class="number">0</span>, n<span class="number">-1</span>): vecSum(num, s.top()+ <span class="number">1</span>, n - <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> curSum =  num[top]*tmp;</div><div class="line">        maxSum = max(curSum, maxSum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/26465701">扩展题</a><br><div class="note info"><p>给一个数组，返回一个大小相同的数组。返回的数组的第i个位置的值应当是，对于原数组中的第i个元素，至少往右走多少步，才能遇到一个比自己大的元素（如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上-1）。<br><strong>简单的例子：</strong><br>input: 5,3,1,2,4<br>return: -1 3 1 1 -1<br><em>explaination:</em> 对于第0个数字5，之后没有比它更大的数字，因此是-1，对于第1个数字3，需要走3步才能达到4（第一个比3大的元素），对于第2和第3个数字，都只需要走1步，就可以遇到比自己大的元素。对于最后一个数字4，因为之后没有更多的元素，所以是-1。  </p>
</div></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextExceed(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result (input.size(), <span class="number">-1</span>);<span class="comment">//保存结果</span></div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; monoStack;<span class="comment">//单调栈</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); ++i) &#123;</div><div class="line">        <span class="comment">//如果栈不空，并且当前元素大于栈顶元素</span></div><div class="line">        <span class="keyword">while</span>(!monoStack.empty() &amp;&amp; input[monoStack.top()] &lt; input[i]) &#123;</div><div class="line">            result[monoStack.top()] = i - monoStack.top();<span class="comment">//求栈顶元素的结果</span></div><div class="line">            monoStack.pop();<span class="comment">//出栈</span></div><div class="line">        &#125;</div><div class="line">        monoStack.push(i);<span class="comment">//当前比栈顶小，压入栈</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="note warning"><p>给定n个非负数，代表直方图的高度，直方图的宽度为1，找到直方图所组成的矩形的最大面积。<br><em>input：</em> 2,1,5,6,2,3<br><em>output:</em> 10<br><em>explaination:</em> 5和6组成的矩形面积为10，返回10。   </p>
</div>  
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">            height.push_back(<span class="number">0</span>);</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</div><div class="line">                <span class="keyword">while</span>(index.size() &gt; <span class="number">0</span> &amp;&amp; height[index.back()] &gt;= height[i]) &#123;</div><div class="line">                    <span class="keyword">int</span> h = height[index.back()];</div><div class="line">                    index.pop_back();</div><div class="line">                    <span class="keyword">int</span> sidx = index.size() &gt; <span class="number">0</span> ? index.back() : <span class="number">-1</span>;</div><div class="line">                    ret = max(ret, h * (i-sidx<span class="number">-1</span>));</div><div class="line">                &#125;</div><div class="line">                index.push_back(i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h4 id="第三题，调度"><a href="#第三题，调度" class="headerlink" title="第三题，调度"></a>第三题，调度</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/66252799.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/54465329.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/34202462.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今日头条2018秋招笔试，编程题目笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="笔试" scheme="http://abumaster.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>牛客网校招模拟编程题(1-5)笔记</title>
    <link href="http://abumaster.com/2017/08/18/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%A0%A1%E6%8B%9B%E6%A8%A1%E6%8B%9F%E7%BC%96%E7%A8%8B%E9%A2%98-1-5-%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2017/08/18/牛客网校招模拟编程题-1-5-笔记/</id>
    <published>2017-08-18T06:43:17.000Z</published>
    <updated>2017-08-22T06:07:25.469Z</updated>
    
    <content type="html"><![CDATA[<p>牛客网上的2017年校招全国统一模拟试题的编程题目，比较难的一些题目汇总，做下记录。  </p>
<a id="more"></a>
<p><strong>1.猜数字游戏</strong><br><div class="note primary"><p>题目描述：<a href="https://www.nowcoder.com/test/5986669/summary">题目链接</a><br>牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中,牛牛玩家选择一个正整数,羊羊根据已给的提示猜这个数字。第i个提示是”Y”或者”N”,表示牛牛选择的数是否是i的倍数。<br>例如,如果提示是”YYNYY”,它表示这个数使1,2,4,5的倍数,但不是3的倍数。<br>注意到一些提示会出现错误。例如: 提示”NYYY”是错误的,因为所有的整数都是1的倍数,所以起始元素肯定不会是”N”。此外,例如”YNNY”的提示也是错误的,因为结果不可能是4的倍数但不是2的倍数。<br>现在给出一个整数n,表示已给的提示的长度。请计算出长度为n的合法的提示的个数。<br>例如 n = 5:<br>合法的提示有:<br>YNNNN YNNNY YNYNN YNYNY YYNNN YYNNY<br>YYNYN YYNYY YYYNN YYYNY YYYYN YYYYY<br>所以输出12  </p>
</div>  </p>
<p>合法的条件是存在倍数依赖的数字要么是全为Y要么全为N，分析：  </p>
<ul>
<li>第 i 个数是素数（如2,3,5,7…），那么在这一位上是Y或N与前面没有依赖，因此当前位的可能数目sum(i)是前面数目sum(i-1)的2倍；  </li>
<li>第 i 个数是偶数，但是却不是素数的幂，（如6,10…），那么这一位是Y或N完全取决于它的两个因子，如6取决于2和3,2和3是Y，6一定是Y。因此，sum(i)为sum(i-1)；  </li>
<li>第 i 个数是素数的幂，（如4,9,8…），它是不能唯一确定的，2取Y，4可以取Y也可以取N，所以对于4，将2,4加入集合取值的组合为NN，YN，YY三种情况，对于8来说，由2,4,8组成，共有NNN，YNN，YYN，YYY四种情况，依次类推就行了，相乘。  </li>
</ul>
<p>关键代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (vis[i])<span class="comment">//是倍数直接可以忽略掉不要重复计算</span></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)<span class="comment">//倍数</span></div><div class="line">    &#123;</div><div class="line">        vis[j] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求i的幂次</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mi = i;</div><div class="line">    <span class="keyword">while</span> (mi &lt;= n)</div><div class="line">    &#123;</div><div class="line">        cnt++;<span class="comment">//记录幂的数目</span></div><div class="line">        mi *= i;</div><div class="line">    &#125;</div><div class="line">    ans = ans * (cnt + <span class="number">1</span>) % MOD;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p><strong>2.庆祝六一</strong><br>题目描述：<br>牛家庄幼儿园为庆祝61儿童节举办庆祝活动,庆祝活动中有一个节目是小朋友们围成一个圆圈跳舞。牛老师挑选出n个小朋友参与跳舞节目,已知每个小朋友的身高h_i。为了让舞蹈看起来和谐，牛老师需要让跳舞的圆圈队形中相邻小朋友的身高差的最大值最小，牛老师犯了难，希望你能帮帮他。<br>如样例所示:<br>当圆圈队伍按照100,98,103,105顺时针排列的时候最大身高差为5，其他排列不会得到更优的解。  </p>
<p><a href="https://www.nowcoder.com/test/question/done?tid=10037688&amp;qid=104799#summary">分析</a><br>身高差最小，将两个差不多的身高的站一块。
如 9 8 7 6 6 7 8 9然后9和9再拉手不就可以了吗 ！所以将数据输入一个数组如【8 9 7 6 5 4 3 2】然后排序【2 3 4 5 6 7 8 9】然后遍历数组进入一个队列一个栈 现规定，索引为0,2,4，，，的依次进入队列Q1，索引为1,3,5，，，，的依次进入//栈S1，就形成一个队列2 4 6 8 （队列尾为8）和一个栈3 5 7 9（栈顶为9） 。然后出栈9 7 5 3依次进入队列尾 形成 2 4 6 8 9 7 5 3 就排队成功，2和3拉手就成圈，求每个元素与挨着的距离就可以了。<br>分析2：<br>动态规划，先将所有的小朋友按低到高排序，dp[i] 表示前i个小朋友最优排列的最大身高差，递推公式为： dp[i+1]=max(dp[i],arr[i+1]-arr[i-1])。  </p>
<p><strong>3.逃离农场</strong><br>题目描述：<br>牛牛在农场饲养了n只奶牛,依次编号为0到n-1, 牛牛的好朋友羊羊帮牛牛照看着农场.有一天羊羊看到农场中逃走了k只奶牛,但是他只会告诉牛牛逃走的k只奶牛的编号之和能被n整除。你现在需要帮牛牛计算有多少种不同的逃走的奶牛群。因为结果可能很大,输出结果对1,000,000,007取模。<br>例如n = 7 k = 4:<br>7只奶牛依次编号为0到6, 逃走了4只<br>编号和为7的有:{0, 1, 2, 4}<br>编号和为14的有:{0, 3, 5, 6}, {1, 2, 5, 6}, {1, 3, 4, 6},{2, 3, 4, 5}<br>4只牛的编号和不会大于18,所以输出5。<br>分析：<br>动态规划，令<code>dp[i][j][s]</code>表示从区间[0,i]中取j个数字，使它们的和与n取模后余数为s，满足这样条件的集合的个数。<br>状态转移方程如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j][s] = (dp[i<span class="number">-1</span>][j][s] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>][(n+s-i)%n]);</div></pre></td></tr></table></figure></p>
<p>转移的过程就是第i个数取还是不取，如果不取，那么就和方法i-1的个数相同；<br>如果取第i个数的话，那么就需要分两种情况，因为第i个数可能大于s，也有可能小于等于s。<br><em>情况1：</em>若<code>i&lt;=s</code>,此时我们需要从前i-1个数中取j-1个数，使他们的和与n的模为s-i。这样就能保证在加入i时，和模n等于s。<br><em>情况2：</em>如果i&gt;s,那么i-s为负数，注意本题的要求是组成和为n的倍数，因此这种情况下需要将<code>(s-i)%n</code>表示为<code>（s-i+n）%n</code>，因为<code>((s-i+n)%n+i)%n=s</code>。<br>可以压缩空间，减少空间复杂度。代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> modMin=<span class="number">1e9</span>+<span class="number">7</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line">  </span>&#123;</div><div class="line">    <span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">1005</span>];</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> n,k;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">      &#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">           &#123;</div><div class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;=<span class="number">1</span>;j--)</div><div class="line">               &#123;</div><div class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;n;s++)</div><div class="line">                    &#123;</div><div class="line">                       dp[j][s]=(dp[j][s]+dp[j<span class="number">-1</span>][(n+s-i)%n])%modMin;</div><div class="line">                    &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">         <span class="built_in">cout</span>&lt;&lt;dp[k][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.牛牛的数列</strong><br>题目描述：<br>牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。<br>输入描述:<br>输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;<br>第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。<br>输出描述:<br>输出一个整数,表示最长的长度。<br>输入例子:<br>6<br>7 2 3 1 5 6<br>输出例子:<br>5<br>分析：<br>动态规划问题，题目中改变一个数字所能达到的严格上升子序列的最大长度，可以假设有两段上升子序列，它们中间可以改变一个数字，使他们连接起来，找到它们之间最长的就行了。<br>因此，设<code>dp1[i]</code>表示i结尾的最长上升子序列的长度，<code>dp2[i]</code>表示以i开始的最长上升子序列长度。分别从前或从后扫描计算即可。<br>然后，扫描数列，对于第i个数，i是第一个数，那么长度为<code>dp2[i+1]+1</code>，如果i为最后一个数，那么长度为<code>dp1[i-1]+1</code>，其他情况，如果i+1的值与i-1之间差值大于1，那么长度为<code>dp2[i+1]+dp1[i-1]+1</code>，如果不大于1只能在前或者在后取一个值了，长度为<code>max(dp2[i+1]+1,dp1[i-1]+1)</code>。<br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> dp[maxn], dp1[maxn];</div><div class="line"><span class="keyword">int</span> data[maxn];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; data[i];</div><div class="line">    &#125;</div><div class="line">    dp[n - <span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//以i开始的上升子序列的长度</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (data[i] &lt; data[i + <span class="number">1</span>])</div><div class="line">            dp[i] = dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            dp[i] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    dp1[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)<span class="comment">//以i结尾的上升子序列的长度</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (data[i]&gt;data[i - <span class="number">1</span>])</div><div class="line">            dp1[i] = dp1[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            dp1[i] = <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>, m = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            m = dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            m = dp1[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data[i - <span class="number">1</span>] + <span class="number">1</span> &lt; data[i + <span class="number">1</span>])</div><div class="line">        &#123;</div><div class="line">            m = dp1[i - <span class="number">1</span>] + dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            m = max(dp[i + <span class="number">1</span>] + <span class="number">1</span>, dp1[i - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (m &gt; ret)</div><div class="line">            ret = m;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>5.创造新世界</strong><br><div class="note default"><p>众所周知计算机代码底层计算都是0和1的计算，牛牛知道这点之后就想使用0和1创造一个新世界！牛牛现在手里有n个0和m个1，给出牛牛可以创造的x种物品，每种物品都由一个01串表示。牛牛想知道当前手中的0和1可以最多创造出多少种物品。<br><em>输入描述</em><br>输入数据包括x+1行：<br>第一行包括三个整数x(2 ≤ x ≤ 20)，n(0 ≤ n ≤ 500)，m(0 ≤ m ≤ 500)，以空格分隔<br>接下来的x行，每行一个01串item[i]，表示第i个物品。每个物品的长度length(1 ≤ length ≤ 50)<br><em>输出描述</em><br>输出一个整数，表示牛牛最多能创造多少种物品  </p>
</div><br>分析：<br>典型的二维背包问题：<br>对于每件物品,当选择这件物品必须同时付出两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。<br>设第i件物品所需的两种代价分别为<code>a[i]</code>和<code>b[i]</code>，两种代价可付出的最大值（两种背包容量）分别为u和v。物品的价值为<code>w[i]</code>。状态转移方程：<br><code>dp[i][u][v] = max(dp[i-1][u][v] , w[i] + dp[i-1][u-a[i]][v-b[i]])</code><br>同样的进行空间压缩，我们可以得到二维数组的状态转移方程，u，v采用倒序，如下：
<code>dp[u][v] = max(dp[u-a[i]][v-b[i]]+w[i],dp[u][v])</code><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s_item</div><div class="line">&#123;</div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    <span class="keyword">int</span> _zero;</div><div class="line">    <span class="keyword">int</span> _one;</div><div class="line">    s_item()&#123; _zero = <span class="number">0</span>; _one = <span class="number">0</span>; str = <span class="string">""</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution_CreateWorld</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    s_item item[<span class="number">25</span>];</div><div class="line">    <span class="keyword">int</span> x, n, m;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; n &gt;&gt; m;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; item[i].str;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; item[i].str.size(); ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (item[i].str[j] == <span class="string">'0'</span>)</div><div class="line">                ++item[i]._zero;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item[i].str[j] == <span class="string">'1'</span>)</div><div class="line">                ++item[i]._one;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</div><div class="line">        &#123;</div><div class="line">            dp[i][j] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= item[i]._zero; --j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = m; k &gt;= item[i]._one; --k)</div><div class="line">            &#123;</div><div class="line">                dp[j][k] = max(dp[j - item[i]._zero][k - item[i]._one] + <span class="number">1</span>, dp[j][k]);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>6.优美的回文串</strong><br><div class="note info"><p>牛牛在书上看到一种字符串叫做回文串,当一个字符串从左到右和从右到左读都是一样的,就称这个字符串为回文串。牛牛又从好朋友羊羊那里了解到一种被称为优美的回文串的字符串,考虑一个长度为N只包含大写字母的字符串,写出它所有长度为M的连续子串(包含所有可能的起始位置的子串,相同的子串也要计入),如果这个字符串至少有K个子串都是回文串,我们就叫这个字符串为优美的回文串。现在给出一个N,牛牛希望你能帮他计算出长度为N的字符串有多少个是优美的回文串(每个位置都可以是’A’~’Z’的一个。)<br><em>输入描述:</em><br>输入数据包括三个整数N, M, K(2 ≤ N ≤ 11, 2 ≤ M ≤ N, 0 ≤ K ≤ 11).<br><em>输出描述:</em><br>输出一个整数,表示所求的字符串个数.<br><em>输入例子:</em><br>2 2 1<br><em>输出例子:</em><br>26 长度为2的字符串,它长度为2的子串只有它自身。长度为2的回文串有”AA”,”BB”,”CC”…”ZZ”,一共26种。  </p>
</div>
<a href="http://blog.csdn.net/scruelt/article/details/65940130?locationNum=1&amp;fps=1">参考</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客网上的2017年校招全国统一模拟试题的编程题目，比较难的一些题目汇总，做下记录。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读3：定时器</title>
    <link href="http://abumaster.com/2017/08/01/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://abumaster.com/2017/08/01/libev源码阅读3：定时器/</id>
    <published>2017-08-01T06:51:24.000Z</published>
    <updated>2017-08-01T13:12:55.814Z</updated>
    
    <content type="html"><![CDATA[<p>定时器作为libev的一个重要监测器，用于超时处理和周期执行任务，通过4叉最小堆管理定时器，据说高效利用CPU缓存。  </p>
<a id="more"></a>
<h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><p>堆是一种树形结构，分为最大堆和最小堆，分别是根节点是最大元素或最小元素，stl中利用二叉大顶堆实现优先级队列以及堆算法。<br>堆的节点一般存放在数组中，在数组的排列有一定的规律，堆没有节点漏洞，按层依次排列的，如堆是从数组array的索引为1的位置开始排列，那么某个节点位于i的位置，其左孩子位于2i处，右孩子位于2i+1处，父节点位于i/2处（/ 为取整）。从0开始排列，节点i的左右孩子节点的索引分别为2i+1，2i+2，父节点为(i-1)/2 。n叉堆的孩子[ni+1,…,ni+n]<br>对于堆的调整，一般用到向上调整和向下调整两种方式，下面结合代码详细注释。  </p>
<h4 id="四叉堆"><a href="#四叉堆" class="headerlink" title="四叉堆"></a>四叉堆</h4><p>libev中的四叉堆的根节点索引是3，从3开始依次向后排列，那么i节点的孩子的范围为[4(i-3)+1+3,…,4(i-3)+4+3]，父节点为(i-3-1)/4+3 。<br>堆元素的结构
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用缓存的情况下</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ev_tstamp at;</div><div class="line">    WT w;</div><div class="line">  &#125; ANHE;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_w(he)        (he).w     <span class="comment">/* access watcher, read-write */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_at(he)       (he).at    <span class="comment">/* access cached at, read-only */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_at_cache(he) (he).at = (he).w-&gt;at <span class="comment">/* update at from watcher */</span></span></div></pre></td></tr></table></figure></p>
<p>堆算法实现如下：<br><strong>downheap 函数：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_4HEAP <span class="comment">//如果定义了4叉堆</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DHEAP 4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP0 (DHEAP - 1) <span class="comment">/* index of first element in heap */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HPARENT(k) ((((k) - HEAP0 - 1) / DHEAP) + HEAP0) <span class="comment">//获得k的父节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UPHEAP_DONE(p,k) ((p) == (k)) <span class="comment">//是否更新完成</span></span></div><div class="line"></div><div class="line"><span class="comment">//从根向下调整，N为堆的元素个数，k表示要调整元素的索引</span></div><div class="line"><span class="function">inline_speed <span class="keyword">void</span></div><div class="line"><span class="title">downheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">    ANHE he = heap [k];<span class="comment">//先获得调整</span></div><div class="line">    ANHE *E = heap + N + HEAP0;<span class="comment">//结束的指针</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">        ev_tstamp minat; <span class="comment">//最小的元素</span></div><div class="line">        ANHE *minpos; <span class="comment">//最小元素的指针</span></div><div class="line">        ANHE *pos = heap + DHEAP * (k - HEAP0) + HEAP0 + <span class="number">1</span>;<span class="comment">//k的第一个孩子的指针</span></div><div class="line"></div><div class="line">        <span class="comment">//查找k的最小孩子</span></div><div class="line">        <span class="keyword">if</span> (expect_true (pos + DHEAP - <span class="number">1</span> &lt; E))<span class="comment">//最后一个孩子没有越界，有四个孩子</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在四个孩子中找最小的</span></div><div class="line">            (minpos = pos + <span class="number">0</span>), (minat = ANHE_at (*minpos));<span class="comment">//设置初值</span></div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">1</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">1</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">2</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">2</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">3</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">3</span>), (minat = ANHE_at (*minpos));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; E)<span class="comment">//有孩子，但是不是4个孩子</span></div><div class="line">        &#123;</div><div class="line">            (minpos = pos + <span class="number">0</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">1</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">1</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">1</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">2</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">2</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">2</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">3</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">3</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">3</span>), (minat = ANHE_at (*minpos));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="comment">//其他情况，没孩子，不用调整退出循环</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//当前节点小于最小孩子，已经是最小堆，不用调整退出</span></div><div class="line">        <span class="keyword">if</span> (ANHE_at (he) &lt;= minat)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//否则将最小元素调到k的位置</span></div><div class="line">        heap [k] = *minpos;</div><div class="line">        ev_active (ANHE_w (*minpos)) = k;<span class="comment">//将时间监测器设置为索引k</span></div><div class="line"></div><div class="line">        k = minpos - heap;<span class="comment">//设置下一次调整的根节点</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    heap [k] = he;<span class="comment">//将元素填充到k中</span></div><div class="line">    ev_active (ANHE_w (he)) = k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有定义四叉堆的宏，那么就是简单的二叉堆的定义和调整。<br><strong>upheap 函数：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从k向根调整</span></div><div class="line"><span class="function">inline_speed <span class="keyword">void</span></div><div class="line"><span class="title">upheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">    ANHE he = heap [k];<span class="comment">//先记录k位置的元素</span></div><div class="line">    <span class="comment">//循环调整</span></div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> p = HPARENT (k);<span class="comment">//获得k的父节点</span></div><div class="line">        <span class="comment">//是否等于父节点（调整完成）或者父节点的元素小于当前的</span></div><div class="line">        <span class="keyword">if</span> (UPHEAP_DONE (p, k) || ANHE_at (heap [p]) &lt;= ANHE_at (he))</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        heap [k] = heap [p];<span class="comment">//</span></div><div class="line">        ev_active (ANHE_w (heap [k])) = k;</div><div class="line">        k = p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  heap [k] = he;</div><div class="line">  ev_active (ANHE_w (he)) = k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>adjust 和 reheap 函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* move an element suitably so it is in a correct place */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span></div><div class="line"><span class="title">adjustheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (k &gt; HEAP0 &amp;&amp; ANHE_at (heap [k]) &lt;= ANHE_at (heap [HPARENT (k)]))</div><div class="line">    upheap (heap, k);<span class="comment">//k的元素小于父节点的元素，向上调整</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    downheap (heap, N, k);<span class="comment">//向下调整</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* rebuild the heap: this function is used only once and executed rarely */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span></div><div class="line"><span class="title">reheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">  <span class="comment">/* we don't use floyds algorithm, upheap is simpler and is more cache-efficient */</span></div><div class="line">  <span class="comment">/* also, this is easy to implement and correct for both 2-heaps and 4-heaps */</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i)<span class="comment">//直接向上调整，简单高效</span></div><div class="line">    upheap (heap, i + HEAP0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="超时监视器"><a href="#超时监视器" class="headerlink" title="超时监视器"></a>超时监视器</h4><p><strong>基本数据结构</strong><br>相对时间。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_timer</div><div class="line">&#123;</div><div class="line">    <span class="comment">//EV_WATCHER_TIME (ev_timer)</span></div><div class="line">    <span class="keyword">int</span> active;   </div><div class="line">    <span class="keyword">int</span> pending;  </div><div class="line">    <span class="keyword">int</span> priority;  </div><div class="line">    <span class="keyword">void</span> *data;  </div><div class="line">    <span class="keyword">void</span> (*cb)(<span class="keyword">struct</span> ev_loop *loop, <span class="keyword">struct</span> ev_timer *w, <span class="keyword">int</span> revents);    </div><div class="line">  </div><div class="line">    ev_tstamp at; <span class="comment">//定时器第一次触发的时间点</span></div><div class="line">    ev_tstamp repeat; <span class="comment">/* rw */</span> <span class="comment">//每隔几秒触发一次，0表示只触发一次</span></div><div class="line">&#125; ev_timer;</div></pre></td></tr></table></figure></p>
<p><strong>初始化超时监视器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化，调用两个宏来初始化成员</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_timer_init(ev,cb,after,repeat) \</div><div class="line">do &#123; ev_init ((ev), (cb)); \</div><div class="line">    ev_timer_set ((ev),(after),(repeat)); \</div><div class="line">    &#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_init(ev,cb_) do &#123;            \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;active  =   \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;pending = 0;    \</div><div class="line">  ev_set_priority ((ev), 0);            \</div><div class="line">  ev_set_cb ((ev), cb_);            \</div><div class="line">&#125; while (0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_timer_set(ev,after_,repeat_)      \</div><div class="line">do &#123; ((ev_watcher_time *)(ev))-&gt;at = (after_); \</div><div class="line">    (ev)-&gt;repeat = (repeat_); &#125; while (0)</span></div></pre></td></tr></table></figure></p>
<p><strong>启动超时器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">noinline</div><div class="line"><span class="keyword">void</span></div><div class="line"><span class="title">ev_timer_start</span> <span class="params">(EV_P_ ev_timer *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (expect_false (ev_is_active (w)))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    ev_at (w) += mn_now;<span class="comment">//设置at时间点，此时间点触发，相对于mn_now，当前日历时间</span></div><div class="line"></div><div class="line">    assert ((<span class="string">"libev: ev_timer_start called with negative timer repeat value"</span>, w-&gt;repeat &gt;= <span class="number">0.</span>));</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">    <span class="comment">//将timer加入到堆中并向上调整，active表示的是堆数组中的下标</span></div><div class="line">    ++timercnt;</div><div class="line">    ev_start (EV_A_ (W)w, timercnt + HEAP0 - <span class="number">1</span>);</div><div class="line">    array_needsize (ANHE, timers, timermax, ev_active (w) + <span class="number">1</span>, EMPTY2);</div><div class="line">    ANHE_w (timers [ev_active (w)]) = (WT)w;</div><div class="line">    ANHE_at_cache (timers [ev_active (w)]);</div><div class="line">    upheap (timers, ev_active (w));</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">    <span class="comment">/*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>停止计时器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">noinline</div><div class="line"><span class="keyword">void</span></div><div class="line"><span class="title">ev_timer_stop</span> <span class="params">(EV_P_ ev_timer *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    clear_pending (EV_A_ (W)w);<span class="comment">//从pending中移除</span></div><div class="line">    <span class="keyword">if</span> (expect_false (!ev_is_active (w)))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> active = ev_active (w);<span class="comment">//获得定时器在堆中的索引</span></div><div class="line">        assert ((<span class="string">"libev: internal timer heap corruption"</span>, ANHE_w (timers [active]) == (WT)w));</div><div class="line">        --timercnt;<span class="comment">//数量减一</span></div><div class="line">        <span class="keyword">if</span> (expect_true (active &lt; timercnt + HEAP0))</div><div class="line">        &#123;</div><div class="line">            timers [active] = timers [timercnt + HEAP0];<span class="comment">//最后一个元素补充上来</span></div><div class="line">            adjustheap (timers, timercnt, active);<span class="comment">//调整</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ev_at (w) -= mn_now;</div><div class="line">    ev_stop (EV_A_ (W)w);</div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="周期定时器"><a href="#周期定时器" class="headerlink" title="周期定时器"></a>周期定时器</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时器作为libev的一个重要监测器，用于超时处理和周期执行任务，通过4叉最小堆管理定时器，据说高效利用CPU缓存。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读2：运行流程</title>
    <link href="http://abumaster.com/2017/07/31/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/07/31/libev源码阅读2：运行流程/</id>
    <published>2017-07-31T10:39:49.000Z</published>
    <updated>2017-07-31T13:38:14.246Z</updated>
    
    <content type="html"><![CDATA[<p>一般的流程：创建默认的事件循环，创建一个事件监测器和回调函数并初始化（init），将监测器放入事件循环（start）中，循环开始等待事件（run）的到来。<br><a id="more"></a></p>
<p><strong>1.主要流程</strong><br>如果在libev中创建一个IO监测器，主循环等待IO事件的触发，触发后调用回调函数，执行相关操作。其主要流程如下：  </p>
<ul>
<li>首先调用<code>ev_default_loop</code>初始化<code>struct  ev_loop</code>结构；  </li>
<li>然后调用<code>ev_io_init</code>初始化监视器中的属性，该宏主要就是调用<code>ev_init</code>和<code>ev_io_set</code>；  </li>
<li>然后调用<code>ev_io_start</code>启动该监视器，该函数主要是将监视器添加到<code>loop-&gt;anfds</code>结构中，将监视的描述符添加到<code>((loop)-&gt;fdchanges)</code>中；</li>
<li>调用<code>ev_run</code>开始等待事件的触发。</li>
</ul>
<p>使用，官方提供的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a single header file is required</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ev.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // for puts</span></span></div><div class="line"><span class="comment">// every watcher type has its own typedef'd struct</span></div><div class="line"><span class="comment">// with the name ev_TYPE</span></div><div class="line">ev_io stdin_watcher;</div><div class="line">ev_timer timeout_watcher;</div><div class="line"><span class="comment">// all watcher callbacks have a similar signature</span></div><div class="line"><span class="comment">// this callback is called when data is readable on stdin</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">stdin_cb</span> <span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="built_in">puts</span> (<span class="string">"stdin ready"</span>);</div><div class="line">  <span class="comment">// for one-shot events, one must manually stop the watcher</span></div><div class="line">  <span class="comment">// with its corresponding stop function.</span></div><div class="line">  ev_io_stop (EV_A_ w);</div><div class="line">  <span class="comment">// this causes all nested ev_run's to stop iterating</span></div><div class="line">  ev_break (EV_A_ EVBREAK_ALL);</div><div class="line">&#125;</div><div class="line"><span class="comment">// another callback, this time for a time-out</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">timeout_cb</span> <span class="params">(EV_P_ ev_timer *w, <span class="keyword">int</span> revents)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="built_in">puts</span> (<span class="string">"timeout"</span>);</div><div class="line">  <span class="comment">// this causes the innermost ev_run to stop iterating</span></div><div class="line">  ev_break (EV_A_ EVBREAK_ONE);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="comment">// use the default event loop unless you have special needs</span></div><div class="line">  <span class="keyword">struct</span> ev_loop *loop = EV_DEFAULT;</div><div class="line">  <span class="comment">// initialise an io watcher, then start it</span></div><div class="line">  <span class="comment">// this one will watch for stdin to become readable</span></div><div class="line">  ev_io_init (&amp;stdin_watcher, stdin_cb, <span class="comment">/*STDIN_FILENO*/</span> <span class="number">0</span>, EV_READ);</div><div class="line">  ev_io_start (loop, &amp;stdin_watcher);</div><div class="line">  <span class="comment">// initialise a timer watcher, then start it</span></div><div class="line">  <span class="comment">// simple non-repeating 5.5 second timeout</span></div><div class="line">  ev_timer_init (&amp;timeout_watcher, timeout_cb, <span class="number">5.5</span>, <span class="number">0.</span>);</div><div class="line">  ev_timer_start (loop, &amp;timeout_watcher);</div><div class="line">  <span class="comment">// now wait for events to arrive</span></div><div class="line">  ev_run (loop, <span class="number">0</span>);</div><div class="line">  <span class="comment">// break was called, so exit</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中有几个奇怪的宏<code>EV_P EV_P_ EV_A EV_A_</code>，它们代表了：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EV_P  == <span class="keyword">struct</span> ev_loop* loop <span class="comment">//event parameter</span></div><div class="line">EV_P_ == EV_P, == <span class="keyword">struct</span> ev_loop* loop, </div><div class="line">EV_A  == loop <span class="comment">//event argument</span></div><div class="line">EV_A_ == EV_A, == loop,</div></pre></td></tr></table></figure></p>
<p><strong>2.ev_default_loop 函数</strong><br>假设定义了EV_MULTIPLICITY，多循环支持，返回一个ev_loop结构指针，否则返回一个整数。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> ev_loop * <span class="title">ev_default_loop</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (!ev_default_loop_ptr)</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_MULTIPLICITY</span></div><div class="line">      EV_P = ev_default_loop_ptr = &amp;default_loop_struct;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">      ev_default_loop_ptr = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//调用此函数初始化</span></div><div class="line">    loop_init (EV_A_ flags);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ev_backend (EV_A))</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_CHILD_ENABLE</span></div><div class="line">          ev_signal_init (&amp;childev, childcb, SIGCHLD);</div><div class="line">          ev_set_priority (&amp;childev, EV_MAXPRI);</div><div class="line">          ev_signal_start (EV_A_ &amp;childev);</div><div class="line">          ev_unref (EV_A); <span class="comment">/* child watcher should not keep loop alive */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ev_default_loop_ptr = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> ev_default_loop_ptr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以下是loop_init函数，初始化loop中的各个成员</span></div><div class="line"><span class="comment">/* initialise a loop structure, must be zero-initialised */</span></div><div class="line"><span class="function">noinline ecb_cold</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">loop_init</span> <span class="params">(EV_P_ <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (!backend)</div><div class="line">    &#123;</div><div class="line">        origflags = flags;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_REALTIME</span></div><div class="line">        <span class="keyword">if</span> (!have_realtime)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">struct</span> timespec ts;</div><div class="line">            <span class="keyword">if</span> (!clock_gettime (CLOCK_REALTIME, &amp;ts))</div><div class="line">                have_realtime = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_MONOTONIC</span></div><div class="line">        <span class="keyword">if</span> (!have_monotonic)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">struct</span> timespec ts;</div><div class="line">            <span class="keyword">if</span> (!clock_gettime (CLOCK_MONOTONIC, &amp;ts))</div><div class="line">                have_monotonic = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></div><div class="line">        <span class="keyword">if</span> (flags &amp; EVFLAG_FORKCHECK)</div><div class="line">            curpid = getpid ();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(flags &amp; EVFLAG_NOENV)</div><div class="line">          &amp;&amp; !enable_secure ()</div><div class="line">          &amp;&amp; getenv (<span class="string">"LIBEV_FLAGS"</span>))</div><div class="line">            flags = atoi (getenv (<span class="string">"LIBEV_FLAGS"</span>));</div><div class="line"></div><div class="line">        ev_rt_now          = ev_time ();</div><div class="line">        mn_now             = get_clock ();</div><div class="line">        now_floor          = mn_now;</div><div class="line">        rtmn_diff          = ev_rt_now - mn_now;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">        invoke_cb          = ev_invoke_pending;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        io_blocktime       = <span class="number">0.</span>;</div><div class="line">        timeout_blocktime  = <span class="number">0.</span>;</div><div class="line">        backend            = <span class="number">0</span>;</div><div class="line">        backend_fd         = <span class="number">-1</span>;</div><div class="line">        sig_pending        = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_ASYNC_ENABLE</span></div><div class="line">        async_pending      = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        pipe_write_skipped = <span class="number">0</span>;</div><div class="line">        pipe_write_wanted  = <span class="number">0</span>;</div><div class="line">        evpipe [<span class="number">0</span>]         = <span class="number">-1</span>;</div><div class="line">        evpipe [<span class="number">1</span>]         = <span class="number">-1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_INOTIFY</span></div><div class="line">        fs_fd              = flags &amp; EVFLAG_NOINOTIFY ? <span class="number">-1</span> : <span class="number">-2</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_SIGNALFD</span></div><div class="line">        sigfd              = flags &amp; EVFLAG_SIGNALFD  ? <span class="number">-2</span> : <span class="number">-1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(flags &amp; EVBACKEND_MASK))</div><div class="line">            flags |= ev_recommended_backends ();</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_IOCP</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_IOCP  )) backend = iocp_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_PORT</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_PORT  )) backend = port_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_KQUEUE</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_KQUEUE)) backend = kqueue_init (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_EPOLL</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_EPOLL )) backend = epoll_init  (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_POLL</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_POLL  )) backend = poll_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_SELECT</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_SELECT)) backend = select_init (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="comment">//如上一章介绍的函数，初始化调用前事件，准备好了，其实什么也没做</span></div><div class="line">        <span class="comment">//表示在此期间等待监测器到来</span></div><div class="line">        ev_prepare_init (&amp;pending_w, pendingcb);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE</span></div><div class="line">        ev_init (&amp;pipe_w, pipecb);<span class="comment">//初始化监测器的pipe</span></div><div class="line">        ev_set_priority (&amp;pipe_w, EV_MAXPRI);<span class="comment">//设置为最大优先级</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.ev_io_init 函数</strong><br>初始化io监测器，初始化结构中的成员，上一节中介绍了。<br><strong>4.ev_io_start 函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_io_start</span> <span class="params">(EV_P_ ev_io *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">int</span> fd = w-&gt;fd;<span class="comment">//获得监视器的描述符</span></div><div class="line">  <span class="comment">//监视器没开始</span></div><div class="line">  <span class="keyword">if</span> (expect_false (ev_is_active (w)))</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with negative fd"</span>, fd &gt;= <span class="number">0</span>));</div><div class="line">  <span class="comment">//屏蔽其他的</span></div><div class="line">  <span class="comment">//0x80 0x01 0x02 events的取值</span></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with illegal event mask"</span>, !(w-&gt;events &amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));</div><div class="line"></div><div class="line">  EV_FREQUENT_CHECK;</div><div class="line">  <span class="comment">//调整优先级并设置为活动状态，</span></div><div class="line">  ev_start (EV_A_ (W)w, <span class="number">1</span>);</div><div class="line">  <span class="comment">//调整loop-&gt;anfds数组的大小，并将监测器加入到[fd]的链表中</span></div><div class="line">  array_needsize (ANFD, anfds, anfdmax, fd + <span class="number">1</span>, array_init_zero);</div><div class="line">  wlist_add (&amp;anfds[fd].head, (WL)w);</div><div class="line"></div><div class="line">  <span class="comment">/* common bug, apparently */</span></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with corrupted watcher"</span>, ((WL)w)-&gt;next != (WL)w));</div><div class="line"></div><div class="line">  fd_change (EV_A_ fd, w-&gt;events &amp; EV__IOFDSET | EV_ANFD_REIFY);</div><div class="line">  w-&gt;events &amp;= ~EV__IOFDSET;<span class="comment">//掩码消除</span></div><div class="line">  EV_FREQUENT_CHECK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//fd_change函数</span></div><div class="line"><span class="comment">/* something about the given fd changed */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span> <span class="title">fd_change</span> <span class="params">(EV_P_ <span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> reify = anfds [fd].reify;</div><div class="line">  anfds [fd].reify |= flags;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (expect_true (!reify))<span class="comment">//以前不存在，调整大小加入变化数组中</span></div><div class="line">    &#123;</div><div class="line">      ++fdchangecnt;</div><div class="line">      array_needsize (<span class="keyword">int</span>, fdchanges, fdchangemax, fdchangecnt, EMPTY2);</div><div class="line">      fdchanges [fdchangecnt - <span class="number">1</span>] = fd;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.ev_run 函数</strong><br>主要功能循环等待事件的到来。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ev_run</span> <span class="params">(EV_P_ <span class="keyword">int</span> flags)</span></div><div class="line"></span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">  ++loop_depth;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  assert ((<span class="string">"libev: ev_loop recursion during release detected"</span>, loop_done != EVBREAK_RECURSE));</div><div class="line">  loop_done = EVBREAK_CANCEL;</div><div class="line"></div><div class="line">  EV_INVOKE_PENDING; <span class="comment">/* in case we recurse, ensure ordering stays nice and clean */</span></div><div class="line"></div><div class="line">  <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_VERIFY &gt;= 2</span></div><div class="line">      ev_verify (EV_A);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></div><div class="line">      <span class="keyword">if</span> (expect_false (curpid)) <span class="comment">/* penalise the forking check even more */</span></div><div class="line">        <span class="keyword">if</span> (expect_false (getpid () != curpid))</div><div class="line">          &#123;</div><div class="line">            curpid = getpid ();</div><div class="line">            postfork = <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FORK_ENABLE</span></div><div class="line">      <span class="comment">/* we might have forked, so queue fork handlers */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (postfork))</div><div class="line">        <span class="keyword">if</span> (forkcnt)</div><div class="line">          &#123;</div><div class="line">            queue_events (EV_A_ (W *)forks, forkcnt, EV_FORK);</div><div class="line">            EV_INVOKE_PENDING;</div><div class="line">          &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PREPARE_ENABLE</span></div><div class="line">      <span class="comment">/* queue prepare watchers (and execute them) */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (preparecnt))</div><div class="line">        &#123;</div><div class="line">          queue_events (EV_A_ (W *)prepares, preparecnt, EV_PREPARE);</div><div class="line">          EV_INVOKE_PENDING;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (expect_false (loop_done))</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* we might have forked, so reify kernel state if necessary */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (postfork))</div><div class="line">        loop_fork (EV_A);</div><div class="line"></div><div class="line">      <span class="comment">//检测fd</span></div><div class="line">      fd_reify (EV_A);</div><div class="line"></div><div class="line">      <span class="comment">/* 计算阻塞的时间 */</span></div><div class="line">      &#123;</div><div class="line">        ev_tstamp waittime  = <span class="number">0.</span>;</div><div class="line">        ev_tstamp sleeptime = <span class="number">0.</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* remember old timestamp for io_blocktime calculation */</span></div><div class="line">        ev_tstamp prev_mn_now = mn_now;</div><div class="line"></div><div class="line">        <span class="comment">/* update time to cancel out callback processing overhead */</span></div><div class="line">        time_update (EV_A_ <span class="number">1e100</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* from now on, we want a pipe-wake-up */</span></div><div class="line">        pipe_write_wanted = <span class="number">1</span>;</div><div class="line"></div><div class="line">        ECB_MEMORY_FENCE; <span class="comment">/* make sure pipe_write_wanted is visible before we check for potential skips */</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (expect_true (!(flags &amp; EVRUN_NOWAIT || idleall || !activecnt || pipe_write_skipped)))</div><div class="line">          &#123;</div><div class="line">            waittime = MAX_BLOCKTIME;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timercnt)</div><div class="line">              &#123;</div><div class="line">                ev_tstamp to = ANHE_at (timers [HEAP0]) - mn_now;</div><div class="line">                <span class="keyword">if</span> (waittime &gt; to) waittime = to;</div><div class="line">              &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PERIODIC_ENABLE</span></div><div class="line">            <span class="keyword">if</span> (periodiccnt)</div><div class="line">              &#123;</div><div class="line">                ev_tstamp to = ANHE_at (periodics [HEAP0]) - ev_rt_now;</div><div class="line">                <span class="keyword">if</span> (waittime &gt; to) waittime = to;</div><div class="line">              &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">            <span class="comment">/* don't let timeouts decrease the waittime below timeout_blocktime */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (waittime &lt; timeout_blocktime))</div><div class="line">              waittime = timeout_blocktime;</div><div class="line"></div><div class="line">            <span class="comment">/* at this point, we NEED to wait, so we have to ensure */</span></div><div class="line">            <span class="comment">/* to pass a minimum nonzero value to the backend */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (waittime &lt; backend_mintime))</div><div class="line">              waittime = backend_mintime;</div><div class="line"></div><div class="line">            <span class="comment">/* extra check because io_blocktime is commonly 0 */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (io_blocktime))</div><div class="line">              &#123;</div><div class="line">                sleeptime = io_blocktime - (mn_now - prev_mn_now);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (sleeptime &gt; waittime - backend_mintime)</div><div class="line">                  sleeptime = waittime - backend_mintime;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (expect_true (sleeptime &gt; <span class="number">0.</span>))</div><div class="line">                  &#123;</div><div class="line">                    ev_sleep (sleeptime);</div><div class="line">                    waittime -= sleeptime;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">        ++loop_count;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        assert ((loop_done = EVBREAK_RECURSE, <span class="number">1</span>)); <span class="comment">/* assert for side effect */</span></div><div class="line">        backend_poll (EV_A_ waittime);</div><div class="line">        assert ((loop_done = EVBREAK_CANCEL, <span class="number">1</span>)); <span class="comment">/* assert for side effect */</span></div><div class="line"></div><div class="line">        pipe_write_wanted = <span class="number">0</span>; <span class="comment">/* just an optimisation, no fence needed */</span></div><div class="line"></div><div class="line">        ECB_MEMORY_FENCE_ACQUIRE;</div><div class="line">        <span class="keyword">if</span> (pipe_write_skipped)</div><div class="line">          &#123;</div><div class="line">            assert ((<span class="string">"libev: pipe_w not active, but pipe not written"</span>, ev_is_active (&amp;pipe_w)));</div><div class="line">            ev_feed_event (EV_A_ &amp;pipe_w, EV_CUSTOM);</div><div class="line">          &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* update ev_rt_now, do magic */</span></div><div class="line">        time_update (EV_A_ waittime + sleeptime);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* queue pending timers and reschedule them */</span></div><div class="line">      timers_reify (EV_A); <span class="comment">/* relative timers called last */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PERIODIC_ENABLE</span></div><div class="line">      periodics_reify (EV_A); <span class="comment">/* absolute timers called first */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_IDLE_ENABLE</span></div><div class="line">      <span class="comment">/* queue idle watchers unless other events are pending */</span></div><div class="line">      idle_reify (EV_A);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_CHECK_ENABLE</span></div><div class="line">      <span class="comment">/* queue check watchers, to be executed first */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (checkcnt))</div><div class="line">        queue_events (EV_A_ (W *)checks, checkcnt, EV_CHECK);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">      EV_INVOKE_PENDING;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">while</span> (expect_true (</div><div class="line">    activecnt</div><div class="line">    &amp;&amp; !loop_done</div><div class="line">    &amp;&amp; !(flags &amp; (EVRUN_ONCE | EVRUN_NOWAIT))</div><div class="line">  ));</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (loop_done == EVBREAK_ONE)</div><div class="line">    loop_done = EVBREAK_CANCEL;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">  --loop_depth;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> activecnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的流程：创建默认的事件循环，创建一个事件监测器和回调函数并初始化（init），将监测器放入事件循环（start）中，循环开始等待事件（run）的到来。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读1：数据结构</title>
    <link href="http://abumaster.com/2017/07/31/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/07/31/libev源码阅读1：数据结构/</id>
    <published>2017-07-31T02:08:24.000Z</published>
    <updated>2017-07-31T07:32:55.837Z</updated>
    
    <content type="html"><![CDATA[<p>libev 是一个高性能事件循环网络库，用于开发高性能网络应用。  </p>
<a id="more"></a>
<p><strong>1.基础宏定义</strong><br>libev中的监视器数据结构的实现是用宏定义以及结构体来实现继承关系，基本的宏定义，展开。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 所有的监视器共有的数据 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER(type)            \</div><div class="line">  int active; <span class="comment">/* private */</span>         \</div><div class="line">  int pending; <span class="comment">/* private */</span>            \</div><div class="line">  <span class="comment">//EV_DECL_PRIORITY /* private */        \</span></span></div><div class="line">  <span class="keyword">int</span> priority; \</div><div class="line">  <span class="comment">//EV_COMMON /* rw */                \</span></div><div class="line">  <span class="keyword">void</span> *data; \</div><div class="line">  <span class="comment">//EV_CB_DECLARE (type) /* private */</span></div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER_LIST(type)           \</div><div class="line">  EV_WATCHER (type)             \</div><div class="line">  struct ev_watcher_list *next; <span class="comment">/* private */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER_TIME(type)           \</div><div class="line">  EV_WATCHER (type)             \</div><div class="line">  ev_tstamp at;     <span class="comment">/* private */</span></span></div></pre></td></tr></table></figure></p>
<p><strong>2.监视器基类</strong><br>由上面的宏定义可以推断，libev的监视器的实现是从watcher，watcher_list和watcher_time三类中派生出去，分为这三个大类，三个基类。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本监视器 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">&#125; ev_watcher;</div><div class="line"><span class="comment">//监视器链表 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher_list</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="comment">//list的下一个节点</span></div><div class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</div><div class="line">&#125; ev_watcher_list;</div><div class="line"><span class="comment">//时间监视器 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher_time</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="comment">//计时器时间</span></div><div class="line">  ev_tstamp at;</div><div class="line">&#125; ev_watcher_time;</div></pre></td></tr></table></figure></p>
<p><strong>3.监视的事件</strong><br>libev从三个监视器基类中派生出以下几种类，用于监视事件的变化，主要的分类和作用如下：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ev_io</code></td>
<td>IO 可读可写</td>
</tr>
<tr>
<td><code>ev_singnal</code></td>
<td>信号处理</td>
</tr>
<tr>
<td><code>ev_timer</code></td>
<td>定时器</td>
</tr>
<tr>
<td><code>ev_periodic</code></td>
<td>周期任务</td>
</tr>
<tr>
<td><code>ev_child</code></td>
<td>子进程状态变化</td>
</tr>
<tr>
<td><code>ev_fork</code></td>
<td>开辟子进程</td>
</tr>
<tr>
<td><code>ev_stat</code></td>
<td>文件属性变化</td>
</tr>
<tr>
<td><code>ev_async</code></td>
<td>激活线程</td>
</tr>
<tr>
<td><code>ev_cleanup</code></td>
<td>退出触发</td>
</tr>
<tr>
<td><code>ev_idle</code></td>
<td>空闲时执行</td>
</tr>
<tr>
<td><code>ev_embed</code></td>
<td>嵌入其他事件循环</td>
</tr>
<tr>
<td><code>ev_prepare</code></td>
<td>eventloop之前</td>
</tr>
<tr>
<td><code>ev_check</code></td>
<td>eventloop之后</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//io监视器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_io</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER_LIST (ev_io) //展开宏</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> fd;     <span class="comment">/* ro */</span></div><div class="line">  <span class="keyword">int</span> events; <span class="comment">/* ro */</span></div><div class="line">&#125; ev_io;</div><div class="line"><span class="comment">//定时器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_timer</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER_TIME (ev_timer) //展开</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  ev_tstamp at;</div><div class="line"></div><div class="line">  ev_tstamp repeat; <span class="comment">/* rw */</span></div><div class="line">&#125; ev_timer;</div><div class="line"><span class="comment">//空闲时触发</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_idle</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER (ev_idle) 展开</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line"></div><div class="line">&#125; ev_idle;</div></pre></td></tr></table></figure>
<p>关系图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-31/44673487.jpg" alt=""><br>这种继承关系，可以用指针进行类型自由转换。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-31/72453924.jpg" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//激活监测器，不管是何类型</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_start</span> <span class="params">(<span class="keyword">struct</span> ev_loop *loop, ev_watcher* w, <span class="keyword">int</span> active)</span>  </div><div class="line"></span>&#123;  </div><div class="line">  <span class="comment">//...  </span></div><div class="line">  w-&gt;active = active;  </div><div class="line">  <span class="comment">//...  </span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">wlist_add</span> <span class="params">(ev_watcher_list **head, ev_watcher_list *elem)</span>  </div><div class="line"></span>&#123;  </div><div class="line">  elem-&gt;next = *head;  </div><div class="line">  *head = elem;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_io_start</span> <span class="params">(<span class="keyword">struct</span> ev_loop *loop, ev_io *w)</span>  </div><div class="line"></span>&#123;   </div><div class="line">  <span class="comment">//将ev_io退化为ev_watcher使用这个ev_start函数</span></div><div class="line">  ev_start (loop, (ev_watcher*)w, <span class="number">1</span>);  </div><div class="line">  <span class="comment">//转换成ev_watcher_list指针插入到list中</span></div><div class="line">  wlist_add (&amp;anfds[fd].head, (ev_watcher_list *)w);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.监视事件的初始化和设置</strong><br>ev的设置也被定义为宏macro，提供了两种方式：  </p>
<ul>
<li><code>ev_init</code> 和 <code>ev_TYPE_set</code> 一起使用；  </li>
<li>使用 <code>ev_TYPE_init</code> 进行初始化。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_init(ev,cb_) do &#123;            \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;active  =   \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;pending = 0;    \</div><div class="line">  ev_set_priority ((ev), 0);            \</div><div class="line">  ev_set_cb ((ev), cb_);            \</div><div class="line">&#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_io_set(ev,fd_,events_)  \</div><div class="line"> do &#123; (ev)-&gt;fd = (fd_); (ev)-&gt;events = (events_) | EV__IOFDSET; &#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_io_init(ev,cb,fd,events)   \</div><div class="line"> do &#123; ev_init ((ev), (cb)); \</div><div class="line">    ev_io_set ((ev),(fd),(events)); &#125; while (0)</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;libev 是一个高性能事件循环网络库，用于开发高性能网络应用。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-容器</title>
    <link href="http://abumaster.com/2017/07/19/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8/"/>
    <id>http://abumaster.com/2017/07/19/STL源码剖析-容器/</id>
    <published>2017-07-19T07:04:58.000Z</published>
    <updated>2017-09-15T00:31:35.960Z</updated>
    
    <content type="html"><![CDATA[<h4 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h4><p><em>容器</em> 用于存放数据，数据在其中的排列具有一定的规律。STL中根据数据的排列方式将容器分为了 <strong>序列式容器</strong> 和 <strong>关联式容器</strong> 两种。其中的分类关系如下图所示：<br><a id="more"></a>
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/20670842.jpg" alt="">  </p>
<h4 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h4><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>vector连续线性空间存储，支持随机访问，类似数组。<br>vector的迭代器是一个T类型的原生指针；<br>vector的空间不是按需分配而是按照多分配的原则，比实际需要的空间要大，也就是说会保留一部分的备用空间用于插入元素，分别定义了三个迭代器指向了目前使用空间的头和尾，可用空间的尾。<code>start finish end_of_storage</code> 定义了函数 <code>size() 和 capacity</code> 分别表示使用空间的大小，以及最大容纳的大小；<br>vector的空间扩充，当没有足够的备用空间用于插入新的元素的时候，这时vecto需要进行空间的扩展，会申请一块原始大小二倍的新空间然后将旧的空间中的元素拷贝入新的空间，也就是说原始的迭代器在执行插入操作后会失效；<br>vector存在的缺点，就是可能浪费一部分空间。  </p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>list 在stl中的实现是一个双向链表，节点结构是有一个指向后一个节点和前一个节点的指针以及节点中的数据，每次插入和删除元素都要重新配置和释放节点，空间按需分配，插入操作不会改变迭代器。<br>list迭代器设计，内部依然是一个指针，指向了list的节点，内部定义了stl迭代器标准的接口，并实现了双向迭代器具有的操作，自增，自减，取值，比较等；<br>list数据结构，双向循环链表，一些操作就是链表的指针的移动；<br>一个内部函数<code>transfer(position, first, last)</code>将[first,last)内的元素移动到position之前。为splice、merge、sort提供基础。操作见图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/87239144.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (position != last) </div><div class="line">    &#123;</div><div class="line">        (*(link_type((*last.node).prev))).next = position.node; <span class="comment">// (1)</span></div><div class="line">        (*(link_type((*first.node).prev))).next = last.node; <span class="comment">// (2)</span></div><div class="line">        (*(link_type((*position.node).prev))).next = first.node; <span class="comment">// (3)</span></div><div class="line">        link_type tmp = link_type((*position.node).prev); <span class="comment">// (4)</span></div><div class="line">        (*position.node).prev = (*last.node).prev; <span class="comment">// (5)</span></div><div class="line">        (*last.node).prev = (*first.node).prev;  <span class="comment">// (6)</span></div><div class="line">        (*first.node).prev = tmp; <span class="comment">// (7)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>list 本身提供了排序的成员函数，不用stl算法（接受随机迭代器）。  </p>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>deque由一些列连续的空间组成，可以分别在头尾扩展插入。有一个中控器map指向连续的一段段的缓冲区。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/26926563.jpg" alt=""><br>deque的迭代器，包括了
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</div><div class="line">-----------------------------</div><div class="line">| cur | first | last | node |</div><div class="line">-----------------------------</div><div class="line">当前指向，缓冲区的开始和结束</div><div class="line">在map中的位置</div><div class="line">***/</span></div></pre></td></tr></table></figure></p>
<p>deque的数据结构，迭代器start指向第一个节点，finish指向最后一个节点，map指向中控器，是连续的空间，每个元素都是一个指针，指向了一个节点（缓冲区）。<br>在deque上进行元素操作时，考虑在中控器的移动。  </p>
<h5 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h5><p>stack先进后出，没有迭代器，queue先进先出，它们都是以deque为底部数据结构（默认），进行一定的限制保证它们各自的特性，不被称为容器，而是被称为配接器。  </p>
<h5 id="heap算法和优先级队列"><a href="#heap算法和优先级队列" class="headerlink" title="heap算法和优先级队列"></a>heap算法和优先级队列</h5><p>堆不是stl容器组件，但是却是优先级队列的底层实现。<br>它是一棵二叉树，根节点元素是最大或者最小元素，每次插入和取出根节点后都会重新排列保持它的这个特性。  </p>
<h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>主要有set集合和map映射表两种，底部以红黑二叉树实现。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;容器概述&quot;&gt;&lt;a href=&quot;#容器概述&quot; class=&quot;headerlink&quot; title=&quot;容器概述&quot;&gt;&lt;/a&gt;容器概述&lt;/h4&gt;&lt;p&gt;&lt;em&gt;容器&lt;/em&gt; 用于存放数据，数据在其中的排列具有一定的规律。STL中根据数据的排列方式将容器分为了 &lt;strong&gt;序列式容器&lt;/strong&gt; 和 &lt;strong&gt;关联式容器&lt;/strong&gt; 两种。其中的分类关系如下图所示：&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>像素反卷积网络</title>
    <link href="http://abumaster.com/2017/07/11/%E5%83%8F%E7%B4%A0%E5%8F%8D%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://abumaster.com/2017/07/11/像素反卷积网络/</id>
    <published>2017-07-11T07:30:10.000Z</published>
    <updated>2017-07-25T09:07:16.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Pixel Deconvolutional Networks Hongyang Gao etc. 2017.1.7 主要介绍了对于传统反卷积操作的新解读。读此论文，做如下笔记。  </p>
</blockquote>
<a id="more"></a>
<p><strong>1.引子</strong><br>反卷积层被广泛地应用在各种各样的深度模型中用于上采样，其中包括了用于语义分割的编码-解码网络、用于无监督学习的深度生成模型。反卷积层容易造成棋盘问题，使得输出的特征图的临近像素没有直接的关系。为了解决这个问题，提出了一种像素反卷积层，在输出特征图的临近像素之间建立一个直接的关系。是对反卷积操作的新的解读，因此可以取代任何的使用反卷积层的网络模型中的反卷积层。效率有所下降但是可以通过实现来解决。实验结果比较良好。  </p>
<p><strong>2.像素反卷积层</strong><br>新的层中的中间特征图是按照顺序生成，后面的特征图的生成依赖前面的。如此。<br>反卷积网络中的棋盘问题。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-24/77481511.jpg" alt=""><br>卷积层对输入特征图进行不同的卷积核卷积生成了中间特征图，然后上采样生成了输出特征图，其相邻的像素是没有直接联系的，因为是不同的卷积核操作生成的。<br>输入特征图Fin，输出特征图Fout，中间特征图的计算：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/57088763.jpg" alt=""><br>像素反卷积层，PixelDCL，改用了一种中间特征图的关联生成形式，生成了序列化的特征图，彼此依赖，如图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-24/26503601.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/92585659.jpg" alt=""><br>移除中间特征图和输入特征图之间的关联，因为，中间特征已经包含了输入特征图的信息，去掉不但可以提高计算效率，还能减小模型的参数。计算时只需第一个中间特征图依赖输入特征图，其他的中间特征图依赖前面计算过的特征图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/42661592.jpg" alt=""><br><strong>分析（ 4*4 的输入特征图，上采样为 8*8 的特征图）：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/85425689.jpg" alt=""><br>第一步：2*2的卷积核对输入特征进行卷积操作生成第一个中间特征图，紫色的；<br>第二步：对第一个中间特征进行卷积操作生成第二个中间特征；<br>第三步：扩展和组合前两个特征图，生成8*8的特征图；<br>第四步：对此特征图进行marked卷积，卷积核大小改为3，保持8的大小；<br>第五步：组合两个大小为8的特征图，生成最终的大小为8的输出特征图。  </p>
<p><a href="https://github.com/divelab/PixelDCN">源码地址</a>  </p>
<p><strong>3.结果</strong><br>在图像语义分割上的结果：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/55128940.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Pixel Deconvolutional Networks Hongyang Gao etc. 2017.1.7 主要介绍了对于传统反卷积操作的新解读。读此论文，做如下笔记。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>使用深度学习技术的图像语义分割最新综述</title>
    <link href="http://abumaster.com/2017/07/10/%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9B%BE%E5%83%8F%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E6%9C%80%E6%96%B0%E7%BB%BC%E8%BF%B0/"/>
    <id>http://abumaster.com/2017/07/10/使用深度学习技术的图像语义分割最新综述/</id>
    <published>2017-07-10T08:32:14.000Z</published>
    <updated>2017-07-29T06:58:05.506Z</updated>
    
    <content type="html"><![CDATA[<p>A Review on Deep Learning Techniques Applied to Semantic Segmentation [A. Garcia-Garcia, S. Orts-Escolano, S.O. Oprea, V. Villena-Martinez, and J. Garcia-Rodriguez] 2017年4月22  </p>
<a id="more"></a>
<div class="note sucess"><p>文章的主要贡献：  </p>
<ul>
<li>对现有用于图像语义分割的数据集的研究；  </li>
<li>深度有组织地对使用深度学习的图像语义分割重要算法它们的起源和贡献进行回顾；  </li>
<li>对它们的性能进行粗略的评估；  </li>
<li>对上述结果进行讨论，并对未来的研究方向进行探讨。  </li>
</ul>
</div>
<h4 id="术语和背景概念"><a href="#术语和背景概念" class="headerlink" title="术语和背景概念"></a>术语和背景概念</h4><p>图像语义分割不是一个孤立的领域，而是一个从粗略到精细的自然的推理过程：预测输入图像中物体的类别，如果多类物体则预测多个类别；定位不同类别物体的位置；为图像中的每一个像素分类（图像语义分割）；对同一类物体的不同物体进行区分（实例分割）。  </p>
<p><strong>数据预处理和增强</strong> 对于小的数据集，可以相应作出改变来增大数据集，往往会带来更好的效果。比如1500张图像的数据集可以缩放成不同的尺度，进行不同的旋转，进行不同的伽马变换，生成大数据集。  </p>
<h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-10/64022244.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-10/39234174.jpg" alt="">  </p>
<p>当前，大多数优秀的深度学习技术用于图像语义分割都来自一个共同的先导者：全卷积网络（Long），这种方法的优势就是利用当前存在的CNNs作为有力的视觉模型，可以学习分层特征。通过改变一些著名的分类网络：改变最后的全连接层为全卷积层，输出特征图来取代分类得分。这些特征图（空域图）通过分数阶卷积（也被称为反卷积）来产生稠密像素级标记的输出图。反卷积网络的工作是一个里程碑式的工作，因为它展示了如何用CNNs训练端对端来解决视觉问题，是深度学习用于图像语义分割的基石。<br><strong>缺陷</strong>：缺少不同特征的感知，阻碍了在具体问题和场景中的应用。固有的空间不变性，使它不能将全局的上下文信息考虑进去，默认不能感知实例，在高分辨率上不能达到实时的处理速度，不能适应无结构的数据，例如3-D点云和模型。<br>对于它的种种缺陷，不同的方法提供不同的改善方向和效果，主要分为以下几个方向。  </p>
<h5 id="解码变种"><a href="#解码变种" class="headerlink" title="解码变种"></a>解码变种</h5><p>这是一种具有两个组件的网络，分别包含了编码器（卷积网络）和解码器（反卷积网络）。与普通的全卷积网络不同之处在于对低分辨率的特征图的处理，通过一个解码网络的东西。<br>SegNet，解码阶段是由一系列的上采样和卷积层组成的，上采样对应了编码过程的最大池化。上采样过的特征图通过一组可以训练的卷积核进行卷积生成了稠密特征图。经过解码后的图像与原始输入图像具有了相同的分辨率，然后经过一层softmax层分类器产生最终的分割图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-26/13339329.jpg" alt="">  </p>
<h5 id="整合上下文信息"><a href="#整合上下文信息" class="headerlink" title="整合上下文信息"></a>整合上下文信息</h5><p><em>图像语义分割的一个问题就是需要整合不同空间尺度的信息</em>。这意味着局部信息和全局信息的平衡，一方面，细粒度或者局部信息对于获得良好的像素级预测精度是非常重要的，另一方面，整合全局上下文信息，可以解决分割图局部模糊性。传统的CNNs网络因为池化层的存在是不能感知全局信息的，有许多方法可以使CNNs感知全局信息，比如，使用条件随机场作为后续的处理，膨胀卷积，多尺度聚合，甚至将上下文模型推广到另一种深度网络中如RNNs。<br><strong>条件随机场</strong><br>解决上述的问题，一种可能的方法优化输出图，提高捕捉细节的能力，是用条件随机场作为后期处理。条件随机场（CRF）可以组合低层次的像素级别的信息，这些是CNN无法做到的，其中DeepLab应用了全连接的条件随机场作为分割图的后续处理，像素作为图的节点，建立全连接充分考虑了短程和远程的连接。另一个CRFasRNN，将条件随机场作为网络的一部分进行端对端的训练。  </p>
<blockquote>
<p>[1] Semantic image segmentation with deep convolutional nets and fully connected crfs<br>[2] Conditional random fields as recurrent neural networks</p>
</blockquote>
<p><strong>膨胀卷积</strong><br>也叫阿托斯卷积，通过增大卷积核的步伐来进行卷积操作，获得更宽的接受域。<br><strong>多尺度聚合</strong><br>首先[1]提出了将全卷积网络分为两个路径，图像分为原图和二倍图，分别放入浅层网络和全卷积网络，将全卷积网络的输出上采样结合浅层输出经过一系列的卷积的到最终的输出图。对尺度感知非常敏感？<br>[2]用了不同的思路，四个相同的网络，感知由粗糙到精细的尺度信息，如图，序列进行处理得到最终的输出。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-26/27217990.jpg" alt=""><br>[4]提出了n个全卷积网络的结构，分别对应处理不同的尺度，分为两个阶段学习：第一个分别独立训练，第二融合各网络的输出，得到最终的输出图。  </p>
<blockquote>
<p>[1] Multi-scale convolutional architecture for semantic segmentation<br>[2] A multi-scale cnn for affordance segmentation in rgb images<br>[3] Predicting depth, surface normals and semantic labels with a common multi-scale convolutional architecture<br>[4] Multiscale fully convolutional network with application to industrial inspection  </p>
</blockquote>
<p><strong>特征融合</strong><br>提取不同层的特征，包含了不同的局部上下文信息，将之融合。<br><strong>递归神经网络</strong>  </p>
<h5 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h5><p>实例分割是语义分割之后的一步，同时也是与其他低级像素分割技术相比最具有挑战性的问题。主要是将同类物品的不同实例区别开。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A Review on Deep Learning Techniques Applied to Semantic Segmentation [A. Garcia-Garcia, S. Orts-Escolano, S.O. Oprea, V. Villena-Martinez, and J. Garcia-Rodriguez] 2017年4月22  &lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>多线程库c++11</title>
    <link href="http://abumaster.com/2017/07/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%93c-11/"/>
    <id>http://abumaster.com/2017/07/09/多线程库c-11/</id>
    <published>2017-07-09T10:32:25.000Z</published>
    <updated>2017-07-10T13:48:30.784Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11 标准中的多线程库，包含了封装的thread类以及用于同步的mutex、atomic和条件变量。<br><a id="more"></a></p>
<h4 id="thread类"><a href="#thread类" class="headerlink" title="thread类"></a>thread类</h4><p>使用包含头文件<thread>，std::thread。<br><strong>构造函数</strong><br>常用的构造函数：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn, <span class="keyword">class</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span> <span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了线程执行函数，第二个可选的线程函数所需的参数。<br>为了控制线程同步，可以设置原子变量atomic类型的全局变量；或者传入一个原子变量参数的引用；或者使用一个成员变量。<a href="http://www.cplusplus.com/reference/thread/thread/thread/">例子</a>，参见cplusplus网站。<br>赋值运算符，可以直接移动分配，不拷贝。<br><strong>等待和独立运行</strong><br>创建线程后可以调用<code>join</code>来阻塞等待线程的结束，同样也提供了一个函数<code>joinable</code>来测试线程是否可以被join，如果想让线程独立于主线程后台运行可以调用<code>detach</code>，使线程分离出去在后台运行，这是测试能否被join则返回的是false，同样主线程也不能调用join来等待线程的结束。<br><strong>this_thread 类</strong><br>表示当前进程，提供了一组函数。  </p>
<ul>
<li><code>get_id</code> 返回一个<code>thread::id</code>类型，标识了当前线程的id。  </li>
<li><code>yield</code> 让步，为其他线程提供调用的机会。  </li>
<li><code>sleep_until</code> 阻塞直到设置的时间到了，绝对的时间。  </li>
<li><code>sleep_for</code> 阻塞到指定的时间，相对时间。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 11 标准中的多线程库，包含了封装的thread类以及用于同步的mutex、atomic和条件变量。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c语言中的struct-option结构</title>
    <link href="http://abumaster.com/2017/07/03/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84struct-option%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/07/03/c语言中的struct-option结构/</id>
    <published>2017-07-03T12:52:19.000Z</published>
    <updated>2017-07-03T13:27:20.575Z</updated>
    
    <content type="html"><![CDATA[<p>C语言知识拾遗，struct option 结构体。</p>
<a id="more"></a>
<p><code>struct option</code> 指明了一个长参数，在一些控制台程序中经常用到，需要指明不同的参数来运行程序。如开源软件<strong>webbench</strong>运行<code>./webbench -h</code>后会出现一些可选项，指定不同的参数，程序会做出不同的相应。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-3/68613055.jpg" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> option &#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//name表示的是长参数名</span></div><div class="line">	<span class="keyword">int</span> has_arg；</div><div class="line">	<span class="keyword">int</span> *flag;</div><div class="line">	<span class="keyword">int</span> val; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数说明：<br><em>name</em> 表示长参数的名称；<br><em>has_arg</em> 表示参数名称后面是否需要跟着参数，no_argument(0)不需要，required_argument(1)一定要跟个参数，optional_argument(2)可以有也可以没有；<br><em>flag</em> 决定了<code>getopt_long</code>的返回值，如果为NULL，返回val字段的数值；如果不为NULL，则会使其指向的内容变为val中的值，并且返回0；若未发现长选项，那么指向不变；<br><em>val</em> 指定的默认值。  </p>
<p><strong>长命令参数的解析</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</div></pre></td></tr></table></figure></p>
<p>参数说明：<br><code>argc</code> 和 <code>argv</code> 是命令行参数；<br><code>optstring</code> 选项参数组成的字符串，如果一个字母后面跟着一个冒号如 <code>t:</code>，那么表示这个选项后需要参数；<br><code>longopts</code> 是需要的自定义的option结构体；<br><code>longindex</code> 指定一个索引指针。  </p>
<p><strong>例子</strong>：  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言知识拾遗，struct option 结构体。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-迭代器和traits编程技法</title>
    <link href="http://abumaster.com/2017/06/27/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8Ctraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/"/>
    <id>http://abumaster.com/2017/06/27/STL源码剖析-迭代器和traits编程技法/</id>
    <published>2017-06-27T06:46:37.000Z</published>
    <updated>2017-06-30T02:38:56.651Z</updated>
    
    <content type="html"><![CDATA[<p>STL源码剖析，第三章 迭代器和traits编程技法的读书笔记。</p>
<a id="more"></a>
<div class="note info"><p><em>迭代器</em> 是一种类似指针的对象，各种行为中最重要的是内容提领(dereference)和成员访问(member access)。最重要的是对 <code>operator*</code> 和 <code>operator-&gt;</code> 进行重载。  </p>
</div>  
<h4 id="迭代器的相应型别"><a href="#迭代器的相应型别" class="headerlink" title="迭代器的相应型别"></a>迭代器的相应型别</h4><p>相应型别（associated type）是迭代器所指之物的型别。<br>应用场景：算法中可能用到一个以迭代器所指型别类型的变量，这时如何获取呢？C++ 不支持<code>typeof</code>。<br>解决方法：利用函数模板的参数推导机制，可以推导出型别。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span></div><div class="line"></span>&#123;</div><div class="line">	T tmp; <span class="comment">// T 所指之物的类别 int</span></div><div class="line">	<span class="comment">// ... 这里做原本func做的工作</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span></div><div class="line"><span class="keyword">void</span> <span class="title">func</span><span class="params">(I iter)</span></div><div class="line"></span>&#123;</div><div class="line">	func_impl(iter, *iter); <span class="comment">// func 的工作全部移往 func_impl</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	func(&amp;i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Traits-编程技法"><a href="#Traits-编程技法" class="headerlink" title="Traits 编程技法"></a>Traits 编程技法</h4><p>上述的参数推导机制，无法推导出函数返回值的型别。有一种方法：内嵌型别来解决，内嵌一个类型声明 value type 。如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> MyIter &#123;</div><div class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌式声明（nested type）</span></div><div class="line">	T* ptr;</div><div class="line">	MyIter(T* p=<span class="number">0</span>) : ptr(p) &#123; &#125;</div><div class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="keyword">typename</span> I::value_type <span class="comment">// 这一行是 func 的回返值型別</span></div><div class="line">func(I ite)</div><div class="line">&#123; <span class="keyword">return</span> *ite; &#125;</div><div class="line"><span class="comment">// 调用</span></div><div class="line">MyIter&lt;<span class="keyword">int</span>&gt; ite(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</div><div class="line"><span class="built_in">cout</span> &lt;&lt; func(ite); <span class="comment">// 输出：8</span></div></pre></td></tr></table></figure></p>
<p><strong>并不是所有的迭代器都可以内嵌型别，如原生指针不是 class type，就无法定义型别。</strong>因此，对一般化概念进行特定情况处理，模板偏特化（template partial specialization）可以做到。<br>所谓<em>偏特化</em>是针对任意template参数更进一步限制条件设计出的一个特化版本。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;typeneme T&gt;</div><div class="line"><span class="keyword">class</span> C&lt;T*&gt; &#123;...&#125;<span class="comment">//T为原生指针的情况，是T为任何类型的进一步条件限制</span></div></pre></td></tr></table></figure></p>
<p><strong>特征萃取机</strong><br>负责将迭代器或者原生指针中的特征提取出来。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-30/21514523.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>迭代器各个型别的意义：<br><code>value type</code> 迭代器所指对象的型别。<br><code>difference_type</code> 两个迭代器之间的距离，也可以用来表示一个容器的最大容量。<br><code>reference</code> 引用类型。<br><code>pointer</code> 指针类型。<br><code>iterator_category</code> 迭代器的分类。<br>迭代器通常分为五类：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input Iterator</td>
<td>不允许外部改变，只读</td>
</tr>
<tr>
<td>Output Iterator</td>
<td>只写</td>
</tr>
<tr>
<td>Forward Iterator</td>
<td>单向移动，可读可写</td>
</tr>
<tr>
<td>Bidirectional Iterator</td>
<td>双向移动，区间内可读可写</td>
</tr>
<tr>
<td>Random Access Iterator</td>
<td>随机访问，涵盖所有指针的算术能力</td>
</tr>
</tbody>
</table>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-30/63413455.jpg" alt=""><br><strong>Traits</strong>编程技法。部分源码剖析，<a href="http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html">参考</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于标记迭代器类型</span></div><div class="line"><span class="keyword">struct</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> output_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> forward_iterator_tag : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> bidirectional_iterator_tag : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> random_access_iterator_tag : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> input_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> input_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                  value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance           difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                 pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                 reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> output_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> forward_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                    value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance             difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                   pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                   reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> bidirectional_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> random_access_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_NAMESPACES</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Category, <span class="keyword">class</span> T, <span class="keyword">class</span> Distance = <span class="keyword">ptrdiff_t</span>,</div><div class="line">          <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt;</div><div class="line"><span class="keyword">struct</span> iterator &#123;</div><div class="line">  <span class="keyword">typedef</span> Category  iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T         value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance  difference_type;</div><div class="line">  <span class="keyword">typedef</span> Pointer   pointer;</div><div class="line">  <span class="keyword">typedef</span> Reference reference;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_NAMESPACES */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></div><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_traits定义</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line"><span class="comment">// 用于traits出迭代其所指对象的型别</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 迭代器类型, STL提供五种迭代器</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代器所指对象的型别</span></div><div class="line">  <span class="comment">// 如果想与STL算法兼容, 那么在类内需要提供value_type定义</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</div><div class="line"></div><div class="line">  <span class="comment">// 这个是用于处理两个迭代器间距离的类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</div><div class="line"></div><div class="line">  <span class="comment">// 直接指向对象的原生指针类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</div><div class="line"></div><div class="line">  <span class="comment">// 这个是对象的引用类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 针对指针提供特化版本</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;T*&gt;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 针对指向常对象的指针提供特化</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;<span class="keyword">const</span> T*&gt;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_traits支持函数</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_category(const Iterator&amp;)           返回迭代器类别</span></div><div class="line"><span class="comment">// distance_type(const Iterator&amp;)               返回表示迭代器距离的类型</span></div><div class="line"><span class="comment">// value_type(const Iterator&amp;)                  返回迭代器所指对象的类型</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</div><div class="line"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</div><div class="line">  <span class="keyword">return</span> category();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</div><div class="line"><span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</div><div class="line"><span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子：使用，如一个动物接收机构，不同的动物对应不同的处理，但是对于外界来说只有一个共同的接口，内部不同的动物有不同的方法，用虚函数可以实现，但是用traits编程技巧，也能很好的实现这个需求。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义不同的动物标签</span></div><div class="line"><span class="keyword">struct</span> cat_tag&#123;&#125;;</div><div class="line"><span class="keyword">struct</span> dog_tag&#123;&#125;;</div><div class="line"><span class="comment">//不同的动物类</span></div><div class="line"><span class="keyword">struct</span> dog&#123;</div><div class="line">	<span class="keyword">typedef</span> dog_tag animal_type;<span class="comment">//内嵌动物类型</span></div><div class="line">	<span class="comment">//typedef T value_type;</span></div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> cat &#123;</div><div class="line">	<span class="keyword">typedef</span> cat_tag animal_type;</div><div class="line">	<span class="comment">//typedef T value_type;</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//获取动物类型</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> AnimalTraits &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::animal_type animal_type;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">//不同的动物有不同的处理</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;  <span class="keyword">void</span> _Accept(T dog, dog_tag)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is dog accept..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> _Accept(T cat, cat_tag)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is cat accept..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//提供外部通用的接口</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Accept</span><span class="params">(T animal)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> AnimalTraits&lt;T&gt;::animal_type type;</div><div class="line">	_Accept(animal, type());<span class="comment">//依据类别的临时变量决定调用哪个</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL源码剖析，第三章 迭代器和traits编程技法的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-空间配置器</title>
    <link href="http://abumaster.com/2017/06/24/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://abumaster.com/2017/06/24/STL源码剖析-空间配置器/</id>
    <published>2017-06-24T08:15:31.000Z</published>
    <updated>2017-06-24T11:18:21.109Z</updated>
    
    <content type="html"><![CDATA[<p>《STL 源码剖析》读书笔记，第2章 空间配置器（allocator）。</p>
<a id="more"></a>
<h4 id="空间的配置和释放"><a href="#空间的配置和释放" class="headerlink" title="空间的配置和释放"></a>空间的配置和释放</h4><blockquote>
<p>内存配置 -&gt; 对象构造 -&gt; 对象析构 -&gt; 内存释放</p>
</blockquote>
<p>考虑到小内存块可能造成内存碎片的问题，SGI设计了双层配置器，对于大的内存块直接使用以及配置器，直接调用 <code>malloc()</code> 和 <code>free()</code> 函数，其中定义了内存不足的处理函数机制；而对于较小的内存申请（128 bytes 为界限），使用二级配置器，使用了内存池技术（内存的申请和释放交由内存池管理），可以保证效率和减少内存碎片。两个配置器的使用取决于 <code>__USE__MALLOC</code> 宏的定义。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/43353252.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></div><div class="line">...</div><div class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</div><div class="line"><span class="keyword">typedef</span> malloc_alloc alloc; <span class="comment">// 令 alloc 为第一级配置器</span></div><div class="line"><span class="meta"># <span class="meta-keyword">else</span></span></div><div class="line">...</div><div class="line"><span class="comment">// 令 alloc 为第二级配置器</span></div><div class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span></span></div></pre></td></tr></table></figure></p>
<p>包装一个接口提供给用户使用，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</div><div class="line"><span class="keyword">class</span> simple_alloc &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></div><div class="line">		</span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*)  Alloc::allocate (n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">		</span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></div><div class="line">		</span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></div><div class="line">		</span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="第二级配置器剖析"><a href="#第二级配置器剖析" class="headerlink" title="第二级配置器剖析"></a>第二级配置器剖析</h4><p>规定申请的空间小于 128 bytes 时，使用二级配置器完成。二级配置器由自由链表（free-list）组成。内存需求以8的倍数对齐。16个 <em>free-lists</em> 各自管理大小分别为 8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128 bytes 的小额区块。需要哪个大小直接从链表中调拨。<br><strong>链表结构</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> obj &#123;</div><div class="line">	<span class="keyword">union</span> obj * free_list_link;</div><div class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析：<br>union共用存储空间。<code>free_list_link</code> 指向下一个 obj ；第二个字段，可以看成一个指针，指向了实际的区块。<code>client_data</code> 为数组名称，是数组的首地址，因此是一个指针，指向了obj的地址，即<code>&amp;obj == obj-&gt;client_data</code>。实现了链表结点只使用一个指针的大小空间, 却能同时做索引和指向内存区域。<br><strong>空间配置函数 allocate()</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n must be &gt; 0</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></div><div class="line"></span>&#123;</div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	obj * result;</div><div class="line">	<span class="comment">// 大于128的调用一级配置器</span></div><div class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)</div><div class="line">		<span class="keyword">return</span>(malloc_alloc::allocate(n));	</div><div class="line">	<span class="comment">// 寻找自由链表中的合适的大小</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	result = *my_free_list;</div><div class="line">	<span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 沒找到可用的 free list ，重新填充</span></div><div class="line">		<span class="keyword">void</span> *r = refill(ROUND_UP(n)); <span class="comment">//</span></div><div class="line">		<span class="keyword">return</span> r;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 调整空闲链表</span></div><div class="line">	*my_free_list = result -&gt; free_list_link;</div><div class="line">	<span class="keyword">return</span> (result);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>示意图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/14223605.jpg" alt=""><br><strong>空间释放函数 deallocate()</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 不可以是 0</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></div><div class="line"></span>&#123;</div><div class="line">	obj *q = (obj *)p;</div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	<span class="comment">// 大於 128 请求一级配置器</span></div><div class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</div><div class="line">		malloc_alloc::deallocate(p, n);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 根据大小寻找对应的 free list</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	<span class="comment">// 重新调整 free list ，回收区块进链表</span></div><div class="line">	q -&gt; free_list_link = *my_free_list;</div><div class="line">	*my_free_list = q;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示意图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/78747924.jpg" alt=""><br>配置和释放的过程：  </p>
<ul>
<li>根据请求的大小，找到16个free lists中对应的list或者请求一级配置器；  </li>
<li>然后将第一块空闲区返回给用户，没有空闲的可以到内存池中再重新注入一些空闲的数据块。<br><strong>重新填充 free lists</strong><br>分配时，发现free list中没有空闲的区块，则从内存池中填充一部分新区快，默认为20个新区快。内存池中没有那么多也可能会少于20个。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回一个大小为n的对象，恰当时候可以为free list增加新的节点</span></div><div class="line"><span class="comment">//n已经是8的倍数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> nobjs = <span class="number">20</span>;</div><div class="line">	<span class="comment">//从内存池中申请 nobjs 个大小为 n 的对象(n*objs)，chunk指向这块内存</span></div><div class="line">	<span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);<span class="comment">//nobjs为引用参数</span></div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	obj * result;</div><div class="line">	obj * current_obj, * next_obj;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="comment">//只得到了一块，那么直接返回，不需要加入free list中了</span></div><div class="line">	<span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</div><div class="line">	<span class="comment">//找到合适的free list</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	result = (obj*)chunk;<span class="comment">//返回的空间</span></div><div class="line">	<span class="comment">//指向下一个空闲块</span></div><div class="line">	*my_free_list = next_obj = (obj *)(chunk + n);</div><div class="line">	<span class="comment">//开始加入free list中</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123; <span class="comment">// 0的已经返回给用户</span></div><div class="line">		current_obj = next_obj;</div><div class="line">		next_obj = (obj *)((<span class="keyword">char</span> *)next_obj + n);</div><div class="line">		<span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;<span class="comment">//最后一个</span></div><div class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">//分成大小n的块，并连成链表</span></div><div class="line">			current_obj -&gt; free_list_link = next_obj;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span>(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>内存池</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </div><div class="line"><span class="keyword">char</span>*  </div><div class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">char</span> * result;  </div><div class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;  </div><div class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;  <span class="comment">// 计算内存池剩余容量  </span></div><div class="line">    <span class="comment">// 如果内存池中剩余内存&gt;=需要分配的内内存, 返回start_free指向的内存块,</span></div><div class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></div><div class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </div><div class="line">        result = start_free;  </div><div class="line">        start_free += total_bytes;  </div><div class="line">        <span class="keyword">return</span>(result);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span></div><div class="line">    <span class="comment">// 返回所能分配的最多的节点, 返回start_free指向的内存块  </span></div><div class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;  </div><div class="line">        nobjs = bytes_left/size;  </div><div class="line">        total_bytes = size * nobjs;  </div><div class="line">        result = start_free;  </div><div class="line">        start_free += total_bytes;  </div><div class="line">        <span class="keyword">return</span>(result);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 内存池剩余内存连一个节点也不够分配  </span></div><div class="line">    <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);  </div><div class="line">        <span class="comment">// 将剩余的内存分配给指定的free_list[FREELIST_INDEX(bytes_left)]  </span></div><div class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </div><div class="line">            obj * __VOLATILE * my_free_list =  </div><div class="line">                        free_list + FREELIST_INDEX(bytes_left);  </div><div class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </div><div class="line">            *my_free_list = (obj *)start_free;  </div><div class="line">        &#125;  </div><div class="line">        start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);  </div><div class="line">        <span class="comment">// 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span></div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;  </div><div class="line">           <span class="keyword">int</span> i;  </div><div class="line">           obj * __VOLATILE * my_free_list, *p;  </div><div class="line">           <span class="comment">//不打算配置较小的内存块</span></div><div class="line">           <span class="comment">//检索在free list中足够大的空闲块 </span></div><div class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </div><div class="line">                my_free_list = free_list + FREELIST_INDEX(i);  </div><div class="line">                p = *my_free_list;  </div><div class="line">                <span class="comment">// 找到了一个, 将其加入内存池中  </span></div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </div><div class="line">                    *my_free_list = p -&gt; free_list_link;  </div><div class="line">                    start_free = (<span class="keyword">char</span> *)p;  </div><div class="line">                    end_free = start_free + i;  </div><div class="line">                    <span class="comment">// 内存池更新完毕, 重新分配需要的内存</span></div><div class="line">                    <span class="comment">//递归调用</span></div><div class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </div><div class="line">                    <span class="comment">// 内存零头被编到了对应free list中  </span></div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助</span></div><div class="line">            <span class="comment">// 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span></div><div class="line">            <span class="comment">// 最好直接log, 然后让程序崩溃  </span></div><div class="line">        end_free = <span class="number">0</span>;   <span class="comment">// In case of exception.  </span></div><div class="line">            start_free = (<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);  </div><div class="line">        &#125;  </div><div class="line">        heap_size += bytes_to_get;  </div><div class="line">        end_free = start_free + bytes_to_get;  </div><div class="line">        <span class="comment">// 内存池更新完毕, 重新分配需要的内存  </span></div><div class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html">参考链接</a>。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《STL 源码剖析》读书笔记，第2章 空间配置器（allocator）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Nginx源码学习-数据结构</title>
    <link href="http://abumaster.com/2017/06/18/Nginx%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/06/18/Nginx源码学习-数据结构/</id>
    <published>2017-06-18T10:29:52.000Z</published>
    <updated>2017-06-20T11:24:52.414Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx源码学习中的数据结构，主要包括数组结构<code>ngx_array_t</code>、链表结构<code>ngx_list_t</code>、队列结构<code>ngx_queue_t</code>、哈希结构<code>ngx_hash_t</code>、字符串结构<code>ngx_string_t</code>。在内存池的基础之上进一步整合组织数据。  </p>
<a id="more"></a>
<h4 id="Nginx数组结构ngx-array-t"><a href="#Nginx数组结构ngx-array-t" class="headerlink" title="Nginx数组结构ngx_array_t"></a>Nginx数组结构ngx_array_t</h4><p>数组结构位于源文件<code>\Src\Core\Ngx_array.h{c}</code>  </p>
<h5 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">void</span>        *elts; <span class="comment">//指向数组空间的起始地址</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>   nelts; <span class="comment">//数组中实际的元素个数</span></div><div class="line">    <span class="keyword">size_t</span>       size; <span class="comment">//数组元素的大小</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>   nalloc; <span class="comment">//实际分配的空间</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>  *pool; <span class="comment">//数组交由此内存池来管理空间</span></div><div class="line">&#125; <span class="keyword">ngx_array_t</span>;<span class="comment">//数组头占用的空间为20字节，头+数据</span></div></pre></td></tr></table></figure>
<p>几种数据结构之间的关系图<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-18/21845022.jpg" alt="">  </p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p><strong>1.一个内联函数</strong><br>功能：在内存池<code>pool</code>上分配一块大小为<code>n*size</code>的空间，并将数组的<code>elts</code>指针指向这个空间的首地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化数组大小为n，参数：数组指针，内存池，数组空间的，每个元素大小</span></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline ngx_int_t</div><div class="line"><span class="title">ngx_array_init</span><span class="params">(<span class="keyword">ngx_array_t</span> *<span class="built_in">array</span>, <span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">/*</div><div class="line">     * set "array-&gt;nelts" before "array-&gt;elts", otherwise MSVC thinks</div><div class="line">     * that "array-&gt;nelts" may be used without having been initialized</div><div class="line">     */</span></div><div class="line"></div><div class="line">    <span class="built_in">array</span>-&gt;nelts = <span class="number">0</span>;<span class="comment">//数组中的元素个数为0</span></div><div class="line">    <span class="built_in">array</span>-&gt;size = size;<span class="comment">//每个元素的大小</span></div><div class="line">    <span class="built_in">array</span>-&gt;nalloc = n;<span class="comment">//分配n个空间，空间大小(n*size)</span></div><div class="line">    <span class="built_in">array</span>-&gt;pool = pool;</div><div class="line">	<span class="comment">//用内存池函数分配一个大小(n*size)的空间并将首地址返回给数组的elts</span></div><div class="line">    <span class="built_in">array</span>-&gt;elts = ngx_palloc(pool, n * size);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//成功初始化数组</span></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2.创建数组</strong><br>功能：提供数组元素的个数并且知道每个元素所占用的空间，在内存池p中创建一个有n个元素的数组。返回数组的指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_array_t</span> *</div><div class="line">ngx_array_create(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_array_t</span> *a;</div><div class="line"><span class="comment">//首先为数组的头分配一个空间，这个数组指针指向的是数组头的起始地址</span></div><div class="line">    a = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="keyword">ngx_array_t</span>));</div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//用内联函数初始化这个数组</span></div><div class="line">    <span class="keyword">if</span> (ngx_array_init(a, p, n, size) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.销毁数组</strong><br>功能：销毁数组实际上没有释放数组占用的内存空间，而是移动首尾指针，这样保证了效率。<br>代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></div><div class="line"><span class="title">ngx_array_destroy</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//数组所用的内存池</span></div><div class="line">    p = a-&gt;pool;</div><div class="line"><span class="comment">//数组不是内存池中的最后一个？还能删除？</span></div><div class="line">    <span class="keyword">if</span> ((u_char *) a-&gt;elts + a-&gt;size * a-&gt;nalloc == p-&gt;d.last) &#123;</div><div class="line">        p-&gt;d.last -= a-&gt;size * a-&gt;nalloc;<span class="comment">//将内存池的指针向前移动</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">//删除数组头</span></div><div class="line">    <span class="keyword">if</span> ((u_char *) a + <span class="keyword">sizeof</span>(<span class="keyword">ngx_array_t</span>) == p-&gt;d.last) &#123;</div><div class="line">        p-&gt;d.last = (u_char *) a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.向数组中插入元素</strong><br>功能：向数组指针a中插入元素，返回插入元素的空间地址
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_array_push</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>        *elt, *<span class="keyword">new</span>;</div><div class="line">    <span class="keyword">size_t</span>       size;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//数组中元素已经满了</span></div><div class="line">    <span class="keyword">if</span> (a-&gt;nelts == a-&gt;nalloc) &#123;</div><div class="line">        size = a-&gt;size * a-&gt;nalloc;<span class="comment">//此时数组的占用空间的大小</span></div><div class="line">        p = a-&gt;pool;</div><div class="line">    <span class="comment">//数组后面有多余的空间可以扩展</span></div><div class="line">        <span class="keyword">if</span> ((u_char *) a-&gt;elts + size == p-&gt;d.last</div><div class="line">            &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/*</div><div class="line">             * the array allocation is the last in the pool</div><div class="line">             * and there is space for new allocation</div><div class="line">             */</span></div><div class="line">	<span class="comment">//向后扩展一个元素的空间</span></div><div class="line">            p-&gt;d.last += a-&gt;size;</div><div class="line">            a-&gt;nalloc++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* allocate a new array */</span></div><div class="line">	<span class="comment">//没有多余的空间进行扩展，则重新申请一个数组，大小为当前的2倍</span></div><div class="line">            <span class="keyword">new</span> = ngx_palloc(p, <span class="number">2</span> * size);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">	<span class="comment">//将原数组元素拷贝到新的数组中，并设置新数组的一些参数（老数组没有销毁）</span></div><div class="line">            ngx_memcpy(<span class="keyword">new</span>, a-&gt;elts, size);</div><div class="line">            a-&gt;elts = <span class="keyword">new</span>;</div><div class="line">            a-&gt;nalloc *= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//将指针指向下一个空闲区域</span></div><div class="line">    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;</div><div class="line">    a-&gt;nelts++;</div><div class="line">	<span class="comment">//返回这个空闲空间的指针</span></div><div class="line">    <span class="keyword">return</span> elt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加n个元素<code>void * ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)</code>。  </p>
<h4 id="Nginx链表结构ngx-list-t"><a href="#Nginx链表结构ngx-list-t" class="headerlink" title="Nginx链表结构ngx_list_t"></a>Nginx链表结构ngx_list_t</h4><h5 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_list_part_s  <span class="keyword">ngx_list_part_t</span>;</div><div class="line"><span class="comment">//链表节点结构</span></div><div class="line"><span class="keyword">struct</span> ngx_list_part_s &#123;</div><div class="line">    <span class="keyword">void</span>             *elts;<span class="comment">//实际指向的内存区域大小为size*nalloc</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        nelts;<span class="comment">//元素的个数</span></div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *next;<span class="comment">//下一个节点的地址</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//链表头结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *last;<span class="comment">//指向链表最后一个节点</span></div><div class="line">    <span class="keyword">ngx_list_part_t</span>   part;<span class="comment">//链表头中也有一个节点</span></div><div class="line">    <span class="keyword">size_t</span>            size;<span class="comment">//每个元素的大小</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        nalloc;<span class="comment">//链表包含的空间，实际分配的空间个数</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *pool;<span class="comment">//在此内存池中分配</span></div><div class="line">&#125; <span class="keyword">ngx_list_t</span>;</div></pre></td></tr></table></figure>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-18/25501941.jpg" alt="">  </p>
<h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><p><strong>1.内联函数-链表的初始化</strong><br>功能：初始化链表实体，头结点
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline ngx_int_t</div><div class="line"><span class="title">ngx_list_init</span><span class="params">(<span class="keyword">ngx_list_t</span> *<span class="built_in">list</span>, <span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="built_in">list</span>-&gt;part.elts = ngx_palloc(pool, n * size);<span class="comment">//实际存储空间</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;part.elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">list</span>-&gt;part.nelts = <span class="number">0</span>;<span class="comment">//当前元素个数</span></div><div class="line">    <span class="built_in">list</span>-&gt;part.next = <span class="literal">NULL</span>;<span class="comment">//下一个没有</span></div><div class="line">    <span class="built_in">list</span>-&gt;last = &amp;<span class="built_in">list</span>-&gt;part;<span class="comment">//最后一个指向了自己</span></div><div class="line">    <span class="built_in">list</span>-&gt;size = size;<span class="comment">//大小</span></div><div class="line">    <span class="built_in">list</span>-&gt;nalloc = n;<span class="comment">//元素的个数</span></div><div class="line">    <span class="built_in">list</span>-&gt;pool = pool;<span class="comment">//内存池</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</div><div class="line"> *</div><div class="line"> *  the iteration through the list:</div><div class="line"> *</div><div class="line"> *  part = &amp;list.part;//先获得链表头中的节点</div><div class="line"> *  data = part-&gt;elts;//获得数据的存储区域</div><div class="line"> *</div><div class="line"> *  for (i = 0 ;; i++) &#123;</div><div class="line"> *判断此节点中元素的个数，依次取出</div><div class="line"> *      if (i &gt;= part-&gt;nelts) &#123;</div><div class="line"> *          if (part-&gt;next == NULL) &#123;//无下一个节点则跳出</div><div class="line"> *              break;</div><div class="line"> *          &#125;</div><div class="line"> *取出下一个节点</div><div class="line"> *          part = part-&gt;next;</div><div class="line"> *          data = part-&gt;elts;</div><div class="line"> *          i = 0;</div><div class="line"> *      &#125;</div><div class="line"> *进行此节点中的数据操作</div><div class="line"> *      ...  data[i] ...</div><div class="line"> *</div><div class="line"> *  &#125;</div><div class="line"> */</span></div></pre></td></tr></table></figure></p>
<p><strong>2.创建链表</strong><br>功能：创建一个链表，指定内存池，个数以及每个元素的大小
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_list_t</span> *</div><div class="line">ngx_list_create(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_list_t</span>  *<span class="built_in">list</span>;</div><div class="line"><span class="comment">//为链表头分配空间大小sizeof(ngx_list_t) = 28B</span></div><div class="line">    <span class="built_in">list</span> = ngx_palloc(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_list_t</span>));</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//调用内联函数进行链表的初始化，包含一个节点的链表头</span></div><div class="line">    <span class="keyword">if</span> (ngx_list_init(<span class="built_in">list</span>, pool, n, size) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//返回此链表头结点</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.添加结点</strong><br>功能：向链表中添加一个元素，返回添加元素数据区的地址
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_list_push</span><span class="params">(<span class="keyword">ngx_list_t</span> *l)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>             *elt;</div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *last;</div><div class="line"><span class="comment">//得到链表中的最后一个节点，在链表的尾部插入新的节点</span></div><div class="line">    last = l-&gt;last;</div><div class="line"><span class="comment">//最后一个节点的元素个数已经满了</span></div><div class="line">    <span class="keyword">if</span> (last-&gt;nelts == l-&gt;nalloc) &#123;</div><div class="line">	<span class="comment">//需要重新创建一个链表节点</span></div><div class="line">        last = ngx_palloc(l-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_list_part_t</span>));</div><div class="line">        <span class="keyword">if</span> (last == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//为节点分配空间</span></div><div class="line">        last-&gt;elts = ngx_palloc(l-&gt;pool, l-&gt;nalloc * l-&gt;size);</div><div class="line">        <span class="keyword">if</span> (last-&gt;elts == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//设置新节点信息</span></div><div class="line">        last-&gt;nelts = <span class="number">0</span>;</div><div class="line">        last-&gt;next = <span class="literal">NULL</span>;</div><div class="line">	<span class="comment">//连接到链表中</span></div><div class="line">        l-&gt;last-&gt;next = last;</div><div class="line">        l-&gt;last = last;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//获得地址</span></div><div class="line">    elt = (<span class="keyword">char</span> *) last-&gt;elts + l-&gt;size * last-&gt;nelts;</div><div class="line">    last-&gt;nelts++;</div><div class="line"><span class="comment">//返回可用存储空间的地址</span></div><div class="line">    <span class="keyword">return</span> elt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.链表设计思路</strong><br>在链表头中设置一些链表节点的信息：<code>last</code>指针用于指向链表的最后一个节点，方便插入元素和数据；<code>part</code>链表头中的结点；<code>size</code>链表中存放元素的大小；<code>nalloc</code>一个节点所占用的空间，可以放元素的个数；<code>pool</code>指定内存池。<br>在链表节点中只存放了指向数据元素存储区的指针<code>elts</code>；当前节点存放的元素个数<code>nelts</code>；以及下一个节点指针<code>next</code>。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/93613137.jpg" alt="">  </p>
<h4 id="Nginx队列结构-ngx-queue-t"><a href="#Nginx队列结构-ngx-queue-t" class="headerlink" title="Nginx队列结构 ngx_queue_t"></a>Nginx队列结构 ngx_queue_t</h4><blockquote>
<p>Nginx 中的队列数据结构是用双向循环链表实现。节点结构为ngx_queue_t。 </p>
</blockquote>
<h5 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_queue_s  <span class="keyword">ngx_queue_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_queue_s &#123;<span class="comment">//队列的结构</span></div><div class="line">    <span class="keyword">ngx_queue_t</span>  *prev;<span class="comment">//前指针</span></div><div class="line">    <span class="keyword">ngx_queue_t</span>  *next;<span class="comment">//后指针</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h5><p>通过定义的一组宏来实现队列的基本操作。  </p>
<p><strong>1.初始化队列</strong><br>初始化头尾指针指向本身。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_init(q)  \</div><div class="line">    (q)-&gt;prev = q;         \</div><div class="line">    (q)-&gt;next = q</span></div></pre></td></tr></table></figure></p>
<p><strong>2.判断队列是否为空</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_empty(h)  \</div><div class="line">    (h == (h)-&gt;prev)</span></div></pre></td></tr></table></figure></p>
<p><strong>3.插入节点</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在头插入</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_insert_head(h, x)                                           \</div><div class="line">    (x)-&gt;next = (h)-&gt;next;                                                    \</div><div class="line">    (x)-&gt;next-&gt;prev = x;                                                      \</div><div class="line">    (x)-&gt;prev = h;                                                            \</div><div class="line">    (h)-&gt;next = x</span></div><div class="line"><span class="comment">//在尾插入</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_insert_tail(h, x)                                           \</div><div class="line">    (x)-&gt;prev = (h)-&gt;prev;                                                    \</div><div class="line">    (x)-&gt;prev-&gt;next = x;                                                      \</div><div class="line">    (x)-&gt;next = h;                                                            \</div><div class="line">    (h)-&gt;prev = x</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/20171048.jpg" alt=""><br><strong>4.访问</strong><br>队列的头结点是固定的，依次链接成了双向链表，进行访问数据。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_head(h)                                                     \</div><div class="line">    (h)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_last(h)                                                     \</div><div class="line">    (h)-&gt;prev</span></div><div class="line"><span class="comment">//哨兵，用于排序</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_sentinel(h)                                                 \</div><div class="line">    (h)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_next(q)                                                     \</div><div class="line">    (q)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_prev(q)                                                     \</div><div class="line">    (q)-&gt;prev</span></div></pre></td></tr></table></figure></p>
<p><strong>5.修改队列</strong><br>删除队列中的节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_remove(x)                                                   \</div><div class="line">    (x)-&gt;next-&gt;prev = (x)-&gt;prev;                                              \</div><div class="line">    (x)-&gt;prev-&gt;next = (x)-&gt;next;                                              \</div><div class="line">    (x)-&gt;prev = NULL;                                                         \</div><div class="line">    (x)-&gt;next = NULL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_remove(x)                                                   \</div><div class="line">    (x)-&gt;next-&gt;prev = (x)-&gt;prev;                                              \</div><div class="line">    (x)-&gt;prev-&gt;next = (x)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>分割队列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_split(h, q, n)                                              \</div><div class="line">    (n)-&gt;prev = (h)-&gt;prev;                                                    \</div><div class="line">    (n)-&gt;prev-&gt;next = n;                                                      \</div><div class="line">    (n)-&gt;next = q;                                                            \</div><div class="line">    (h)-&gt;prev = (q)-&gt;prev;                                                    \</div><div class="line">    (h)-&gt;prev-&gt;next = h;                                                      \</div><div class="line">    (q)-&gt;prev = n;</span></div></pre></td></tr></table></figure></p>
<p>h为队列头(即链表头指针)，将该队列从q节点将队列(链表)分割为两个队列(链表)，q之后的节点组成的新队列的头节点为n。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/10619716.jpg" alt=""><br>合并队列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_add(h, n)                                                   \</div><div class="line">    (h)-&gt;prev-&gt;next = (n)-&gt;next;                                              \</div><div class="line">    (n)-&gt;next-&gt;prev = (h)-&gt;prev;                                              \</div><div class="line">    (h)-&gt;prev = (n)-&gt;prev;                                                    \</div><div class="line">    (h)-&gt;prev-&gt;next = h;</span></div></pre></td></tr></table></figure></p>
<p>两个队列的头结点。最后只保留h头结点。  </p>
<h5 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h5><p>获取队列节点的数据，由队列基本结构和以上操作可知，nginx的队列操作只对链表指针进行简单的修改指向操作，并不负责节点数据空间的分配。<br>因此，用户在使用nginx队列时，要自己定义数据结构并分配空间，且在其中包含一个<code>ngx_queue_t</code>的指针或者对象，当需要获取队列节点数据时，使用<code>ngx_queue_data</code>宏，其定义如下:
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_data(q, type, link)                                         \</div><div class="line">    (type *) ((u_char *) q - offsetof(type, link))</span></div><div class="line"><span class="comment">//其中offsetof，是一个宏，用于计算成员在一个数据结构中的偏移量</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(s, m)   (size_t)&amp;(((s *)0)-&gt;m)</span></div><div class="line"><span class="comment">/*</div><div class="line">s是一个结构名，它有一个名为m的成员（s和m 是宏offsetof的形参，它实际是返回结构s的成员m的偏移地址.</div><div class="line">(s *)0 是骗编译器说有一个指向类（或结构）s的指针，其地址值0 </div><div class="line">&amp;((s *)0)-&gt;m   是要取得类s中成员变量m的地址. 因基址为0，这时m的地址当然就是m在s中的偏移</div><div class="line">最后转换size_t 型，即unsigned int。</div><div class="line"> */</span></div></pre></td></tr></table></figure></p>
<p>由该宏定义可以看出，一般定义队列节点结构(该结构类型为type)时，需要将真正的数据放在前面，而<code>ngx_queue_t</code>结构放在后面，故该宏使用减法计算整个节点结构的起始地址(需要进行类型转换)。  </p>
<p><em>获取队列中的中间元素</em>，奇数则返回中间的，偶数则会返回第二部分的第一个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_queue_t</span> *</div><div class="line">ngx_queue_middle(<span class="keyword">ngx_queue_t</span> *<span class="built_in">queue</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_queue_t</span>  *middle, *next;</div><div class="line"><span class="comment">//队列首元素</span></div><div class="line">    middle = ngx_queue_head(<span class="built_in">queue</span>);</div><div class="line"><span class="comment">//只有一个元素返回</span></div><div class="line">    <span class="keyword">if</span> (middle == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> middle;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//用一个指针记录</span></div><div class="line">    next = ngx_queue_head(<span class="built_in">queue</span>);</div><div class="line"><span class="comment">//两个指针向前移动</span></div><div class="line">    <span class="keyword">for</span> ( ;; ) &#123;</div><div class="line">        middle = ngx_queue_next(middle);</div><div class="line">        next = ngx_queue_next(next);</div><div class="line">        <span class="keyword">if</span> (next == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//next指针向前多移动一次</span></div><div class="line">        next = ngx_queue_next(next);</div><div class="line"><span class="comment">//到了尾返回middle</span></div><div class="line">        <span class="keyword">if</span> (next == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找中间位置，两个指针，middle移动一次，next移动两次，当next到达尾时，那么middle指向的是中间位置。  </p>
<p><em>排序</em>，稳定插入排序。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">ngx_queue_sort(ngx_queue_t *queue,</div><div class="line">    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *))</div><div class="line">&#123;</div><div class="line">    ngx_queue_t  *q, *prev, *next;</div><div class="line">//获得第一个元素</div><div class="line">    q = ngx_queue_head(queue);</div><div class="line">    if (q == ngx_queue_last(queue)) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">//获得下一个节点</div><div class="line">    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) &#123;</div><div class="line">//</div><div class="line">        prev = ngx_queue_prev(q);</div><div class="line">        next = ngx_queue_next(q);</div><div class="line">//</div><div class="line">        ngx_queue_remove(q);</div><div class="line">//</div><div class="line">        do &#123;</div><div class="line">            if (cmp(prev, q) &lt;= 0) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">//</div><div class="line">            prev = ngx_queue_prev(prev);</div><div class="line">//</div><div class="line">        &#125; while (prev != ngx_queue_sentinel(queue));</div><div class="line">//插入</div><div class="line">        ngx_queue_insert_after(prev, q);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Nginx哈希数据结构"><a href="#Nginx哈希数据结构" class="headerlink" title="Nginx哈希数据结构"></a>Nginx哈希数据结构</h4><p>哈希表是用于（key-value）对应的一种关系，为了直接由key来计算出value，需要构建一个哈希函数，并想方设法去避免冲突，尽量保证键值对的唯一性。<br>讲解详细的博文<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html">链接1</a>和<a href="http://www.nowamagic.net/academy/detail/3008088">链接2</a>。  </p>
<h5 id="hash-结构"><a href="#hash-结构" class="headerlink" title="hash 结构"></a>hash 结构</h5><p><strong>1.ngx_hash_t结构</strong><br>Nginx中的哈希结构为<code>ngx_hash_t</code>以及元素结构<code>ngx_hash_elt_t</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash元素结构</span></div><div class="line">    <span class="keyword">void</span>             *value; <span class="comment">//key对应的值(key, value)中的key</span></div><div class="line">    u_short           len; <span class="comment">//name长度</span></div><div class="line">    u_char            name[<span class="number">1</span>];<span class="comment">//要hash的数据，(key, value)中的key</span></div><div class="line">&#125; <span class="keyword">ngx_hash_elt_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash结构</span></div><div class="line">    <span class="keyword">ngx_hash_elt_t</span>  **buckets;<span class="comment">//哈希桶</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        size;<span class="comment">//哈希桶的个数</span></div><div class="line">&#125; <span class="keyword">ngx_hash_t</span>;</div></pre></td></tr></table></figure></p>
<p><strong>2.ngx_hash_init_t结构</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hash计算函数指针</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ngx_uint_t</span> <span class="params">(*ngx_hash_key_pt)</span> <span class="params">(u_char *data, <span class="keyword">size_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash初始化结构</span></div><div class="line">    <span class="keyword">ngx_hash_t</span>       *hash;<span class="comment">//指向待初始化的hash结构</span></div><div class="line">    ngx_hash_key_pt   key;<span class="comment">//hash函数指针</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        max_size;<span class="comment">//bucket的最大个数</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        bucket_size;<span class="comment">//每个bucket占用的空间</span></div><div class="line">    <span class="keyword">char</span>             *name;<span class="comment">//该hash结构的名字</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *pool;<span class="comment">//所需空间的由此内存池接管</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *temp_pool;<span class="comment">//临时文件</span></div><div class="line">&#125; <span class="keyword">ngx_hash_init_t</span>;</div></pre></td></tr></table></figure></p>
<p>通常是作为参数传递给<code>ngx_hash_init</code>函数。<br><strong>3.ngx_hash_key_t</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;  <span class="comment">//hash key结构  </span></div><div class="line">    <span class="keyword">ngx_str_t</span>         key;   <span class="comment">//key，为nginx的字符串结构  </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>  key_hash; <span class="comment">//由该key计算出的hash值(通过hash函数)  </span></div><div class="line">    <span class="keyword">void</span>    *value;  <span class="comment">//该key对应的值，组成一个键-值对&lt;key,value&gt;  </span></div><div class="line">&#125; <span class="keyword">ngx_hash_key_t</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;                    <span class="comment">//字符串结构  </span></div><div class="line">    <span class="keyword">size_t</span>      len;                <span class="comment">//字符串长度  </span></div><div class="line">    u_char     *data;               <span class="comment">//字符串内容  </span></div><div class="line">&#125; <span class="keyword">ngx_str_t</span>;</div></pre></td></tr></table></figure></p>
<p>该结构也主要用来保存要hash的数据，即键-值对<key,value>，在实际使用中，一般将多个键-值对保存在<code>ngx_hash_key_t</code>结构的数组中，作为参数传给<code>ngx_hash_init()</code>或<code>ngx_hash_wildcard_init()</code>函数。<br><strong>哈希结构的内存布局：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-20/23126191.jpg" alt="">  </p>
<center><a href="https://code.google.com/archive/p/nginxsrp/wikis/NginxCodeReview.wiki">图片来源 Google Code</a></center>  

<h5 id="hash-操作"><a href="#hash-操作" class="headerlink" title="hash 操作"></a>hash 操作</h5><p><strong>1.计算ngx_hash_elt_t的大小</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//name为ngx_hash_key_t</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HASH_ELT_SIZE(name)                                               \</div><div class="line">    (sizeof(void *) + ngx_align((name)-&gt;key.len + 2, sizeof(void *)))</span></div></pre></td></tr></table></figure></p>
<p><code>sizeof(void *)=4B</code>,4字节对齐。<br><strong>2.hash函数</strong><br>hash函数提供了几种计算hash的方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_hash(key, c)   ((ngx_uint_t) key * 31 + c)</span></div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_key(u_char *data, <span class="keyword">size_t</span> len);</div><div class="line"><span class="comment">//lc表示lower case，即字符串转换为小写后再计算hash值  </span></div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_key_lc(u_char *data, <span class="keyword">size_t</span> len);</div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_strlow(u_char *dst, u_char *src, <span class="keyword">size_t</span> n);</div><div class="line"><span class="comment">//如：</span></div><div class="line"><span class="keyword">ngx_uint_t</span></div><div class="line">ngx_hash_key(u_char *data, <span class="keyword">size_t</span> len)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_uint_t</span>  i, key;</div><div class="line"></div><div class="line">    key = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        key = ngx_hash(key, data[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> key;</div><div class="line">&#125;</div><div class="line"><span class="comment">//相当于：</span></div><div class="line"><span class="comment">/*</div><div class="line">Key[0] = data[0]  </div><div class="line">Key[1] = data[0]*31 + data[1]  </div><div class="line">Key[2] = (data[0]*31 + data[1])*31 + data[2]  </div><div class="line">...  </div><div class="line">Key[len-1] = ((((data[0]*31 + data[1])*31 + data[2])*31) ... data[len-2])*31 + data[len-1] </div><div class="line"> */</span></div><div class="line"><span class="comment">//key[len-1]即为传入的参数data对应的hash值。</span></div></pre></td></tr></table></figure></p>
<p><strong>3.hash初始化</strong><br>hash的初始化是用<code>ngx_hash_init</code>完成，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hinit hash结构指针；names 为ngx_hash_key_t结构数组；nelts为数组中元素个数</span></div><div class="line"><span class="comment">/*</div><div class="line">该函数初始化的结果就是将names数组保存的键-值对&lt;key,value&gt;，</div><div class="line">通过hash的方式将其存入相应的一个或多个hash桶(即代码中的buckets)中，</div><div class="line">该hash过程用到的hash函数一般为ngx_hash_key_lc等。</div><div class="line">hash桶里面存放的是ngx_hash_elt_t结构的指针(hash元素指针)，该指针指向一个基本连续的数据区。</div><div class="line">该数据区中存放的是经hash之后的键-值对&lt;key',value'&gt;，即ngx_hash_elt_t结构中的字段&lt;name,value&gt;。</div><div class="line">每一个这样的数据区存放的键-值对&lt;key',value'&gt;可以是一个或多个。</div><div class="line"> */</span></div><div class="line"></div><div class="line"><span class="keyword">ngx_int_t</span></div><div class="line">ngx_hash_init(<span class="keyword">ngx_hash_init_t</span> *hinit, <span class="keyword">ngx_hash_key_t</span> *names, <span class="keyword">ngx_uint_t</span> nelts)</div><div class="line">&#123;</div><div class="line">    u_char          *elts;</div><div class="line">    <span class="keyword">size_t</span>           len;</div><div class="line">    u_short         *test;</div><div class="line">    <span class="keyword">ngx_uint_t</span>       i, n, key, size, start, bucket_size;</div><div class="line">    <span class="keyword">ngx_hash_elt_t</span>  *elt, **buckets;</div><div class="line"><span class="comment">//允许的hash桶的最大数量为0，错误</span></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;max_size == <span class="number">0</span>) &#123;</div><div class="line">        ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                      <span class="string">"could not build %s, you should "</span></div><div class="line">                      <span class="string">"increase %s_max_size: %i"</span>,</div><div class="line">                      hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size);</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//对于数组中的每个元素，如果hash元素大小大于桶的容量，出错</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (hinit-&gt;bucket_size &lt; NGX_HASH_ELT_SIZE(&amp;names[n]) + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))</div><div class="line">        &#123;</div><div class="line">            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"could not build %s, you should "</span></div><div class="line">                          <span class="string">"increase %s_bucket_size: %i"</span>,</div><div class="line">                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//分配一块2*max_size大小的空间，没有在内存池上分配，只是临时的</span></div><div class="line">    test = ngx_alloc(hinit-&gt;max_size * <span class="keyword">sizeof</span>(u_short), hinit-&gt;pool-&gt;<span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (test == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//桶的大小减去4字节</span></div><div class="line">    bucket_size = hinit-&gt;bucket_size - <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line"><span class="comment">//确定起始位置</span></div><div class="line">    start = nelts / (bucket_size / (<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    start = start ? start : <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;max_size &gt; <span class="number">10000</span> &amp;&amp; nelts &amp;&amp; hinit-&gt;max_size / nelts &lt; <span class="number">100</span>) &#123;</div><div class="line">        start = hinit-&gt;max_size - <span class="number">1000</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (size = start; size &lt;= hinit-&gt;max_size; size++) &#123;</div><div class="line"></div><div class="line">        ngx_memzero(test, size * <span class="keyword">sizeof</span>(u_short));</div><div class="line"><span class="comment">//标记1：此块代码是检查bucket大小是否够分配hash数据</span></div><div class="line">        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">            <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"><span class="comment">//计算key和names中所有name长度，并保存在test[key]中</span></div><div class="line">            key = names[n].key_hash % size;</div><div class="line">            test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: %ui %ui \"%V\""</span>,</div><div class="line">                          size, key, test[key], &amp;names[n].key);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (test[key] &gt; (u_short) bucket_size) &#123;</div><div class="line">                <span class="keyword">goto</span> next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">goto</span> found;</div><div class="line"></div><div class="line">    next:</div><div class="line"></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size = hinit-&gt;max_size;</div><div class="line"></div><div class="line">    ngx_log_error(NGX_LOG_WARN, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                  <span class="string">"could not build optimal %s, you should increase "</span></div><div class="line">                  <span class="string">"either %s_max_size: %i or %s_bucket_size: %i; "</span></div><div class="line">                  <span class="string">"ignoring %s_bucket_size"</span>,</div><div class="line">                  hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size,</div><div class="line">                  hinit-&gt;name, hinit-&gt;bucket_size, hinit-&gt;name);</div><div class="line"></div><div class="line">found:<span class="comment">//找到</span></div><div class="line"><span class="comment">//test[i]初始化为4</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        test[i] = <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">    &#125;</div><div class="line"> <span class="comment">/** </div><div class="line">  * 标记2：与标记1代码基本相同，但此块代码是再次计算所有hash数据的总长度(标记1的检查已通过)</div><div class="line">  但此处的test[i]已被初始化为4，即相当于后续的计算再加上一个void指针的大小。</div><div class="line">  */</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        key = names[n].key_hash % size;</div><div class="line">        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (test[i] == <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//对test[i]按ngx_cacheline_size对齐(32位平台，ngx_cacheline_size=32)  </span></div><div class="line">        test[i] = (u_short) (ngx_align(test[i], ngx_cacheline_size));</div><div class="line">        len += test[i];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//在内存池中分配hash头及buckets数组(size个ngx_hash_elt_t*结构)</span></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;hash == <span class="literal">NULL</span>) &#123;</div><div class="line">        hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_wildcard_t</span>)</div><div class="line">                                             + size * <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_elt_t</span> *));</div><div class="line">        <span class="keyword">if</span> (hinit-&gt;hash == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_free(test);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buckets = (<span class="keyword">ngx_hash_elt_t</span> **)</div><div class="line">                      ((u_char *) hinit-&gt;hash + <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_wildcard_t</span>));</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buckets = ngx_pcalloc(hinit-&gt;pool, size * <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_elt_t</span> *));</div><div class="line">        <span class="keyword">if</span> (buckets == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_free(test);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    elts = ngx_palloc(hinit-&gt;pool, len + ngx_cacheline_size);</div><div class="line">    <span class="keyword">if</span> (elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        ngx_free(test);</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    elts = ngx_align_ptr(elts, ngx_cacheline_size);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (test[i] == <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buckets[i] = (<span class="keyword">ngx_hash_elt_t</span> *) elts;</div><div class="line">        elts += test[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        test[i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        key = names[n].key_hash % size;</div><div class="line">        elt = (<span class="keyword">ngx_hash_elt_t</span> *) ((u_char *) buckets[key] + test[key]);</div><div class="line"></div><div class="line">        elt-&gt;value = names[n].value;</div><div class="line">        elt-&gt;len = (u_short) names[n].key.len;</div><div class="line"></div><div class="line">        ngx_strlow(elt-&gt;name, names[n].key.data, names[n].key.len);</div><div class="line"></div><div class="line">        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (buckets[i] == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        elt = (<span class="keyword">ngx_hash_elt_t</span> *) ((u_char *) buckets[i] + test[i]);</div><div class="line"></div><div class="line">        elt-&gt;value = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngx_free(test);</div><div class="line"></div><div class="line">    hinit-&gt;hash-&gt;buckets = buckets;</div><div class="line">    hinit-&gt;hash-&gt;size = size;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">ngx_str_t</span>   val;</div><div class="line">        <span class="keyword">ngx_uint_t</span>  key;</div><div class="line"></div><div class="line">        elt = buckets[i];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (elt == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: NULL"</span>, i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (elt-&gt;value) &#123;</div><div class="line">            val.len = elt-&gt;len;</div><div class="line">            val.data = &amp;elt-&gt;name[<span class="number">0</span>];</div><div class="line"></div><div class="line">            key = hinit-&gt;key(val.data, val.len);</div><div class="line"></div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: %p \"%V\" %ui"</span>, i, elt, &amp;val, key);</div><div class="line"></div><div class="line">            elt = (<span class="keyword">ngx_hash_elt_t</span> *) ngx_align_ptr(&amp;elt-&gt;name[<span class="number">0</span>] + elt-&gt;len,</div><div class="line">                                                   <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>常用的有创建 hash 和在 hash 中进行查找两个操作，对于创建hash的操作,过程一般为：  </p>
<ul>
<li>构造一个 <code>ngx_hash_key_t</code> 为成员的数组， 包含 key, value 和 使用key计算出的一个hash值  </li>
<li>构建一个 <code>ngx_hash_init_t</code> 结构体的变量， 其中包含了 <code>ngx_hash_t</code> 的成员， 为hash的结构体， 还包括一些其他初始设置，如bucket的大小，内存池等   </li>
<li>调用 <code>ngx_hash_init</code> 传入 <code>ngx_hash_init_t</code> 结构， <code>ngx_hash_key_t</code> 的数组，和数组的长度， 进行初始化，这样 <code>ngx_hash_init_t</code>的hash成员就是我们要的hash结构  </li>
</ul>
<p>查找的过程很简单</p>
<ul>
<li>计算 key 的hash值  </li>
<li>使用 <code>ngx_hash_find</code> 进行查找，需要同时传入 hash值和key ,返回的就是value的指针
需要注意的是，nginx 的 hash 在查找时使用的是分桶后线性查找法，因此当分桶数确定时查找效率同其中的总 key-val 对数量成反比。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx源码学习中的数据结构，主要包括数组结构&lt;code&gt;ngx_array_t&lt;/code&gt;、链表结构&lt;code&gt;ngx_list_t&lt;/code&gt;、队列结构&lt;code&gt;ngx_queue_t&lt;/code&gt;、哈希结构&lt;code&gt;ngx_hash_t&lt;/code&gt;、字符串结构&lt;code&gt;ngx_string_t&lt;/code&gt;。在内存池的基础之上进一步整合组织数据。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>笔记：虚函数实现机制</title>
    <link href="http://abumaster.com/2017/06/10/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://abumaster.com/2017/06/10/笔记：虚函数实现机制/</id>
    <published>2017-06-10T15:26:43.000Z</published>
    <updated>2017-06-11T00:20:28.488Z</updated>
    
    <content type="html"><![CDATA[<p>C++的虚函数是实现多态的一种方法，那么它的实现机制如何，笔记记录如下。  </p>
<a id="more"></a>
<p>虚函数的实现机制就是：虚表和虚指针。虚函数在运行期间来确定类型，即动态绑定，而构造函数在构造对象的时候就应该知道类型，这也是构造函数不能声明为虚函数的原因。<br>先看一个例子，假设两个类A和B：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://ooo.0o0.ooo/2017/06/11/593c8c1a67649.png" alt="">  </p>
<p>虚函数地址的获得<br><code>A *p = new B;</code><br>p:是个指针。<br><code>(int *)p</code>：转换成 int 类型的指针<br><code>*(int *)p</code>：把转换成int 类型指针p 的内容取出<br><code>(int *)( *(int *)p)</code>：在转换成 int 类型的指针<br><code>(int *)( *(int *)p) +0</code>：取出第一个元素的地址<br><code>*((int *)( *(int *)p) +0)</code>：得到第一个元素的内容<br><code>(void *)(*((int *)( *(int *)p) +0))</code>：得到第一个元素的地址  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++的虚函数是实现多态的一种方法，那么它的实现机制如何，笔记记录如下。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
</feed>
