<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <icon>https://www.gravatar.com/avatar/c23e0b827a934d7b3e4ebf0c652670b6</icon>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2018-10-07T13:52:29.904Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>conda创建Python虚拟环境</title>
    <link href="http://abumaster.com/2018/10/07/conda%E5%88%9B%E5%BB%BAPython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://abumaster.com/2018/10/07/conda创建Python虚拟环境/</id>
    <published>2018-10-07T13:16:02.000Z</published>
    <updated>2018-10-07T13:52:29.904Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda和conda创建虚拟Python环境，解决不同项目对于Python 版本的要求不同的问题。</p><a id="more"></a><p>在本机上安装Anaconda，Python科学计算包，Windows下，有 <em>Navigator</em> 可以直接创建和管理包。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-10-7/34764981.jpg" alt=""><br>很方便。<br>现在使用 <strong>conda</strong> 命令，创建和切换虚拟环境。<br><strong>conda常用的命令：</strong>  </p><ul><li><code>conda -V</code> 查看版本信息；  </li><li><code>conda -h</code> 查看帮助信息；  </li><li><code>conda list</code> 列出当前环境下可用的Python包；  </li><li><code>conda create -n &lt;envname&gt; python=x.x</code> 创建Python版本为x.x的虚拟环境；  </li><li><code>conda env list</code> 列出存在的Python虚拟环境；  </li><li><code>conda install -n &lt;envname&gt; &lt;package&gt;</code> 为指定的虚拟环境安装指定的包；  </li><li><code>conda remove --name &lt;envname&gt; &lt;package&gt;</code> 移除指定虚拟环境中的包；  </li><li><code>conda remove -n &lt;envname&gt; --all</code> 删除虚拟环境。    </li></ul><p><strong>激活和关闭虚拟环境:</strong>  </p><ul><li>Linux上开启：source activate envname  </li><li>Linux上关闭：source deactivate  </li><li>Windows上开启：activate envname  </li><li>Windows上关闭：deactivate  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Anaconda和conda创建虚拟Python环境，解决不同项目对于Python 版本的要求不同的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Python" scheme="http://abumaster.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7关闭防火墙</title>
    <link href="http://abumaster.com/2018/10/07/CentOS7%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://abumaster.com/2018/10/07/CentOS7关闭防火墙/</id>
    <published>2018-10-07T09:30:39.000Z</published>
    <updated>2018-10-07T09:46:31.921Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 7.X默认使用的是firewall作为防火墙，如果你想用CentOS主机做一个服务器和其他主机交互，socket通信什么或者要访问主机的资源，不把默认防火墙关掉是不行的。<a id="more"></a></p><h3 id="关闭默认的-firewall"><a href="#关闭默认的-firewall" class="headerlink" title="关闭默认的 firewall"></a>关闭默认的 firewall</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">firewall-cmd --state <span class="comment">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure><h3 id="开启-iptables"><a href="#开启-iptables" class="headerlink" title="开启 iptables"></a>开启 iptables</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iptables-services     <span class="comment">#安装iptables</span></span><br><span class="line">systemctl <span class="built_in">enable</span> iptables            <span class="comment">#设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service    <span class="comment">#两个都执行</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 7.X默认使用的是firewall作为防火墙，如果你想用CentOS主机做一个服务器和其他主机交互，socket通信什么或者要访问主机的资源，不把默认防火墙关掉是不行的。
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置ssh免密码登录</title>
    <link href="http://abumaster.com/2018/07/14/Linux%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>http://abumaster.com/2018/07/14/Linux配置ssh免密码登录/</id>
    <published>2018-07-14T13:47:46.000Z</published>
    <updated>2018-07-14T14:32:43.281Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ssh</strong> 是一种安全加密的网络协议，用于远程登录，传输的过程中，密码是加密的，加密的方式如rsa，非对称加密，生成了公钥和私钥。免密登录应用十分广泛，如在Github中提交代码时，通过ssh的方式，将本机生成的公钥拷贝到Github网站的sshkey中，可以不用每次验证密码。免密登录远程Linux主机，如何配置这些呢？  </p><a id="more"></a><h1 id="本机免密登录"><a href="#本机免密登录" class="headerlink" title="本机免密登录"></a>本机免密登录</h1><p>首先，生成秘钥对 <code>ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa</code> ，其中指定了加密算法，以及生成的私钥和公钥的保存位置：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.ssh</span><br><span class="line">├── id_rsa</span><br><span class="line">└── id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>然后将密码插入到认证过的公钥中<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># authorized_keys 可能一开始是空的，公钥按序加入文件的末尾</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><p>现在，可以通过ssh来登录了<code>ssh localhost</code>，不再需要输入密码了。</p><h1 id="远程免密登录"><a href="#远程免密登录" class="headerlink" title="远程免密登录"></a>远程免密登录</h1><p>远程主机的登录类似，首先在远程主机上生成一个sshkey，同样将公钥添加到<code>authorize_keys</code>文件中，然后可以通过 <code>ssh user@host</code> 来访问远程主机了。<br>注：生成key时的密码。<br><a href="http://notes.maxwi.com/">参考博客</a><a href="http://mirror.hust.edu.cn/apache/hadoop/common/hadoop-2.7.6/hadoop-2.7.6.tar.gz">http://mirror.hust.edu.cn/apache/hadoop/common/hadoop-2.7.6/hadoop-2.7.6.tar.gz</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ssh&lt;/strong&gt; 是一种安全加密的网络协议，用于远程登录，传输的过程中，密码是加密的，加密的方式如rsa，非对称加密，生成了公钥和私钥。免密登录应用十分广泛，如在Github中提交代码时，通过ssh的方式，将本机生成的公钥拷贝到Github网站的sshkey中，可以不用每次验证密码。免密登录远程Linux主机，如何配置这些呢？  &lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>GCC编译选项参数介绍[转]</title>
    <link href="http://abumaster.com/2018/07/08/GCC%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D-%E8%BD%AC/"/>
    <id>http://abumaster.com/2018/07/08/GCC编译选项参数介绍-转/</id>
    <published>2018-07-08T14:51:52.000Z</published>
    <updated>2018-07-08T15:10:09.628Z</updated>
    
    <content type="html"><![CDATA[<p>从网上转载的 <a href="https://blog.csdn.net/fengbingchun/article/details/80960916">GCC常见的编译选项参数介绍</a> ，希望在以后的学习中有所用到。<a id="more"></a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#(1). -x: 设定文件所使用的语言，使文件后缀名无效，如下，执行完后生成test.o</span></span><br><span class="line">gcc -c -x c++ test.jpg</span><br><span class="line"><span class="comment">#(2). -c: 只编译生成目标文件即*.o,只编译不链接生成可执行文件，如下，执行完后生成test.o</span></span><br><span class="line">gcc -c test.cpp</span><br><span class="line"><span class="comment">#(3). -S: 把文件编译成为汇编源文件，如下，执行完后生成test.s</span></span><br><span class="line">gcc -S test.cpp</span><br><span class="line"><span class="comment">#(4). -o: 指定生成的可执行文件，输出文件名称，gcc编译出来的文件缺省的是a.out，如下，执行完后生成test执行文件</span></span><br><span class="line">gcc -o <span class="built_in">test</span> -c test.cpp</span><br><span class="line"><span class="comment">#(5). -ansi: 关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏),仅支持ANSI标准的C语法，如下</span></span><br><span class="line">gcc -ansi -c test.cpp</span><br><span class="line"><span class="comment">#(6). -fno-asm: 禁止将asm,inline和typeof用作关键字，如下</span></span><br><span class="line">gcc -fno-asm -c test.cpp</span><br><span class="line"><span class="comment">#(7). -funsigned-char或-fno-signed-char: 对char类型进行设置，将char类型设置成unsigned char，如下</span></span><br><span class="line">gcc -funsigned-char -c test.cpp</span><br><span class="line">gcc -fno-signed-char -c test.cpp</span><br><span class="line"><span class="comment">#(8). -fsigned-char或-fno-unsigned-char: 对char类型进行设置，将char类型设置成signed char，如下</span></span><br><span class="line">gcc -fsigned-char -c test.cpp</span><br><span class="line">gcc -fno-unsigned-char -c test.cpp</span><br><span class="line"><span class="comment">#(9). -include file_name: 在编译test.cpp文件需要aa.hpp文件的时候使用，而此时test.cpp文件中并没有#include "../aa.hpp",相当于在代码中使用#include "../aa.hpp",如下</span></span><br><span class="line">gcc -c test.cpp -include ../aa.hpp</span><br><span class="line"><span class="comment">#(10). -Dmacro_name: 相当于C语言中的#define macro_name,如下</span></span><br><span class="line">gcc -DTEST_MAIN -c test.cpp</span><br><span class="line"><span class="comment">#(11). -Dmacro_name=value: 相当于C语言中的#define macro_name value,如下</span></span><br><span class="line">gcc -DTEST_MAIN=2 -c test.cpp</span><br><span class="line"><span class="comment">#(12). -Umacro_name: 相当于C语言中的#undef macro_name,如下</span></span><br><span class="line">gcc -Umax -c test.cpp</span><br><span class="line"><span class="comment">#(13). -Idir_name: 在test.cpp文件中#include "aa.hpp"文件，而aa.hpp又没有和test.cpp在同一目录下时使用，gcc/g++会到-I指定的目录下查找，即指定额外的头文件搜索路径，如下</span></span><br><span class="line">gcc -c test.cpp -I../</span><br><span class="line"><span class="comment">#(14). -dirafter dir_name: 如果-I指定的目录查找失败，将到这个目录里查找，如下</span></span><br><span class="line">gcc -c test.cpp -I../../ -idirafter ../</span><br><span class="line"><span class="comment">#(15). -nostdinc: 使编译器不再系统缺省的目录里查找头文件，一般和-I一起使用，明确限定头文件的位置</span></span><br><span class="line">gcc -c test.cpp -I../ -nostdinc</span><br><span class="line"><span class="comment">#(16). -C: 在预处理的时候，不删除注释信息,如下</span></span><br><span class="line">gcc -C -c test.cpp -I../</span><br><span class="line"><span class="comment">#(17). -M: 生成文件关联信息，目标文件依赖的所有文件，如下</span></span><br><span class="line">gcc -M -c test.cpp -I../</span><br><span class="line"><span class="comment">#(18). -MM: 生成文件关联信息，与-M相似，但是它将忽略由#include &lt;file&gt;造成的依赖关系，如下</span></span><br><span class="line">gcc -MM -c test.cpp -I../</span><br><span class="line"><span class="comment">#(19). -Wa,option: 此选项传递option给汇编程序;如果option中间有逗号,就将option分成多个选项,然后传递给会汇编程序</span></span><br><span class="line"><span class="comment">#(20). -Wl.option: 此选项传递option给链接程序;如果option中间有逗号,就将option分成多个选项,然后传递给会链接程序</span></span><br><span class="line"><span class="comment">#(21). -llibrary_name: 指定链接时搜索指定的库，如下</span></span><br><span class="line">gcc -c test.cpp -I../ -lpthread</span><br><span class="line"><span class="comment">#(22). -Ldir: 指定额外的库搜索路径，如下</span></span><br><span class="line">gcc -c test.cpp -I../ -L../</span><br><span class="line"><span class="comment">#(23). -O0或-O1或-O2或-O3：编译器优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高，如下</span></span><br><span class="line">gcc -O3 -c test.cpp -I../ -L../</span><br><span class="line"><span class="comment">#(24). -g: 指示编译器在编译的时候产生调试信息，如下</span></span><br><span class="line">gcc -O3 -g -c test.cpp -I../ -L../</span><br><span class="line"><span class="comment">#(25). -gstabs: 此选项以stabs格式生成调试信息，但是不包括gdb调试信息，如下 </span></span><br><span class="line">gcc -O3 -gstabs -c test.cpp -I../ -L../</span><br><span class="line"><span class="comment">#(26). -gstabs+: 此选项以stabs格式生成调试信息，并且包含仅供gdb使用的额外调试信息，如下</span></span><br><span class="line">gcc -O3 -gstabs+ -c test.cpp -I../ -L../</span><br><span class="line"><span class="comment">#(27). -ggdb: 此选项将尽可能的生成gdb可以使用的调试信息，如下</span></span><br><span class="line">gcc -O3 -ggdb -c test.cpp -I../ -L../</span><br><span class="line"><span class="comment">#(28). -static: 此选项将禁止使用动态库，一般编译出来的文件比较大，不需要什么动态链接库就可以运行，如下</span></span><br><span class="line">cc -static -o <span class="built_in">test</span> -c test.cpp -I../</span><br><span class="line"><span class="comment">#(29). -shared: 此选项将尽可能使用动态库，一般编译出来的文件比较小，如下</span></span><br><span class="line">gcc -shared -o <span class="built_in">test</span> -c test.cpp -I../</span><br><span class="line"><span class="comment">#(30). -tradional: 试图让编译器支持传统的C语言特性，如下</span></span><br><span class="line">gcc -traditional -o <span class="built_in">test</span> -c test.cpp -I../</span><br><span class="line"><span class="comment">#(31). -E: 预编译后停下来，生成后缀为*.i的预编译文件，如下</span></span><br><span class="line">gcc -E -o test.i test.cpp -I../</span><br><span class="line"><span class="comment">#(32). -w: 不生成任何警告信息，如下</span></span><br><span class="line">gcc -w -o <span class="built_in">test</span> -c test.cpp -I../</span><br><span class="line"><span class="comment">#(33). -Wall: 生成所有警告信息，如下</span></span><br><span class="line">gcc -Wall -o <span class="built_in">test</span> -c test.cpp -I../</span><br><span class="line"><span class="comment">#(34). -pedantic: 当gcc在编译不符合ANSI/ISO C语言标准的源代码时，将产生相应的警告信息，如下</span></span><br><span class="line">gcc -pedantic -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(35). -Werror: 要求gcc将所有的警告信息当成错误进行处理，如下</span></span><br><span class="line">gcc -Werror -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(36). -Wcast-align: 当源程序中地址不需要对齐的指针指向一个地址需要对齐的变量地址时则产生一个警告，如下</span></span><br><span class="line">gcc -Wcast-align -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(37). -p或-pg: 会将剖析(profiling)信息加入到最终生成的二进制文件中，剖析信息对于找出程序的性能瓶颈很有帮助，如下</span></span><br><span class="line">gcc -p -o <span class="built_in">test</span> test.cpp</span><br><span class="line">gcc -pg -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(38). -save-temps: 保存编译过程中生成的一些中间文件，如test.s, test.ii，如下</span></span><br><span class="line">gcc -save-temps -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(40). -pipe: 使用管道代替编译中临时文件，如下</span></span><br><span class="line">gcc -pipe -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(41). -ftime-report: 统计编译消耗的时间并显示报告，如下</span></span><br><span class="line">gcc -ftime-report -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(42). -fmem-report: 显示所有的静态内存分配，如下</span></span><br><span class="line">gcc -fmem-report -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(43). -march: 指定目标架构选项，如下</span></span><br><span class="line">gcc -march=native -Q --help=target | grep march</span><br><span class="line"><span class="comment">#(44). -fpic或-fPIC: 如果支持目标机，编译器就生成位置无关目标码，适用于共享库，如下</span></span><br><span class="line">gcc -fpic -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(45). -fno-rtti: 禁用运行时类型信息，如下</span></span><br><span class="line">gcc -fno-rtti -o <span class="built_in">test</span> test.cpp</span><br><span class="line"><span class="comment">#(46). -fno-exceptions: 禁用异常机制，如下</span></span><br><span class="line">gcc -fno-exceptions -o <span class="built_in">test</span> test.cpp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从网上转载的 &lt;a href=&quot;https://blog.csdn.net/fengbingchun/article/details/80960916&quot;&gt;GCC常见的编译选项参数介绍&lt;/a&gt; ，希望在以后的学习中有所用到。
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>安装 Ubuntu server 版本</title>
    <link href="http://abumaster.com/2018/06/26/%E5%AE%89%E8%A3%85Ubuntu-server%E7%89%88%E6%9C%AC/"/>
    <id>http://abumaster.com/2018/06/26/安装Ubuntu-server版本/</id>
    <published>2018-06-26T13:17:45.000Z</published>
    <updated>2018-07-01T13:48:17.807Z</updated>
    
    <content type="html"><![CDATA[<p>从同学那里得到了一个免费的显卡坏掉的戴尔笔记本，所以装一个 Ubuntu server 玩一下。安装 Ubuntu server 版本与安装桌面版的有一些不同，同样在物理机上安装与在虚拟机中安装也不同，记录一些在安装过程中出现的问题。</p><a id="more"></a><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><p>1.从 <a href="https://www.ubuntu.com/download/alternative-downloads">Ubuntu 官网</a> 上下载对应的服务器版本。<br>2.制作U盘启动器，用 UltraISO 将ISO刻录到U盘中，作为启动盘。<br>3.开机boot用U盘启动。<br>4.一路选择安装。  </p><p><strong>事情当然不会这么容易了，安装过程中出现了很多问题。</strong>  </p><h1 id="问题出现和解决"><a href="#问题出现和解决" class="headerlink" title="问题出现和解决"></a>问题出现和解决</h1><h2 id="光盘无法读取"><a href="#光盘无法读取" class="headerlink" title="光盘无法读取"></a>光盘无法读取</h2><p>安装过程出现 CD-ROM 读取失败，这种情况。首先，我们制作好了 U盘启动盘，也要把Ubuntu的iso镜像拷贝到U盘的根目录下。然后，再一次重新开始安装。出现错误，退出打开命令行工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/sd* #显示出所有的硬件设备，一般u盘就是dev/sdb 那么u盘上的分区就是dev/sdb1</span><br><span class="line">#创建一个空目录，将U盘分区挂载到这个空目录上</span><br><span class="line">mkdir ubt</span><br><span class="line">mount /dev/sdb1 /ubt</span><br><span class="line"># 然后将其中的Ubuntu ISO镜像挂载到cdrom上</span><br><span class="line">mount /ubt/ubuntu-xxx.iso /cdrom</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><h2 id="无线网络设置"><a href="#无线网络设置" class="headerlink" title="无线网络设置"></a>无线网络设置</h2><p>使用到的工具 <code>wpasupplicant</code> ，一般高版本的Linux集成了这个工具。<br>生成无线路由密钥。这一步就是根据你无线网络的SSID和密码，来生成WLAN需要的配置文件。命令如下：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#wpa_passphrase 无线网络SSID 无线网络密码 &gt; 配置文件名</span></span><br><span class="line"><span class="comment">#wpa_passphraseTP-LINK 123456 &gt; /etc/wpa_config.conf</span></span><br></pre></td></tr></table></figure></p><p>设置无线网络。编辑 <code>/etc/network/interfaces</code> 文件，将wlan添加到其中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">wpa-conf /etc/wpa_config.conf</span><br></pre></td></tr></table></figure></p><p>一般人的都是<code>eth0</code>，和<code>wlan0</code>，但在Ubuntu Server 16.04里面变成了<code>enp4s0</code> 和 <code>wlp5s0</code>，所以还需要查看网卡的名称，有时 <code>wlan0</code>这个名称是不对的，所以使用 <code>ip addr</code> 查看网卡的名称，进行替换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从同学那里得到了一个免费的显卡坏掉的戴尔笔记本，所以装一个 Ubuntu server 玩一下。安装 Ubuntu server 版本与安装桌面版的有一些不同，同样在物理机上安装与在虚拟机中安装也不同，记录一些在安装过程中出现的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="其他" scheme="http://abumaster.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行练习</title>
    <link href="http://abumaster.com/2018/06/15/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%83%E4%B9%A0/"/>
    <id>http://abumaster.com/2018/06/15/Linux命令行练习/</id>
    <published>2018-06-15T08:29:33.000Z</published>
    <updated>2018-06-26T14:59:59.065Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下命令行练习，旨在熟悉Linux下的命令，以及常用的工具。题目来源一个好玩的网站，<a href="https://cmdchallenge.com/">cmdchallenge</a>，以挑战的形式对各种命令进行练习。  </p><a id="more"></a><h1 id="主要界面"><a href="#主要界面" class="headerlink" title="主要界面"></a>主要界面</h1><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-15/99270386.jpg" alt=""><br>当在题目下，输入正确的命令，并得出正确的结果时，会进入下一条命令，根据要求，用相关的命令，得到符合要求的结果。  </p><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p><strong>grep</strong> 是一个全面按照正则表达式，搜索匹配文本的工具，把匹配的行打印出来。<br>使用：<code>grep [opetion]... pattern [FILE]...</code>，options如下：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上下文显示控制：</span></span><br><span class="line">-A &lt;显示行数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span><br><span class="line">-B &lt;显示的行数&gt; 除了显示符合要求的样式那一行外，并显示该行之前的内容。</span><br><span class="line">-C &lt;显示上下文行数&gt;  除了显示符合范本样式的那一列之外，并显示该行之前后的几行内容。</span><br><span class="line">--color 用颜色标记符合条件的匹配项</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出控制：</span></span><br><span class="line">-c 输出匹配的行数。</span><br><span class="line">-m &lt;NUM&gt; 输出匹配的NUM个结果。</span><br><span class="line">-b 在结果前加上，匹配项所在的字符偏移量。</span><br><span class="line">-n 在输出结果上加上行号。</span><br><span class="line">-H 输出结果前面加上文件名。</span><br><span class="line">-h 不输出文件名。</span><br><span class="line">-o 只输出完全匹配的内容。</span><br><span class="line"><span class="_">-a</span> 将二进制文件当做文本文件处理。</span><br><span class="line">-I 忽略二进制文件。</span><br><span class="line"><span class="_">-d</span>, --directories=ACTION  how to handle directories;ACTION is <span class="string">'read'</span>, <span class="string">'recurse'</span>, or <span class="string">'skip'</span></span><br><span class="line">-r -R 递归文件夹。</span><br><span class="line">-L 输出不匹配的文件名。</span><br><span class="line"><span class="_">-l</span> 只输出包含匹配的文件名。</span><br><span class="line">-q 不显示任何信息。</span><br><span class="line">-Z 输出的文件名后加上 0 bytes。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式</span></span><br><span class="line"><span class="_">-e</span>&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。</span><br><span class="line">-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span><br><span class="line"><span class="_">-f</span>&lt;范本文件&gt; 从文件中获得匹配样式，其中每一行为一个样式</span><br><span class="line">-F 将范本样式视为固定字符串的列表。</span><br><span class="line">-G 将范本样式视为普通的表示法来使用。</span><br><span class="line">-i 忽略字符大小写的差别。</span><br><span class="line">-v 反转查找。</span><br><span class="line">-w 只显示全字符合的匹配项。</span><br><span class="line">-x 只显示全行符合的匹配项。</span><br></pre></td></tr></table></figure></p><p><strong>举个栗子：</strong><br>Windows 下使用 <code>tasklist</code> 命令，将进程信息保存到一个文件中，以此来测试 <code>grep</code> 的各个命令。<br><strong>1.简单的输出上下文相关的行</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/44782426.jpg" alt=""><br><strong>2.输出控制</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/41090895.jpg" alt=""><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   -m5   表示输出匹配结果的5行</span></span><br><span class="line"><span class="comment">#   -b    表示输出匹配结果的偏移量</span></span><br><span class="line"><span class="comment">#   -n    输出匹配结果所在的行号</span></span><br><span class="line"><span class="comment">#   -H    输出结果前加上文件名</span></span><br><span class="line"><span class="comment">#   -o    输出完全匹配的信息，而不是整行内容</span></span><br><span class="line"><span class="comment">#   -a    将二进制文件当做文本来处理</span></span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/96928073.jpg" alt=""><br>正则表达式的应用。正则表达式的基本标识符。  </p><table><thead><tr><th style="text-align:center">字符</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>$</code></td><td>匹配输入字符结束的位置</td></tr><tr><td style="text-align:center"><code>*</code></td><td>匹配前面的子表达式零次或多次</td></tr><tr><td style="text-align:center"><code>+</code></td><td>匹配前面的子表达式一次或多次</td></tr><tr><td style="text-align:center"><code>.</code></td><td>匹配单个字符</td></tr><tr><td style="text-align:center"><code>[</code></td><td>标识一个中括号表达式的开始</td></tr><tr><td style="text-align:center"><code>?</code></td><td>匹配前面的字表达式零次或一次</td></tr><tr><td style="text-align:center"><code>\</code></td><td>转义字符，如果要匹配有特殊含义的字符，需要加上进行转义</td></tr><tr><td style="text-align:center"><code>^</code></td><td>匹配输入字符的开始位置，当出现在中括号中时，则表示不接受任何表达式</td></tr><tr><td style="text-align:center"><code>{</code></td><td>标记限定表达式的开始</td></tr><tr><td style="text-align:center"><code>这是竖线</code></td><td>指定在两项之中进行一个选择</td></tr><tr><td style="text-align:center"><code>\&lt;</code></td><td>表示词首</td></tr><tr><td style="text-align:center"><code>\&gt;</code></td><td>表示词尾</td></tr></tbody></table><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><strong>1.extract_ip_address</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extract all IP addresses from files</span></span><br><span class="line"><span class="comment"># that start with "access.log" printing one</span></span><br><span class="line"><span class="comment"># IP address per line.</span></span><br><span class="line">grep -r -o ^[0-9.]*</span><br></pre></td></tr></table></figure></p><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p><strong>sed</strong> 是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。<br><strong>sed 命令格式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed [options] &apos;command&apos; file(s)</span><br><span class="line">sed [options] -f scripfile file(s)</span><br></pre></td></tr></table></figure></p><p><strong>sed 的选项</strong><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="_">-e</span> &lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的script来处理输入的文本文件；</span><br><span class="line"><span class="_">-f</span> &lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script文件来处理输入的文本文件；</span><br><span class="line">-h 或 --help：显示帮助；</span><br><span class="line">-n 或 --quiet或--silent：仅显示script处理后的结果；</span><br><span class="line">-V 或--version：显示版本信息；</span><br><span class="line">-b 二进制模式打开文件；</span><br><span class="line">-E 或 -r 在脚本中使用扩展的正则表达式</span><br><span class="line">-u 或 --unbuffered </span><br><span class="line">-i 在原文件中编辑</span><br></pre></td></tr></table></figure></p><p><strong>sed 命令：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a\  在当前行下面插入文本</span><br><span class="line">i\  在当前行上面插入文本</span><br><span class="line">c\  把选定的行改为新的文本</span><br><span class="line"></span><br><span class="line">d   删除，删除选择的行</span><br><span class="line">D   删除模块的第一行</span><br><span class="line">s   替换指定的字符</span><br><span class="line">h   拷贝模板块的内容到内存中的缓冲区。</span><br><span class="line">H   追加模板块的内容到内存中的缓冲区。</span><br><span class="line">g   替换一行中的所有匹配到的内容。</span><br><span class="line">G   获得内存缓冲区的内容，并追加到当前模板块文本的后面。</span><br><span class="line">l   列表不能打印字符的清单。</span><br><span class="line">n   读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</span><br><span class="line">N   追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。</span><br><span class="line">p   打印模板块的行。</span><br><span class="line">P   打印模板块的第一行。</span><br><span class="line">q   退出Sed。</span><br><span class="line">b   lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。</span><br><span class="line">r   file 从file中读行。</span><br><span class="line">t   label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span><br><span class="line">T   label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span><br><span class="line">w   file 写并追加模板块到file末尾。  </span><br><span class="line">W   file 写并追加模板块的第一行到file末尾。  </span><br><span class="line">!   表示后面的命令对所有没有被选定的行发生作用。  </span><br><span class="line">=   打印当前行号码。  </span><br><span class="line">#   把注释扩展到下一个换行符以前。</span><br></pre></td></tr></table></figure></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>1.替换文本中的字符串</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/hello/world/'</span> file</span><br><span class="line"><span class="comment"># 显示发生更改的行</span></span><br><span class="line">sed -n <span class="string">'s/test/TEST/p'</span> file</span><br><span class="line"><span class="comment"># 在源文件中更改 /g对符合条件全部替换</span></span><br><span class="line">sed -i <span class="string">'s/hello/world/g'</span> file</span><br><span class="line"><span class="comment"># 从第N处匹配开始替换使用 /Ng</span></span><br><span class="line"><span class="built_in">echo</span> hhhhhhhh | sed <span class="string">'s/h/H/3g'</span> <span class="comment"># 从第三个h开始替换</span></span><br></pre></td></tr></table></figure></p><p><strong>2.删除文本中信息</strong><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除空白行</span></span><br><span class="line">sed <span class="string">'/^$/d'</span> file</span><br><span class="line"><span class="comment"># 删除文件的第二行</span></span><br><span class="line">sed <span class="string">'2d'</span> file</span><br><span class="line"><span class="comment"># 删除文件第二行到末尾</span></span><br><span class="line">sed <span class="string">'2,$d'</span> file</span><br><span class="line"><span class="comment"># 删除文件最后一行</span></span><br><span class="line">sed <span class="string">'$d'</span> file</span><br><span class="line"><span class="comment"># 删除所有 test开头的行</span></span><br><span class="line">sed <span class="string">'/^test/d'</span> file</span><br></pre></td></tr></table></figure></p><h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>用于显示指定文件中末尾的几行内容，如果表示字符或行数的N数值之后有<code>+</code>时，则表示从N行开始，到文件尾。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c [+]NUM 输出结尾的NUM个字节数，+NUM 表示输出从NUM字节开始到文件尾的信息，可以在其后加上单位，如k，kB，K，MB；</span><br><span class="line">-n [+]NUM 输出最后NUM行的信息，+NUM 表示从NUM行开始到结尾的数据输出；</span><br><span class="line">-v 显示文件头信息</span><br><span class="line">-q 不显示文件头信息</span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/93310029.jpg" alt="">  </p><h1 id="head"><a href="#head" class="headerlink" title="head"></a>head</h1><p>用于显示给定文件的前几行，默认10行，用途与<code>tail</code>正好相反，用管道结合起来可以显示文件中间的几行。用法<code>head 选项 参数</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt;：指定显示头部内容的行数；</span><br><span class="line">-c&lt;字符数&gt;：指定显示头部内容的字符数；</span><br><span class="line">-v：总是显示文件名的头信息；</span><br><span class="line">-q：不显示文件名的头信息。</span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/49603155.jpg" alt="">  </p><p>结合<code>tail</code>显示中间的文件<code>cat file1.md | tail -n +10 | head 10</code>，输出10行开始到19行结束。</p><h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1><p>字符字节统计命令，利用wc指令我们可以计算文件的Byte数、字数或是列数。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c或--bytes或——chars：只显示Bytes数；</span><br><span class="line">-m 统计字符数目</span><br><span class="line"><span class="_">-l</span> lines：只显示列数；</span><br><span class="line">-w words：只显示字数。</span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/72464158.jpg" alt="">  </p><h1 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h1><p><code>tr</code> 命令，对来自标准输入的字符进行替换、删除和压缩处理，将一组字符变成另一组字符。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c或--complerment：取代所有不属于第一字符集的字符；</span><br><span class="line"><span class="_">-d</span>或--delete：删除所有属于第一字符集的字符；</span><br><span class="line"><span class="_">-s</span>或--squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。</span><br><span class="line"><span class="comment"># 字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</span></span><br><span class="line"><span class="comment"># 字符集2：指定要转换成的目标字符集。</span></span><br></pre></td></tr></table></figure></p><p><strong>tr 可以使用的字符类：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[:alnum:]：字母和数字</span><br><span class="line">[:alpha:]：字母</span><br><span class="line">[:cntrl:]：控制（非打印）字符</span><br><span class="line">[:digit:]：数字</span><br><span class="line">[:graph:]：图形字符</span><br><span class="line">[:lower:]：小写字母</span><br><span class="line">[:<span class="built_in">print</span>:]：可打印字符</span><br><span class="line">[:punct:]：标点符号</span><br><span class="line">[:space:]：空白字符</span><br><span class="line">[:upper:]：大写字母</span><br><span class="line">[:xdigit:]：十六进制字符</span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-18/90763520.jpg" alt="">  </p><h1 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h1><blockquote><p>用来输出某一个数到另一个数之间的所有整数序列</p></blockquote><p>主要参数：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用法</span></span><br><span class="line">seq [选项]... 尾数</span><br><span class="line">seq [选项]... 首数 尾数</span><br><span class="line">seq [选项]... 首数 增量 尾数</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项</span></span><br><span class="line"><span class="_">-f</span>, --format=格式        使用<span class="built_in">printf</span> 样式的浮点格式</span><br><span class="line"><span class="_">-s</span>, --separator=字符串   使用指定字符串分隔数字（默认使用：\n）</span><br><span class="line">-w, --equal-width        在列前添加0 使得宽度相同 不能和<span class="_">-f</span>同时使用</span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-18/9882993.jpg" alt="">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 下命令行练习，旨在熟悉Linux下的命令，以及常用的工具。题目来源一个好玩的网站，&lt;a href=&quot;https://cmdchallenge.com/&quot;&gt;cmdchallenge&lt;/a&gt;，以挑战的形式对各种命令进行练习。  &lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="cmd" scheme="http://abumaster.com/tags/cmd/"/>
    
      <category term="linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>工具集</title>
    <link href="http://abumaster.com/2018/06/13/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <id>http://abumaster.com/2018/06/13/工具集/</id>
    <published>2018-06-13T12:57:58.000Z</published>
    <updated>2018-06-13T13:38:20.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>提高效率工具集汇总，备忘，装机必备。</p></blockquote><a id="more"></a><h3 id="Windows-高效工具集合"><a href="#Windows-高效工具集合" class="headerlink" title="Windows 高效工具集合"></a>Windows 高效工具集合</h3><h4 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h4><p><strong>C++</strong>：  </p><ul><li>宇宙最强IDE <strong>visual studio 2015</strong>，<a href="https://msdn.itellyou.cn/">下载</a>，专业版的密钥<code>HMGNV-WCYXV-X7G9W-YCX63-B98R2</code>，网上可以随处找到。 </li><li>开源跨平台 Qt ，<a href="http://download.qt.io/archive/qt/">下载列表</a>，可以选择 <em>MinGW</em> 或者 <em>vc</em> 作为编译器。</li><li>gVim sublime txt 3 with MinGW <a href="https://keelii.github.io/2016/06/13/awsome-window-vimrc/">配置好看的界面</a>。</li><li>文本编辑器  <ul><li><a href="http://www.sublimetextcn.com/3/">sublimetext3</a>  </li><li><a href="https://code.visualstudio.com/">vscode</a> </li><li><a href="https://ivarptr.github.io/yu-writer.site/">yuwrite</a></li></ul></li><li>Windows C++开发依赖工具包管理 <a href="https://github.com/Microsoft/vcpkg">vcpkg.exe</a></li><li>帮助文档  <a href="https://zealdocs.org/">Zeal</a></li></ul><p><strong>Python</strong>：  </p><ul><li>Python 工具包 <a href="https://repo.continuum.io/archive/">Anaconda3</a></li><li>IDE JetBrains PyCharm 太卡了，改用 vscode 或者 sublime text3 配置Python开发环境。</li></ul><p><strong>JavaScript相关</strong>：  </p><ul><li><a href="https://nodejs.org/zh-cn/">node.js</a> Windows版</li><li>好玩的前端框架:<ul><li><a href="&quot;https://alibaba.github.io/ice&quot;">ICE</a></li><li>react</li></ul></li></ul><p><strong>版本控制</strong>：</p><ul><li>git cmd </li><li>github Windows版</li><li>好用的终端 cmder</li></ul><p><strong>数据库</strong>：</p><ul><li>MySQL Redis MongoDB sqlite</li><li>数据库可视化 Navicat</li></ul><h4 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h4><p><strong>文档处理</strong>：</p><ul><li>office 2015</li><li>Visio 2015</li><li>极速PDF阅读器</li><li>officebox 万彩办公</li><li>Endnote 文献管理</li><li>iSlide PPT插件</li></ul><p><strong>小工具</strong>: </p><ul><li>快速启动小工具 launchy 和 cerebro</li><li>快速截图工具 Snipaster</li></ul><p><strong>下载</strong>: </p><ul><li>FDM</li></ul><h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h4><ul><li>搬瓦工 购买国外服务器，并且创建sserver</li><li>Shadowsocks 登录sserver</li><li>Chrome 好用插件集合</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提高效率工具集汇总，备忘，装机必备。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="工具" scheme="http://abumaster.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="效率" scheme="http://abumaster.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Feature Pyramid Networks for Object Detection</title>
    <link href="http://abumaster.com/2018/06/09/Detection/"/>
    <id>http://abumaster.com/2018/06/09/Detection/</id>
    <published>2018-06-09T01:26:26.000Z</published>
    <updated>2018-06-09T12:41:09.826Z</updated>
    
    <content type="html"><![CDATA[<p>用于物体检测的特征金字塔网络，由 FAIR 发表。特征金字塔是识别系统中检测不同尺度大小目标的基础组件，最近的基于深度学习的物体监测器中，避免使用金字塔表示，一个原因是对内存和计算敏感。本文使用固有的多尺度和金字塔形的卷积网络，构建特征金字塔，尽可能减少了额外的代价。一个自顶向下的有侧边连接的网络模型，用于为各个尺度构建高层次语义特征图。作为一个模块嵌入到其他物体检测模型中，有着很好的实验结果，为多尺度物体检测提供了一种解决方案。<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>多尺度物体的检测是计算机视觉任务中一个基本的挑战。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-9/27376237.jpg" alt="几种方式对比">  </p><ul><li>第一种，将原始图像缩放为不同的尺度，分别提取出特征图，进行预测；</li><li>第二种，单一的图像放入网络中，输出预测结果；</li><li>第三种，单张图像放入网络中，对不同层次，预测；</li><li>第四种，从不同层次中提取出特征图，构建成金字塔型的特征图，并预测。</li></ul><h1 id="特征金字塔网络"><a href="#特征金字塔网络" class="headerlink" title="特征金字塔网络"></a>特征金字塔网络</h1><p>本文提出了一种结构 <strong>Feature Pyramid Network（FPN）</strong> ，如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-9/69223848.jpg" alt="网络结构">  </p><ul><li><strong>Bottom-up pathway</strong>，自下而上的路径，与传统的卷积网络类似，分层次获得图像特征组合，特征图逐层缩小，而特征图的数量在增加，每一个层次被称为一个阶段，同时也是一个金字塔层次级别。  </li><li><strong>Top-down pathway and lateral connections</strong>，自顶下下的路径，通过上采样获得更大的分辨率特征图，很粗糙，但是从高层金字塔层次获得的语义更强。通过横向连接去优化这个分割图，横向连接将两条路径上，大小相同的特征图连接，自底向上的特征图包含了低层次的语义。  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用于物体检测的特征金字塔网络，由 FAIR 发表。特征金字塔是识别系统中检测不同尺度大小目标的基础组件，最近的基于深度学习的物体监测器中，避免使用金字塔表示，一个原因是对内存和计算敏感。本文使用固有的多尺度和金字塔形的卷积网络，构建特征金字塔，尽可能减少了额外的代价。一个自顶向下的有侧边连接的网络模型，用于为各个尺度构建高层次语义特征图。作为一个模块嵌入到其他物体检测模型中，有着很好的实验结果，为多尺度物体检测提供了一种解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="论文" scheme="http://abumaster.com/tags/lunwen/"/>
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="CV" scheme="http://abumaster.com/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>优秀架构师必须掌握的架构思维（转）</title>
    <link href="http://abumaster.com/2018/05/25/%E4%BC%98%E7%A7%80%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://abumaster.com/2018/05/25/优秀架构师必须掌握的架构思维（转）/</id>
    <published>2018-05-25T09:02:05.000Z</published>
    <updated>2018-05-25T11:41:11.142Z</updated>
    
    <content type="html"><![CDATA[<p>架构的本质是管理复杂性，<strong>抽象</strong>、<strong>分层</strong>、<strong>分治</strong> 和 <strong>演化</strong> 思维是我们工程师/架构师应对和管理复杂性的四种最基本武器。<a href="http://www.infoq.com/cn/articles/architecture-thought?utm_source=tuicool&amp;utm_medium=referral">原文地址</a>。</p><a id="more"></a><h4 id="抽象思维"><a href="#抽象思维" class="headerlink" title="抽象思维"></a>抽象思维</h4><p><strong>对某种事物进行简化描述或表示的过程，只关注要素而忽略具体的细节</strong>。<br>在系统架构和设计中，抽象帮助我们从大处着眼（get our mind about big picture），隐藏细节（temporarily hide details）。抽象能力的强弱，直接决定我们所能解决问题的复杂性和规模大小。<br>关于抽象层次的跳跃性，开发过程应该保证代码的抽象层次一致性，保证代码清晰明了。如在电商处理订单过程中，需要的流程如下：  </p><ul><li>更新库存信息；  </li><li>打折计算；  </li><li>支付卡校验；  </li><li>支付；  </li><li>送货。<br>上述流程处于同一个抽象层次上，在编写代码的时候，不应该出现一些细节性的问题，如在支付卡校验过程中，出现调用某一银行卡的支付api，这是不正确的，应该调用一个抽象的支付api，而不是细节。  </li></ul><h4 id="分层思维"><a href="#分层思维" class="headerlink" title="分层思维"></a>分层思维</h4><p>分层抽象，系统分为若干层次化的模块，每一个层次负责解决一个问题，下层向上层提供服务，一些层次贯穿所有层，被称为共享层。常见的分层模式有TCP/IP协议，操作系统等。  </p><h4 id="分治思维"><a href="#分治思维" class="headerlink" title="分治思维"></a>分治思维</h4><p>分而治之也是一种应对和管理复杂性的一般性方法，一次无法解决的大问题，划分成多个子问题，然后将子问题划分为更小的子问题，直到分解成可解的小问题集合，将这些解组合拼接成子问题的解，在以次拼成原问题的解。<br>面试时为了考察候选人的分治思维，我经常会面一个分治题：给你一台8G内存/500G磁盘空间的普通电脑，如何对一个100G的大文件进行排序？假定文件中都是字符串记录，一行约100个字符。<br>这是一个典型的分治问题，100G的大文件肯定无法一次加载到内存直接排序，所以需要先切分成若干小问题来解决。那么8G内存的计算机一次大概能排多大的数据量，可以在有限的时间内排完呢？也就是100G的大文件要怎么切法，切成多少份比较合适？这个是考察候选人的时间空间复杂度估算能力，需要一定的计算机组织和算法功底，也需要一定实战经验和sense。实际上8G内存的话，操作系统要用掉一部分，如果用Java开发排序程序，大致JVM可用2~4G内存，基于一般的经验值，一次排1G左右的数据应该没有问题（我实际在计算机上干过1G数据的排序，是OK的）。所以100G的文件需要先切分成100份，每份1G，这样每个子文件可以直接加载到内存进行排序。对于1G数据量的字符串排序，采用Java里头提供的快速排序算法是比较合适的。<br>好，经过有限时间的排序（取决于计算机性能，快的一天内能排完），假定100个1G的文件都已经排好了，相当于现在硬盘上有100个已经排好序的文件，但是我们最终需要的是一个排好序的文件，下面该怎么做？这个时候我们需要把已经解决的子问题组合起来，合并成我们需要的最终结果文件。这个时候该采用什么算法呢？这里考察候选人对外排序和归并排序算法的掌握程度，我们可以将100个排好序的文件进行两两归并排序，这样不断重复，我们就会得到50个排好序的文件，每个大小是2G。然后再两两归并，不断重复，直到最后两个文件归并成目标文件，这个文件就是100G并且是排好序的。因为是外排序+归并排序，每次只需要读取当前索引指向的文件记录到内存，进行比较，小的那个输出到目标文件，内存占用极少。另外，上面的算法是两路归并，也可以采用多路归并，甚至是采用堆排序进行优化，但是总体分治思路没有变化。<br>总体上这是一个非常好的面试题，除了考察候选人的分治思维之外，还考察对各种排序算法（快排，外排序，归并排序，堆排序）的理解，计算的时间空间复杂度估算，计算机的内外存特性和组织，文件操作等等。实际上能完全回答清楚这个问题的候选人极少，如果有幸被我面到一个，我会如获至宝，因为这个人有成长为优秀架构师的潜质。<br>另外，递归也是一种特殊的分治技术，掌握递归技术的开发人员，相当于掌握了一种强大的编程武器，可以解决一些一般开发人员无法解决的问题。比方说最近我的团队在研发一款新的服务框架，其中包括契约解析器(parser)，代码生产器(code generator)，序列化器(serializer)等组件，里头大量需要用到递归的思维和技术，没有这个思维的开发人员就干不了这个事情。所以我在面试候选人的时候，一般都会出递归相关的编程题，考察候选人的递归思维。  </p><h4 id="演化思维"><a href="#演化思维" class="headerlink" title="演化思维"></a>演化思维</h4><p>设计开发之初，无法对全局业务进行掌握，并且随着业务量的增加和业务的变更，设计架构需要根据业务需求不断演化。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构的本质是管理复杂性，&lt;strong&gt;抽象&lt;/strong&gt;、&lt;strong&gt;分层&lt;/strong&gt;、&lt;strong&gt;分治&lt;/strong&gt; 和 &lt;strong&gt;演化&lt;/strong&gt; 思维是我们工程师/架构师应对和管理复杂性的四种最基本武器。&lt;a href=&quot;http://www.infoq.com/cn/articles/architecture-thought?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;原文地址&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="架构" scheme="http://abumaster.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="思维" scheme="http://abumaster.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>去看墙外的世界</title>
    <link href="http://abumaster.com/2018/05/08/%E5%8E%BB%E7%9C%8B%E5%A2%99%E5%A4%96%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://abumaster.com/2018/05/08/去看墙外的世界/</id>
    <published>2018-05-08T06:33:45.000Z</published>
    <updated>2018-05-30T11:57:36.124Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间使用非常方便的Chrome翻墙插件 <strong>快速安全通道</strong> 不再可以免费使用，VIP价格挺高的，决定使用国外vps作为代理搭建翻墙服务器，折腾。  </p><a id="more"></a><p><strong>使用工具：</strong>  </p><ul><li>搬瓦工 VPS  </li><li><strong>Shadowsocks</strong> 服务端和客户端  </li><li><del><strong>Openvpn</strong> 服务端和客户端（这种方案体验过不是太好，全局代理，导致国内网站访问缓慢）</del>。</li></ul><p><strong>搬瓦工 VPS 购买攻略</strong><br><a href="http://banwagong.cn/">搬瓦工非官方中文网站</a> 提供了优惠的 VPS 购买，以及优惠券。可以在上面找到合适的服务器，一般作为代理服务器配置基本够用。我选用的是最便宜的一年需要 19.9$ ，打完折优惠了1刀。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-5-8/44022811.jpg" alt=""><br>按官网的步骤购买，支付完毕后，可以进入管理界面，界面非常清晰，只是终端命令输入太卡，故在Windows上使用 <em>putty</em> 可以远程连接到服务器。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-5-8/79363014.jpg" alt=""><br>默认安装的是Centos，可以自己根据需要安装Ubuntu或者其他发行版本。密码会通过注册的邮箱发过来，是一个随机生成的密码，貌似很安全，用户名为root。  </p><p><strong>安装代理服务</strong><br>搬瓦工默认提供了OpenVPN服务的安装选项，可以直接在线安装，安装完毕后，会默认生成一个用户的key，其中包含了生成的公钥和证书。同时也提供了Windows客户端的下载，下载安装后，将这个key解压到openvpn客户端的配置目录下，这是启动openvpn可以连接到远程的服务器上，本机所有的请求都通过代理服务器进行转发，隐藏了本机的IP地址。这种方法的缺点非常明显了，没被墙的网站还要先翻到墙外再翻回来，速度可想而知，另外毕竟不是无限流量。<em>不使用这种</em>。<br>另一种方式：<strong>Shadowsocks</strong>，其原理是将被墙的请求，伪装成普通的流量包，绕过 <strong><a href="https://zh.wikipedia.org/wiki/%E9%87%91%E7%9B%BE%E5%B7%A5%E7%A8%8B">GFW</a></strong> 的检测。  </p><p><strong>服务端的部署，安装：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line">apt-get install python-pip</span><br><span class="line">pip install shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure></p><p>首先优化Shadowsocks的性能，创建一个 <code>/etc/sysctl.d/local.conf</code> 文件，输入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># max open files</span><br><span class="line">fs.file-max = 1024000</span><br><span class="line"># max read buffer</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"># max write buffer</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"># default read buffer</span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"># default write buffer</span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"># max processor input queue</span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"># max backlog</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"># resist SYN flood attacks</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"># reuse timewait sockets when safe</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"># turn off fast timewait sockets recycling</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"># short FIN timeout</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"># short keepalive time</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"># outbound port range</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"># max SYN backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"># max timewait sockets held by system simultaneously</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"># TCP receive buffer</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"># TCP write buffer</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"># turn on path MTU discovery</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line"># for high-latency network</span><br><span class="line">net.ipv4.tcp_congestion_control = hybla</span><br><span class="line"># forward ivp4</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure></p><p>然后，创建一个Shadowsocks的配置文件，是一个json文件，<code>/etc/shadowsocks.json</code>，内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"my_server_ip",  #填入你的IP地址</span><br><span class="line">    "local_address": "127.0.0.1",</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "port_password": &#123;</span><br><span class="line">        "8381": "foobar1",    #端口号，密码</span><br><span class="line">        "8382": "foobar2",</span><br><span class="line">        "8383": "foobar3",</span><br><span class="line">        "8384": "foobar4"</span><br><span class="line">    &#125;,</span><br><span class="line">    # 单用户配置 "server_port" "password"</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast_open": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个多用户的配置文件，一个端口配置一个密码。<br>启动Shadowsocks服务：  </p><ul><li>前端启动，<code>ssserver -c /etc/shadowsocks.json</code> ;</li><li>后端启动，<code>ssserver -c /etc/shadowsocks.json -d start</code> ；</li><li>停止，<code>ssserver -c /etc/shadowsocks.json -d stop</code> ;</li><li>重启，<code>ssserver -c /etc/shadowsocks.json -d restart</code> .</li></ul><p>设置为开机启动：<br>编辑 <code>/etc/rc.local</code> 文件，在其中加上 <code>ssserver -c /etc/shadowsocks.json -d start</code> ，保存退出。<br><strong>客户端的配置：</strong><br>下载<a href="https://github.com/shadowsocks/shadowsocks-windows/releases">Shadowsocks客户端</a>。打开文件，然后编辑服务器。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-5-8/46616172.jpg" alt=""><br>为服务器端配置的ip和端口号以及密码信息。然后右键，选择启动代理，代理模式选择PAC模式，PAC文件可以选择从GFWList更新到本地PAC文件。这样PAC中的网站走代理，其他网站走本地ip。速度很快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间使用非常方便的Chrome翻墙插件 &lt;strong&gt;快速安全通道&lt;/strong&gt; 不再可以免费使用，VIP价格挺高的，决定使用国外vps作为代理搭建翻墙服务器，折腾。  &lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://abumaster.com/categories/life/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="Shadowsocks" scheme="http://abumaster.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简介</title>
    <link href="http://abumaster.com/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>http://abumaster.com/2018/04/24/设计模式简介/</id>
    <published>2018-04-24T02:34:40.000Z</published>
    <updated>2018-04-25T06:49:36.358Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计模式</strong>（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。阅读开源书籍<a href="https://github.com/me115/design_patterns">图说设计模式</a>的总结。</p><a id="more"></a><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><strong>适用场景：</strong><br>一个工厂Factory中生产不同种类的产品ProductA和ProductB，然后他们继承一个抽象基类，使用这些产品时，通过工厂提供的一个接口，根据参数返回对应的产品对象，而隔离具体的产品。<br>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。<br><strong>模式结构：</strong><br>简单工厂模式包含以下角色  </p><ul><li>Factory： 工厂角色<br>负责创建内部所有实例的逻辑  </li><li>Product： 抽象产品角色<br>抽象基类，负责所有具体类的公共接口和描述  </li><li>ConcreteProduct： 具体产品角色<br>具体的产品子类  </li></ul><p><strong>实例</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">class</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Product()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"abstract product construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数 接口</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Product()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"abstract product deconstruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 产品A</span></span><br><span class="line"><span class="keyword">class</span> ProductA :<span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProductA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品A的构造函数\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Product A ...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ProductA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品B的析构函数\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 产品B</span></span><br><span class="line"><span class="keyword">class</span> ProductB :<span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProductB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品B的构造函数\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ProductB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品B的析构函数\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是产品B\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 工厂</span></span><br><span class="line"><span class="keyword">class</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">creatProduct</span><span class="params">(<span class="built_in">string</span> productname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (productname == <span class="string">"A"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (productname == <span class="string">"B"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用于测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MY_TEST</span><span class="params">(<span class="built_in">string</span> name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory factory;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------TEST product = "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Product * product = factory.creatProduct(name);</span><br><span class="line">    <span class="keyword">if</span> (product == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no the product\n"</span>; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------END TEST PASS ---------\n"</span>;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        product-&gt;print();</span><br><span class="line">    <span class="keyword">delete</span> product;</span><br><span class="line">    product = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------END TEST PASS ---------\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MY_TEST(<span class="string">"A"</span>);</span><br><span class="line">    MY_TEST(<span class="string">"B"</span>);</span><br><span class="line">    MY_TEST(<span class="string">"err"</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><em>具体的产品由具体的工厂生产，而不是一个工厂生产多样产品。</em><br>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。<br>是对简单工厂模式的一种改进，所有的产品不再由单一的工厂创建，而是从一个抽象工厂中继承生产某一产品的工厂，增加新的产品的时候不用修改工厂角色，只需要从抽象工厂中派生一个具体的工厂子类。<br><strong>适用情况：</strong>   </p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。  </li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。  </li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。  </li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt="">  </p><ul><li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。  </li><li>抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。  </li><li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。  </li><li>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。  </li><li>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。  </li></ul><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>建造者模式（Builder Pattern）</strong> 将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。一步一步创建一个复杂对象，允许用户只通过指定复杂对象的类型和内容就可以创建他们，不需要知道内部具体的创建细节。属于对象创建型模式。  </p><p><strong>优点：</strong>  </p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。  </li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。  </li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。  </li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。  </li></ul><p><strong>缺点：</strong>  </p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。  </li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。  </li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>系统运行过程中保持一个实例是非常重要的，比如日志记录。单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。<br>单利模式保证某一个类只有一个实例，并且这个实例是自行创建的，并且向整个系统提供这个实例。  </p><ul><li>单例类的构造函数私有  </li><li>提供一个自身的静态私有成员变量  </li><li>提供一个公有的静态工厂方法  </li></ul><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;设计模式&lt;/strong&gt;（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。阅读开源书籍&lt;a href=&quot;https://github.com/me115/design_patterns&quot;&gt;图说设计模式&lt;/a&gt;的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="设计模式" scheme="http://abumaster.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Boost学习01</title>
    <link href="http://abumaster.com/2018/04/20/Boost%E5%AD%A6%E4%B9%A001/"/>
    <id>http://abumaster.com/2018/04/20/Boost学习01/</id>
    <published>2018-04-20T03:33:50.000Z</published>
    <updated>2018-04-25T08:51:38.274Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Boost.Asio的特性和使用。  </p><a id="more"></a><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>Boost.Asio 是使用 Proactor 设计模式实现的，设计模式如下图所示：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-20/77149905.jpg" alt="Proactor pattern"><br><strong>各个模块介绍：</strong>  </p><ul><li>Asynchronous Operation 异步操作<br>定义异步操作，比如在套接字上的异步读写  </li></ul><ul><li>Asynchronous Operation Processor 异步操作处理器<br>执行异步操作，并把操作完成的事件放入完成事件队列中</li><li>Completion Event Queue 完成事件队列<br>缓冲着完成事件队列，等待被异步事件分离器调用</li><li>Completion Hander 完成函数<br>用来处理异步操作返回的结果，是函数对象，回调函数</li><li>Asynchronous Event Demultiplexer 异步事件分离器<br>阻塞等待完成事件队列，并将完成事件返回给调用者</li><li>Proactor 前摄器<br>调用异步事件分离器</li><li>Initiator 初始化<br>开始异步操作，分发回调函数</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h4 id="基本技能"><a href="#基本技能" class="headerlink" title="基本技能"></a>基本技能</h4><p><strong>使用定时器观察同步和异步</strong><br>首先包含头文件 <code>boost/asio.hpp</code> ，然后定义一个核心IO操作对象 <code>boost::asio::io_context io;</code> 将一个定时器绑定到IO对象上 <code>boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));</code> 。同步io只需要调用 <code>t.wait()</code> 会等待5s的时间才执行下面的内容。如果是非同步io需要提供一个回调函数，不影响接下来行的执行，调用<code>t.async_wait(&amp;hander);</code> 异步执行回调函数，接下来等待函数的结束，接下来的行继续执行使用 <code>io.run()</code> 阻塞等待回调函数执行结束。  </p><p><strong>绑定参数</strong><br>为了使用asio实现重复定时器，需要更改回调函数定时器的到期时间，然后启动新的异步等待。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入定时器对象和控制结束的计数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">    boost::asio::steady_timer*t, <span class="keyword">int</span> *count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*count &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        ++(*count);</span><br><span class="line">        t-&gt;expires_at(t-&gt;expiry() + boost::asio::chrono::seconds(<span class="number">1</span>));<span class="comment">//定时器的到期时间往后推迟1s</span></span><br><span class="line">        t-&gt;async_wait(boost::bind(MyPrint, boost::asio::placeholders::error, t, count));<span class="comment">//重新开始一个异步等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context io;</span><br><span class="line">    boost::asio::steady_timer t(io, boost::asio::chrono::seconds(1));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    t.async_wait(boost::bind(MyPrint, boost::asio::placeholders::error, &amp;t, &amp;count));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"start...\n"</span>;</span><br><span class="line">    io.run();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final count is "</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用类的成员函数作为回调函数的句柄</strong><br>主函数更加简洁<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* 成员函数作为回调函数的句柄                                           */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类，用io对象构造</span></span><br><span class="line"><span class="keyword">class</span> printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数 初始化定时器，并且异步等待</span></span><br><span class="line">    printer(boost::asio::io_context&amp; io)</span><br><span class="line">        :m_timer(io,boost::asio::chrono::seconds(<span class="number">1</span>)),m_count(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_timer.async_wait(boost::bind(&amp;printer::myprint, <span class="keyword">this</span>));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"start sync wait...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~printer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Finaly the count is "</span> &lt;&lt; m_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员函数，用于更新定时器和重新绑定异步事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_count &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"now count is "</span> &lt;&lt; m_count++ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定时器的到期时间延长1s</span></span><br><span class="line">            m_timer.expires_at(m_timer.expiry() + boost::asio::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">//重置异步等待</span></span><br><span class="line">            m_timer.async_wait(boost::bind(&amp;printer::myprint, <span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::asio::steady_timer m_timer;</span><br><span class="line">    <span class="keyword">int</span> m_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context io;</span><br><span class="line">    <span class="function">printer <span class="title">p</span><span class="params">(io)</span></span>;<span class="comment">//用io对象构造一个打印对象</span></span><br><span class="line">    io.run();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>多线程环境下的同步处理</strong><br>使用 <code>io_context::strand</code> 类来同步多线程程序中的回调处理函数。如果处理需要很长的时间响应，或者考虑在多处理器上进行扩展，可以使用多线程，将处理函数同步化，共享访问。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类，不同进程共享一个类的对象，分别对一个对象进行操作</span></span><br><span class="line"><span class="keyword">class</span> printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    printer(boost::asio::io_context&amp; io)</span><br><span class="line">        : strand_(io),</span><br><span class="line">        timer1_(io, boost::asio::chrono::seconds(<span class="number">1</span>)),</span><br><span class="line">        timer2_(io, boost::asio::chrono::seconds(<span class="number">1</span>)),</span><br><span class="line">        count_(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//绑定到一个io_context::strand对象上，由此对象分发其中的函数句柄</span></span><br><span class="line">        <span class="comment">//保证了不会同时执行</span></span><br><span class="line">        timer1_.async_wait(boost::asio::bind_executor(strand_,</span><br><span class="line">            boost::bind(&amp;printer::print1, <span class="keyword">this</span>)));</span><br><span class="line"></span><br><span class="line">        timer2_.async_wait(boost::asio::bind_executor(strand_,</span><br><span class="line">            boost::bind(&amp;printer::print2, <span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    ~printer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final count is "</span> &lt;&lt; count_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count_ &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;boost::this_thread::get_id() &lt;&lt;<span class="string">" Timer 1: "</span> &lt;&lt; count_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ++count_;</span><br><span class="line"></span><br><span class="line">            timer1_.expires_at(timer1_.expiry() + boost::asio::chrono::seconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            timer1_.async_wait(boost::asio::bind_executor(strand_,</span><br><span class="line">                boost::bind(&amp;printer::print1, <span class="keyword">this</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count_ &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;boost::this_thread::get_id()&lt;&lt; <span class="string">" Timer 2: "</span> &lt;&lt; count_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ++count_;</span><br><span class="line"></span><br><span class="line">            timer2_.expires_at(timer2_.expiry() + boost::asio::chrono::seconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            timer2_.async_wait(boost::asio::bind_executor(strand_,</span><br><span class="line">                boost::bind(&amp;printer::print2, <span class="keyword">this</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::asio::io_context::strand strand_;</span><br><span class="line">    boost::asio::steady_timer timer1_;</span><br><span class="line">    boost::asio::steady_timer timer2_;</span><br><span class="line">    <span class="keyword">int</span> count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::asio::io_context io;</span><br><span class="line">    <span class="function">printer <span class="title">p</span><span class="params">(io)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main thread id :"</span> &lt;&lt; boost::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    boost::thread t(boost::bind(&amp;boost::asio::io_context::run, &amp;io));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"child thread id: "</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    io.run();</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>:system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Sockets-编程"><a href="#Sockets-编程" class="headerlink" title="Sockets 编程"></a>Sockets 编程</h4><h5 id="同步-TCP-服务器和客户端"><a href="#同步-TCP-服务器和客户端" class="headerlink" title="同步 TCP 服务器和客户端"></a>同步 TCP 服务器和客户端</h5><p>以 <strong>daytime</strong> 服务器为例，占据13端口，获取服务器当前时间，返回给客户端程序的服务。<br>使用 Boost.Asio TCP daytime server 的设计过程：<br>使用头文件和命名空间<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;       //包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;     <span class="comment">//使用tcp传输协议</span></span><br></pre></td></tr></table></figure></p><p>创建一个acceptor接收器，用于接收客户端的连接请求<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line">tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 13));</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用以下的初始化过程</span></span><br><span class="line">tcp::<span class="function">acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">tcp::endpoint endpoint(tcp::v4(),13);</span><br><span class="line">acceptor.open(endpoint.protocol());</span><br><span class="line">acceptor.set_option(tcp::acceptor::reuse_address(<span class="literal">true</span>));</span><br><span class="line">acceptor.bind(endpoint);</span><br><span class="line">acceptor.listen();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出，创建的acceptor对象，相当于调用了标准套接字中的bind和listen</span></span><br></pre></td></tr></table></figure></p><p>接收连接请求并处理<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcp::<span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;             <span class="comment">//连接套接字</span></span><br><span class="line">acceptor.accept(socket);                    <span class="comment">//阻塞于此，等待客户端的连接</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> message = make_daytime_string();</span><br><span class="line">boost::system::error_code ignored_error;</span><br><span class="line">boost::asio::write(socket, boost::asio::buffer(message), ignored_error);</span><br></pre></td></tr></table></figure></p><p><strong>客户端程序</strong><br>连接服务器，获得连接套接字，然后从连接套接字中读取或写入信息。<br>使用 <code>tcp::resolver</code> 解析服务的端点信息 <code>endpoint</code> ，然后调用 <code>connect(socket,endpoint)</code> 与服务器建立连接，调用 <code>socket.read_some(...)</code> 读取一定长度的信息。  </p><h5 id="异步-TCP-服务器"><a href="#异步-TCP-服务器" class="headerlink" title="异步 TCP 服务器"></a>异步 TCP 服务器</h5><p><strong>首先</strong>，创建一个服务器对象，用于接收来自客户端的连接请求，为构造函数提供一个 <code>io_context</code> 对象，用于提供IO服务，然后运行 <code>io_context.run()</code> 代表你执行异步io操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"><span class="function">tcp_server <span class="title">server</span><span class="params">(io_context)</span></span>;</span><br><span class="line">io_context.run();</span><br></pre></td></tr></table></figure></p><p><strong><code>tcp_server</code></strong>类，构造函数使它在13端口开始监听连接的到来：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcp_server(boost::asio::io_context&amp; io_context)</span><br><span class="line">    : acceptor_(io_context, tcp::endpoint(tcp::v4(), <span class="number">13</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    start_accept();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>start_accept()函数用于创建一个套接字，并且异步等待接收一个连接<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tcp_connection::pointer new_connection =</span><br><span class="line">      tcp_connection::create(acceptor_.get_executor().context());</span><br><span class="line"></span><br><span class="line">    acceptor_.async_accept(new_connection-&gt;socket(),</span><br><span class="line">        boost::bind(&amp;tcp_server::handle_accept, <span class="keyword">this</span>, new_connection,</span><br><span class="line">          boost::asio::placeholders::error));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(tcp_connection::pointer new_connection,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> boost::system::error_code&amp; error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">    &#123;</span><br><span class="line">      new_connection-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是tcp连接类，获取连接的套接字，并向连接套接字中写入信息。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> tcp_connection</span><br><span class="line">  : <span class="keyword">public</span> boost::enable_shared_from_this&lt;tcp_connection&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;tcp_connection&gt; pointer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> pointer <span class="title">create</span><span class="params">(boost::asio::io_context&amp; io_context)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pointer(<span class="keyword">new</span> tcp_connection(io_context));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tcp::<span class="function">socket&amp; <span class="title">socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> socket_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    message_ = make_daytime_string();</span><br><span class="line"></span><br><span class="line">    boost::asio::async_write(socket_, boost::asio::buffer(message_),</span><br><span class="line">        boost::bind(&amp;tcp_connection::handle_write, shared_from_this(),</span><br><span class="line">          boost::asio::placeholders::error,</span><br><span class="line">          boost::asio::placeholders::bytes_transferred));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tcp_connection(boost::asio::io_context&amp; io_context)</span><br><span class="line">    : socket_(io_context)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_write</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; <span class="comment">/*error*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">size_t</span> <span class="comment">/*bytes_transferred*/</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  tcp::socket socket_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> message_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Boost.Asio的特性和使用。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Boost" scheme="http://abumaster.com/tags/Boost/"/>
    
      <category term="Asio" scheme="http://abumaster.com/tags/Asio/"/>
    
  </entry>
  
  <entry>
    <title>深刻理解Reactor和Proactor</title>
    <link href="http://abumaster.com/2018/04/19/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3Reactor%E5%92%8CProactor/"/>
    <id>http://abumaster.com/2018/04/19/深刻理解Reactor和Proactor/</id>
    <published>2018-04-19T09:07:28.000Z</published>
    <updated>2018-04-20T03:26:44.859Z</updated>
    
    <content type="html"><![CDATA[<p>对两种 I/O 多路复用的模式 Reactor 和 Proactor 进行介绍。</p><a id="more"></a><p><a href="http://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html">参考链接1</a><br><a href="https://www.zhihu.com/question/26943938">参考链接2</a>  </p><p>I/O 多路复用是为了应对高并发情况下对于客户端连接服务器请求时出现的一种技术，不用为每个连接开一个线程或者进程监听连接套接字读写数据，而是使用单个进程监听所有的套接字，当可以读写时通知开始进行 I/O 操作。多路复用机制通常依赖一个 <strong>事件多路分离器（Event Demultiplexer）</strong> ，将来自事件源的 I/O 事件分离出来，并分发到对应的 read/write 事件处理器（Event Handler）上。开发人员需要注册需要处理的事件及其回调函数，事件分离器负责将事件分发到对应的回调函数上，与事件分离器相关的模式是 <strong>Reactor</strong> 采用同步IO， <strong>Proactor</strong>采用的是异步IO。  </p><p><em>Reactor</em> 模式，事件分离器等待文件描述符或套接字读写就绪，然后将事件分发给对应的事件处理器（回调函数），然后由回调函数进行读写操作。<br><em>Proactor</em> 模式，事件分离器捕获IO操作完成事件，然后传递给对应的事件处理器。  </p><p>两种模式下的读操作过程：<br><strong>Reactor 模式实现读：</strong>  </p><ul><li>注册读就绪事件和对应的事件处理器  </li><li>事件分离器等待事件  </li><li>事件到来，激活分离器，分离器将事件分发到对应的事件处理器上  </li><li>事件处理器完成实际的读操作，处理读到的数据，注册新事件，返还控制权</li></ul><p><strong>Proactor 模式实现读：</strong>  </p><ul><li>处理器发起异步读操作（OS支持），处理器无视IO就绪状态，只关注完成事件  </li><li>事件分离器等待 <em>操作完成事件</em>  </li><li>在分离器等待过程中，操作系统 <em>利用并行的内核线程执行实际的读操作</em>，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成  </li><li>事件分离器呼唤事件处理器  </li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器  </li></ul><p>两者之间一个重要的不同点就是：前者发起回调函数时表示IO可以操作，后者发起回调时表示IO已经完成了。Reactor框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要向一个SOCKET写数据，那么当该SOCKET可以接收数据的时候，你的操作就会被调用；而Proactor框架中用户定义的操作是在实际操作之后调用的。比如你定义了一个操作要显示从SOCKET中读入的数据，那么当读操作完成以后，你的操作才会被调用。一个异步IO，一个是同步IO。  </p><p>使用 Reactor 的库和应用有：<br>libev、libevent、libuv、Nginx…<br>使用 Proactor 的库和应用有：<br>Booost.Asio、IOCP、ACE…  </p><p><a href="https://www.zhihu.com/question/26393784">关于异步和同步</a><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-20/55538714.jpg" alt=""><br>图片来自知乎</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对两种 I/O 多路复用的模式 Reactor 和 Proactor 进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="设计模式" scheme="http://abumaster.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>vcpkg：vc++ 的包管理器</title>
    <link href="http://abumaster.com/2018/04/15/vcpkg%EF%BC%9Avc-%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://abumaster.com/2018/04/15/vcpkg：vc-的包管理器/</id>
    <published>2018-04-15T07:22:32.000Z</published>
    <updated>2018-04-16T06:49:39.890Z</updated>
    
    <content type="html"><![CDATA[<p><a href=""><strong>vcpkg</strong></a> 是一个Windows下vc++的第三方库管理工具，提供了第三方库的快速安装和配置，为Windows下C++开发提供了一种有效的工具。  </p><a id="more"></a><p><strong>vcpkg</strong> 可以在Windows上安装C、C++第三方的库。通常Windows下使用第三方库时，没有在Linux下使用方便，需要自己下源码编译，并在项目中加入库和头文件的目录，十分麻烦，并且vc++的版本不同也可能出现库的不兼容问题，而vcpkg可以很好的解决这个问题。可以使用简单的几条命令安装第三方库，使用时只需要包含头文件，不再需要配置头文件目录和链接库的目录。  </p><hr><p><strong>安装需求：</strong>  </p><ul><li>Windows 10,8 或 7；  </li><li>vs2017或vs2015 update3；  </li><li>Git 2.10.x 以上；  </li><li>Cmake 3.10 以上。  </li></ul><hr><p><strong>简单使用：</strong><br><strong>1.安装</strong><br>从Microsoft的Github仓库找到vcpkg的仓库，clone到本地<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Microsoft/vcpkg.git</span><br></pre></td></tr></table></figure></p><p>进入根目录下运行一下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\bootstrap-vcpkg.bat       #生成vcpkg.exe</span><br><span class="line">.\vcpkg integrate install   #连接到用户集成中</span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-15/8337753.jpg" alt=""><br>然后，安装的库直接可以在自己的项目中使用，只需要包含头文件。  </p><p><strong>2.安装第三方库</strong><br>常用的几个命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vcpkg list                  <span class="comment"># 列出安装的第三方库</span></span><br><span class="line">vcpkg search xxxlib         <span class="comment"># 查找可以安装的库</span></span><br><span class="line">vcpkg install xxxlib        <span class="comment"># 安装xxxlib库</span></span><br></pre></td></tr></table></figure></p><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-15/11870040.jpg" alt=""><br>安装完第三方库后，可以加入头文件，直接编译使用，不再需要繁琐的目录配置。<br><strong>注意</strong>：安装第三方库的时候，可能会出现库的编译错误<code>BUILD_FAILD</code>，可能是因为没有安装英文版本的VS语言包，安装过后问题解决。</p><p><strong>3.高级应用</strong><br><a href="https://github.com/Microsoft/vcpkg/blob/master/docs/examples/packaging-zlib.md">打包第三方库</a>，当无法搜到需要的库的时候，可以自己通过源码打包，配置，然后安装到本地。暂时没用到，用到时详细参考文档。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;&quot;&gt;&lt;strong&gt;vcpkg&lt;/strong&gt;&lt;/a&gt; 是一个Windows下vc++的第三方库管理工具，提供了第三方库的快速安装和配置，为Windows下C++开发提供了一种有效的工具。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="包管理" scheme="http://abumaster.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的使用</title>
    <link href="http://abumaster.com/2018/04/13/mongoDB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2018/04/13/mongoDB的使用/</id>
    <published>2018-04-13T06:25:47.000Z</published>
    <updated>2018-04-13T08:06:26.854Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是一种非关系数据库，是一种 NoSQL 型数据库，用于应对大数据和分布式系统的数据库，具有高扩展性和分布式，没有复杂的关系模型。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><a id="more"></a><h3 id="MongoDB-简介和安装"><a href="#MongoDB-简介和安装" class="headerlink" title="MongoDB 简介和安装"></a>MongoDB 简介和安装</h3><p>MongoDB 是一种<a href="http://www.runoob.com/mongodb/nosql.html">NoSQL</a>型数据库，使用C++编写，基于分布式文件存储的开源数据库系统。<br><a href="https://www.mongodb.com/download-center#community">官方下载地址</a>。<br>在 Windows 系统环境下，可以下载安装包或者压缩包，解压后在 <code>bin</code> 目录下找到可执行的文件，其中 <code>mongod.exe</code> 是数据库服务，使用时需要打开，<code>mongo.exe</code> 是MongoDB数据库的控制台，命令终端。另外，该目录下还提供了数据库的状态查看和管理小程序。  </p><h4 id="MongoDB-服务器的运行"><a href="#MongoDB-服务器的运行" class="headerlink" title="MongoDB 服务器的运行"></a>MongoDB 服务器的运行</h4><p><strong>有两种方式运行：<em>命令行</em> 和 <em>配置服务</em> </strong><br>第一种方法是从终端运行 MongoDB 服务器，需要指定数据库的存储路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod.exe --dbpath mydbpath\db</span><br></pre></td></tr></table></figure></p><p>第二种方法是编写Windows下的服务程序，使MongoDB服务器以服务的形式存在，创建一个 <code>mongodd.cfg</code> 文件，在其中指定日志路径和数据库路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: D:\Program Files (x86)\mongodb-win32-x86_64\bin\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: D:\Program Files (x86)\mongodb-win32-x86_64\bin\db</span><br></pre></td></tr></table></figure></p><p>然后以管理员的身份运行：<code>mongod.exe --config &quot;path\mongod.cfg&quot; --install</code> 安装服务，这时可以在Windows服务中看到一个名为MongoDB的服务，可以手动启动或者使用命令启动和关闭：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net start MongoDB   <span class="comment"># 启动服务</span></span><br><span class="line">net stop MongoDB    <span class="comment"># 关闭服务</span></span><br><span class="line">mongod.exe --remove <span class="comment"># 移除服务</span></span><br></pre></td></tr></table></figure></p><h4 id="连接-MongoDB-服务器"><a href="#连接-MongoDB-服务器" class="headerlink" title="连接 MongoDB 服务器"></a>连接 MongoDB 服务器</h4><p>使用 <code>mongo</code> 命令进入 MongoDB 后台管理的shell，默认连接到其中的test数据库，可以使用一些简单的JavaScript语句。  </p><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="创建和删除数据库"><a href="#创建和删除数据库" class="headerlink" title="创建和删除数据库"></a>创建和删除数据库</h4><p>查看所有包含数据的数据库： <code>show dbs</code><br>查看当前使用的数据库： <code>db</code><br>切换和创建数据库 <code>use DB_NAME</code> 不存在会创建需要删除某一个数据库，可以先切换到某一个数据库下，然后执行 <code>db.dropDatabase()</code> </p><h4 id="创建和删除集合"><a href="#创建和删除集合" class="headerlink" title="创建和删除集合"></a>创建和删除集合</h4><p>创建的基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(name, options)</span><br></pre></td></tr></table></figure></p><p>name 为名称，options为选项用来指定集合的大小和文档的最大数量。<br>删除集合 <code>db.collection.drop()</code> ，删除前使用 <code>show collections</code> 或者 <code>show tables</code> 查看集合，然后调用具体的集合删除。  </p><h4 id="文档的操作"><a href="#文档的操作" class="headerlink" title="文档的操作"></a>文档的操作</h4><p><strong>插入文档的基本操作</strong>，文档相当于一个json数据结构的文件。插入的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure></p><p>其中要指定插入到的集合，document是一个json格式如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line">        <span class="attr">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line">        <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>,</span><br><span class="line">        <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">        <span class="attr">"tags"</span> : [</span><br><span class="line">                <span class="string">"mongodb"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"likes"</span> : <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>db.col.find()</code> 可以查找插入的文档。  </p><p><strong>更新文档</strong> 通过 <code>update</code> 语句，基本语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,     # 类似SQL中where后面的 找到要更改的记录</span><br><span class="line">   &lt;update&gt;,    # set后面的内容 更改的内容</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;, #没有修改记录是否插入新的</span><br><span class="line">     multi: &lt;boolean&gt;, # 插入多条记录</span><br><span class="line">     writeConcern: &lt;document&gt; #抛出异常级别</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>通过 <code>save()</code> 方法，可以通过传入一个文档替换现有的文档。</p><p><strong>删除文档</strong> 通过 <code>remove</code> 来删除，基本语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>使用更新的方法 <code>deleteOne()</code> 和 <code>deleteMany()</code> 方法删除文档：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection.deleteMany(&#123;&#125;)  <span class="comment"># 删除所有的文档</span></span><br><span class="line">db.collection.deleteMany(&#123;status:<span class="string">"A"</span>&#125;) <span class="comment"># 删除所有status为A的文档</span></span><br><span class="line">db.collection.deleteOne(&#123;status:<span class="string">"A"</span>&#125;)  <span class="comment"># 删除一条</span></span><br></pre></td></tr></table></figure></p><p><strong>查询文档</strong> 简单的查询方式一种非结构化和一种结构化的输出方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br><span class="line">db.collection.find(query, projection).pretty()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 是一种非关系数据库，是一种 NoSQL 型数据库，用于应对大数据和分布式系统的数据库，具有高扩展性和分布式，没有复杂的关系模型。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://abumaster.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="NoSql" scheme="http://abumaster.com/tags/NoSql/"/>
    
      <category term="MongoDB" scheme="http://abumaster.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-4</title>
    <link href="http://abumaster.com/2018/04/08/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-4/"/>
    <id>http://abumaster.com/2018/04/08/高效使用STL-4/</id>
    <published>2018-04-08T07:07:38.000Z</published>
    <updated>2018-04-12T13:20:41.172Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，使用STL编程。</p></div><a id="more"></a><h4 id="条款43：尽量用算法取代循环"><a href="#条款43：尽量用算法取代循环" class="headerlink" title="条款43：尽量用算法取代循环"></a>条款43：尽量用算法取代循环</h4><p>每个算法至少接收一组迭代器来表示容器的区间，如查找最大最小值，查找满足某一条件的元素，这时用内置的一些算法可以解决，不需要手写一些循环，效率更高，即使在算法的内部遍历也是由循环来搞定的。优点包括：  </p><ul><li><strong>效率</strong>：通常算法比循环更高效；  </li><li><strong>正确性</strong>：写循环更容易出错，且代码较算法来的复杂；  </li><li><strong>可维护性</strong>：算法代码简洁，便于维护。  </li></ul><h4 id="条款44：尽量使用成员函数替代同名算法"><a href="#条款44：尽量使用成员函数替代同名算法" class="headerlink" title="条款44：尽量使用成员函数替代同名算法"></a>条款44：尽量使用成员函数替代同名算法</h4><p>出于效率考虑，可以使用容器的成员函数替代同名的算法，成员函数的速度相对较快。  </p><h4 id="条款45：注意-count、find、binary-search、lower-bound、upper-bound和equal-range-的区别"><a href="#条款45：注意-count、find、binary-search、lower-bound、upper-bound和equal-range-的区别" class="headerlink" title="条款45：注意 count、find、binary_search、lower_bound、upper_bound和equal_range 的区别"></a>条款45：注意 <code>count、find、binary_search、lower_bound、upper_bound和equal_range</code> 的区别</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-12/37444869.jpg" alt="">  </p><h4 id="条款46：考虑使用函数对象代替函数作算法的参数"><a href="#条款46：考虑使用函数对象代替函数作算法的参数" class="headerlink" title="条款46：考虑使用函数对象代替函数作算法的参数"></a>条款46：考虑使用函数对象代替函数作算法的参数</h4><p>将函数对象传递给STL算法的效率比传递真的函数高。如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对容器中数据进行降序排序</span></span><br><span class="line"><span class="comment">//1.使用函数对象greater</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">double</span>&gt;());</span><br><span class="line"><span class="comment">//2.使用函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">doubleGreater</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dl &gt; d2;</span><br><span class="line">&#125;</span><br><span class="line">sort(v.begin(), v.end(), doubleGreater);</span><br></pre></td></tr></table></figure></p><p>函数作为参数实际上是传递的函数指针，在每一次调用的时候编译器产生一个间接函数调用，通过指针调用。  </p><h4 id="条款47：避免产生只写代码"><a href="#条款47：避免产生只写代码" class="headerlink" title="条款47：避免产生只写代码"></a>条款47：避免产生只写代码</h4><p>灵感的乍现，让写代码变得容易，但是后期很难从代码中领会其真正所要表达的意思，称之为只写代码。<br>原书中说道：  </p><blockquote><p>代码的读比写更经常，这是软件工程的真理。也就是说软件的维护比开发花费多得多的时间。不能读和理解的软件不能被维护，不能维护的软件几乎没有不值得拥有。你用STL越多，你会感到它越来越舒适，而且你会越来越多的使用嵌套函数调用和即时（on the fly）建立函数对象。这没有什么错的，但永远记住你今天写的代码会被某个人——也可能是你——在未来的某一天读到。为那天做准备吧。</p></blockquote><h4 id="条款48：总是-include适当的头文件"><a href="#条款48：总是-include适当的头文件" class="headerlink" title="条款48：总是#include适当的头文件"></a>条款48：总是<code>#include</code>适当的头文件</h4><p>包含正确的头文件，谨记以下几条：  </p><ul><li>几乎所有的容器都在其同名的头文件中；  </li><li>算法常在 <code>algorithm</code> 头文件中，除了 <code>accumulate inner_product、adjacent_difference和partial_sum</code> 在 <code>numeric</code>；  </li><li>特殊的迭代器在 <code>iterator</code> 中，流迭代器和缓冲迭代器；  </li><li>标准仿函数和仿函数适配器在 <code>functional</code> 头文件中。  </li></ul><h4 id="条款49：学习破解有关STL的编译器诊断信息"><a href="#条款49：学习破解有关STL的编译器诊断信息" class="headerlink" title="条款49：学习破解有关STL的编译器诊断信息"></a>条款49：学习破解有关STL的编译器诊断信息</h4><h4 id="条款50：不断学习"><a href="#条款50：不断学习" class="headerlink" title="条款50：不断学习"></a>条款50：不断学习</h4><p>善于利用网络资源：  </p><ul><li>SGI STL网站: <a href="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>   </li><li>STLport网站， <a href="http://www.stlport.org/">http://www.stlport.org/</a>   </li><li>Boost网站， <a href="http://www.boost.org/">http://www.boost.org/</a>  或者 <a href="http://boost.sourceforge.net/">http://boost.sourceforge.net/</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，使用STL编程。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-3</title>
    <link href="http://abumaster.com/2018/04/08/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-3/"/>
    <id>http://abumaster.com/2018/04/08/高效使用STL-3/</id>
    <published>2018-04-08T07:07:12.000Z</published>
    <updated>2018-04-11T12:15:48.657Z</updated>
    
    <content type="html"><![CDATA[<div class="note success"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第五章算法和第六章仿函数的介绍。</p></div><a id="more"></a><h4 id="条款30：确保目标空间足够大"><a href="#条款30：确保目标空间足够大" class="headerlink" title="条款30：确保目标空间足够大"></a>条款30：确保目标空间足够大</h4><p>使用算法插入时插入的是不存在的空即迭代器的尾部，编译出错。  </p><h4 id="条款31：排序选择"><a href="#条款31：排序选择" class="headerlink" title="条款31：排序选择"></a>条款31：排序选择</h4><p>根据实际的需求选择合适的排序算法：  </p><ul><li>如果你需要在vector、string、deque或数组上进行完全排序，你可以使用 <code>sort</code> 或 <code>stable_sort</code>。  </li><li>如果你有一个vector、string、deque或数组，你只需要排序前n个元素，应该用 <code>partial_sort</code>。  </li><li>如果你有一个vector、string、deque或数组，你需要鉴别出第n个元素或你需要鉴别出最前的n个元素，而不用知道它们的顺序，<code>nth_element</code>是你应该注意和调用的。  </li><li>如果你需要把标准序列容器的元素或数组分隔为满足和不满足某个标准，你大概就要找 <code>partition</code> 或 <code>stable_partition</code>。  </li><li>如果你的数据是在list中，你可以直接使用 <code>partition</code> 和 <code>stable_partition</code>，你可以使用list的 <code>sort</code>来代替 <code>sort</code> 和<code>stable_sort</code>。   </li><li>如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务，但正如我在上面勾画的，会有很多选择。  </li></ul><h4 id="条款32：如果真要删除东西，在remove-后加上-erase"><a href="#条款32：如果真要删除东西，在remove-后加上-erase" class="headerlink" title="条款32：如果真要删除东西，在remove 后加上 erase"></a>条款32：如果真要删除东西，在<code>remove</code> 后加上 <code>erase</code></h4><p>STL 算法 <code>remove</code> 不是真正意义上的删除元素，而是遇见一个满足条件的元素，然后将其后的元素向前移动，元素的个数是不变的。而想真正删除，需要使用 <code>erase</code> 函数，将指定迭代器的元素删除。  </p><h4 id="条款33：避免在指针容器上使用-remove"><a href="#条款33：避免在指针容器上使用-remove" class="headerlink" title="条款33：避免在指针容器上使用 remove"></a>条款33：避免在指针容器上使用 <code>remove</code></h4><p>如上条款一样，这个算法不是真正意义上的删除，而是将元素向前移动，在指针容器上使用，可能会导致内存的泄漏。  </p><h4 id="条款34：注意哪个算法需要使用有序空间"><a href="#条款34：注意哪个算法需要使用有序空间" class="headerlink" title="条款34：注意哪个算法需要使用有序空间"></a>条款34：注意哪个算法需要使用有序空间</h4><h4 id="条款35：使用-mismatch-和-lexicographical-compare-实现简单的忽略大小写字符串比较"><a href="#条款35：使用-mismatch-和-lexicographical-compare-实现简单的忽略大小写字符串比较" class="headerlink" title="条款35：使用 mismatch 和 lexicographical_compare 实现简单的忽略大小写字符串比较"></a>条款35：使用 <code>mismatch</code> 和 <code>lexicographical_compare</code> 实现简单的忽略大小写字符串比较</h4><h4 id="条款36：了解-copy-if-的正确实现"><a href="#条款36：了解-copy-if-的正确实现" class="headerlink" title="条款36：了解 copy_if 的正确实现"></a>条款36：了解 <code>copy_if</code> 的正确实现</h4><h4 id="条款37：统计区间"><a href="#条款37：统计区间" class="headerlink" title="条款37：统计区间"></a>条款37：统计区间</h4><p>STL中提供了一些用于统计的算法，如 <code>count</code> 用来统计具有某一值的元素的个数，<code>count_if</code> 用于统计满足某一判别式的元素个数，区间中的最大最小值可以使用 <code>max_element</code> 和 <code>min_element</code> 得到。如果需要对某一区间中的元素定制更加复杂的操作，比如容器中元素求和，乘积和平均，可以使用 <code>accumulate</code> 和 <code>for_each</code> 定制仿函数，对容器进行操作。  </p><h4 id="条款38：把仿函数设计为用于值传递"><a href="#条款38：把仿函数设计为用于值传递" class="headerlink" title="条款38：把仿函数设计为用于值传递"></a>条款38：把仿函数设计为用于值传递</h4><p>在C和CPP中不允许将函数作为参数传递给函数，需要传递一个函数指针作为参数。如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///最后一个参数是一个函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line">            int (*cmpfcn)(const void*, const void*));</span><br></pre></td></tr></table></figure></p><h4 id="条款39：用纯函数做判断式"><a href="#条款39：用纯函数做判断式" class="headerlink" title="条款39：用纯函数做判断式"></a>条款39：用纯函数做判断式</h4><h4 id="条款40：使仿函数类可以适配"><a href="#条款40：使仿函数类可以适配" class="headerlink" title="条款40：使仿函数类可以适配"></a>条款40：使仿函数类可以适配</h4><h4 id="条款41：了解使用-ptr-fun-、mem-fun-的原因"><a href="#条款41：了解使用-ptr-fun-、mem-fun-的原因" class="headerlink" title="条款41：了解使用 ptr_fun 、mem_fun 的原因"></a>条款41：了解使用 <code>ptr_fun</code> 、<code>mem_fun</code> 的原因</h4><h4 id="条款42：确定-less-lt-T-gt-表示-operator-lt"><a href="#条款42：确定-less-lt-T-gt-表示-operator-lt" class="headerlink" title="条款42：确定 less&lt;T&gt; 表示 operator&lt;"></a>条款42：确定 <code>less&lt;T&gt;</code> 表示 <code>operator&lt;</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note success&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第五章算法和第六章仿函数的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-2</title>
    <link href="http://abumaster.com/2018/04/07/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-2/"/>
    <id>http://abumaster.com/2018/04/07/高效使用STL-2/</id>
    <published>2018-04-07T10:55:12.000Z</published>
    <updated>2018-04-10T06:40:02.434Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第二章 <code>vector</code> 和 <code>string</code> 和第三章的关联容器的介绍。</p></div><a id="more"></a><h4 id="条款13：使用-vector-和-string-替代动态分配的数组"><a href="#条款13：使用-vector-和-string-替代动态分配的数组" class="headerlink" title="条款13：使用 vector 和 string 替代动态分配的数组"></a>条款13：使用 <code>vector</code> 和 <code>string</code> 替代动态分配的数组</h4><p><strong>动态申请空间的弊端：</strong>  </p><ul><li>保证 <code>new</code> 和 <code>delete</code> 的成对出现，否则容易造成内存泄漏；  </li><li>保证 <code>delete</code> 的正确使用对象使用 <code>delete</code> ，而数组则要使用 <code>delete []</code> 形式；</li><li>保证 <code>delete</code> 只使用一次，以免发生错误。  </li></ul><p>因此，如果需要使用 <strong>动态分配数组</strong> 形式的数据结构可以考虑使用 <code>vector</code> 或者 <code>string</code> 容器，其有安全的内存管理机制，可以保证不会发生内存泄漏的问题。</p><h4 id="条款14：使用-reserve-来避免不必要的重新分配"><a href="#条款14：使用-reserve-来避免不必要的重新分配" class="headerlink" title="条款14：使用 reserve 来避免不必要的重新分配"></a>条款14：使用 <code>reserve</code> 来避免不必要的重新分配</h4><p>像 <code>vector</code> 这样的容器，其可以最大容纳元素的数量 <code>capacity()</code> 往往要大于当前大小 <code>size()</code> 这保证其不需要插入一个元素就要申请空间，更加高效。然而当我们频繁插入元素的时候，往往是大于所能够容纳的最大元素，这时需要重新分配空间，其步骤如下：  </p><ul><li>分配新的内存空间，一般是当前容量的倍数；   </li><li>将旧空间的元素拷贝到新的空间中；  </li><li>销毁旧空间上的对象；  </li><li>回收旧空间。<br>开销非常大，并且会让迭代器、指针和引用失效。这时为了避免这种不需要的代价，可以预估所需空间一次分配足够大的空间。<br>通常有两个成员函数可以使用：  </li><li><code>resize(size_type n)</code> 通常返回设置的新大小 <code>n</code> ，需要注意的是，这个函数将会在容器中构造新的元素，当 <code>n</code> 大于当前容器大小时，如果小于，则会将尾部的元素销毁，大于最大容量时，会发生重新分配；  </li><li><code>reserve(size_type n)</code> 函数通常设置容器的最大空间和大小为 <code>n</code> ，当 <code>n</code> 大于当前最大容量时才会发生内存的重新配置。<br>因此可以使用 <code>reserve</code> 函数来通过预估使用空间的大小申请足够大的空间，来避免频繁申请配置空间。  </li></ul><h4 id="条款15：小心-string-实现的多样性"><a href="#条款15：小心-string-实现的多样性" class="headerlink" title="条款15：小心 string 实现的多样性"></a>条款15：小心 <code>string</code> 实现的多样性</h4><p><code>string</code> 类型在各个平台下的实现是不同的，如果使用 <code>sizeof(string)</code> 来获得其大小会发现，它的大小为 1 或者 7 倍 <code>char *</code> 。</p><h4 id="条款16：如何将-vector-和-string-的数据传递遗留的-API"><a href="#条款16：如何将-vector-和-string-的数据传递遗留的-API" class="headerlink" title="条款16：如何将 vector 和 string 的数据传递遗留的 API"></a>条款16：如何将 <code>vector</code> 和 <code>string</code> 的数据传递遗留的 API</h4><p>对一些旧的API传递的参数是数组或者指针，当使用 <code>vector</code> 或者 <code>string</code> 作为参数传递时，要发生一定的转变。<br>通常，由于如 <code>vector</code> 容器那样，内存分布是连续的与普通的数组没有两样，可以用首元素的地址当做是数组名称，当然需对容器非空进行判断。一个技巧是，当使用 <code>C</code> 风格的API时，参数是数组的情况下，需要将数据传递给其他容器，可以使用 <code>vector</code> 作为中介，然后用它去初始化其他容器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 C API 中获得数据 传递到其他容器中</span></span><br><span class="line"><span class="keyword">size_t</span> fillArray(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize); <span class="comment">// C API</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd(maxNumDoubles);</span><br><span class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.size()));</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到deque</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; l(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到list</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; s(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其他容器中的数据传递到 C API 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pints, <span class="keyword">size_t</span> numInts)</span></span>; <span class="comment">// C API (同上)</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet; <span class="comment">// 保存要传递给API数据的set</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(intSet.begin(), intSet.end()); <span class="comment">// 拷贝set数据到vector</span></span><br><span class="line"><span class="keyword">if</span> (!v.empty()) doSomething(&amp;v[<span class="number">0</span>], v.size()); <span class="comment">// 传递数据到API</span></span><br></pre></td></tr></table></figure></p><h4 id="条款17：使用交换来修整过剩容量"><a href="#条款17：使用交换来修整过剩容量" class="headerlink" title="条款17：使用交换来修整过剩容量"></a>条款17：使用交换来修整过剩容量</h4><p>当使用容器时，插入数据可以使最大容量增加，但是当删除一部分元素时，多余的空间并不会自己归还给系统，需要手动收缩到合适的范围，一个做法是使用 <code>swap</code> 函数，构造一个与原始容器大小相同的临时容器，通过交换将元素填充到原始容器，互换而不会持有多余的空间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Contestant&gt;(contestants).swap(contestants);</span><br></pre></td></tr></table></figure></p><p>在 <code>C++11</code> 后提供了一个函数来调整过剩的空间大小，<code>shrink_to_fit()</code> 将多余的空间归还给系统。  </p><h4 id="条款18：避免使用-vector-lt-bool-gt"><a href="#条款18：避免使用-vector-lt-bool-gt" class="headerlink" title="条款18：避免使用 vector&lt;bool&gt;"></a>条款18：避免使用 <code>vector&lt;bool&gt;</code></h4><p>它不是一个 STL 容器，不保存 bool 类型。<code>vector&lt;bool&gt;</code> 不满足STL容器的必要条件，你最好不要使用它；而<code>deque&lt;bool&gt;</code> 和 <code>bitset</code> 是基本能满足你对 <code>vector&lt;bool&gt;</code> 提供的性能的需要的替代数据结构。  </p><h4 id="条款19：了解相等和等价的区别"><a href="#条款19：了解相等和等价的区别" class="headerlink" title="条款19：了解相等和等价的区别"></a>条款19：了解相等和等价的区别</h4><p>在标准的关联容器中，如<code>set</code>当插入新的元素时，是用等价判断的，而不是相等，通过自定义的比较函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!c.key_comp()(x, y) &amp;&amp; !c.key_comp()(y, x) <span class="comment">// 在c的排序顺序中</span></span><br><span class="line"><span class="comment">// 如果x在y之前它非真，</span></span><br><span class="line"><span class="comment">// 同时在c的排序顺序中</span></span><br><span class="line"><span class="comment">// 如果y在x之前它非真</span></span><br></pre></td></tr></table></figure></p><p>使用等价作为比较的标准，可以避免使用排序和相等两个比较函数造成的问题。  </p><h4 id="条款20：为指针的关联容器指定比较类型"><a href="#条款20：为指针的关联容器指定比较类型" class="headerlink" title="条款20：为指针的关联容器指定比较类型"></a>条款20：为指针的关联容器指定比较类型</h4><p>使用一个 <code>string*</code> 类型的 <code>set</code> 容器的时候，其比较类型默认为比较容器中指针的大小，如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp; <span class="comment">// ssp = “set of string ptrs”</span></span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Anteater"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Wombat"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Lemur"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Penguin"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用以下自定义函数来按字符串的值比较大小，而不是只比较指针的大小</span></span><br><span class="line"><span class="keyword">struct</span> StringPtrLess: </span><br><span class="line"><span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ps1 &lt; *ps2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="条款21：永远让比较函数对相等的值返回-false"><a href="#条款21：永远让比较函数对相等的值返回-false" class="headerlink" title="条款21：永远让比较函数对相等的值返回 false"></a>条款21：永远让比较函数对相等的值返回 false</h4><h4 id="条款22：避免原地修改-set-的键值"><a href="#条款22：避免原地修改-set-的键值" class="headerlink" title="条款22：避免原地修改 set 的键值"></a>条款22：避免原地修改 set 的键值</h4><p>set 容器需要保证元素的有序性，任何对于键值的修改都会改变这种有序性，简单来说不要改变容器中影响排序的键值。  </p><h4 id="条款23：考虑有序的-vector-替代关联容器"><a href="#条款23：考虑有序的-vector-替代关联容器" class="headerlink" title="条款23：考虑有序的 vector 替代关联容器"></a>条款23：考虑有序的 vector 替代关联容器</h4><h4 id="条款24：关乎效率的考虑"><a href="#条款24：关乎效率的考虑" class="headerlink" title="条款24：关乎效率的考虑"></a>条款24：关乎效率的考虑</h4><h4 id="条款25：熟悉非标准散列容器"><a href="#条款25：熟悉非标准散列容器" class="headerlink" title="条款25：熟悉非标准散列容器"></a>条款25：熟悉非标准散列容器</h4><h4 id="条款26：使用迭代器"><a href="#条款26：使用迭代器" class="headerlink" title="条款26：使用迭代器"></a>条款26：使用迭代器</h4><p>迭代器和常量迭代器之间的转换关系<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-10/12775061.jpg" alt=""><br>由图可以看出，迭代器可以隐式转换成常量迭代器，而常量迭代器却不可以转换成非常亮迭代器，一些容器的成员函数接收的是非常量迭代器，只能尽量使用非常量的迭代器。  </p><h4 id="条款27：常量迭代器转换成非常量迭代器"><a href="#条款27：常量迭代器转换成非常量迭代器" class="headerlink" title="条款27：常量迭代器转换成非常量迭代器"></a>条款27：常量迭代器转换成非常量迭代器</h4><p>使用 <code>distance</code> 和 <code>advance</code> 把 <code>const_iterator</code> 转换成 <code>iterator</code> 。为了在容器当前常量迭代器上插入一个元素，需要使其非常量化。通常的做法是，使用一个非常量的迭代器使其移动到常量迭代器的位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; IntDeque; <span class="comment">// 和以前一样</span></span><br><span class="line"><span class="keyword">typedef</span> IntDeque::iterator Iter;        <span class="comment">// 非常量迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> IntDeque::const_iterator ConstIter; <span class="comment">// 常量迭代器</span></span><br><span class="line">IntDeque d;</span><br><span class="line">ConstIter ci;</span><br><span class="line">... <span class="comment">// 让ci指向d</span></span><br><span class="line">Iter i(d.begin()); // 初始化i为d.begin()</span><br><span class="line">advance(i, distance(i, ci)); <span class="comment">// 把i移到指向ci位置</span></span><br><span class="line"><span class="comment">// （但请留意下面关于为什么</span></span><br><span class="line"><span class="comment">// 在它编译前要调整的原因）</span></span><br></pre></td></tr></table></figure></p><h4 id="条款28：-base-迭代器之间的转换"><a href="#条款28：-base-迭代器之间的转换" class="headerlink" title="条款28： base 迭代器之间的转换"></a>条款28： <code>base</code> 迭代器之间的转换</h4><p><code>base</code> 可以将 <code>reverse_iterator</code> 转换成 <code>iterator</code>，其是如何实现这种转换的呢？  </p><h4 id="条款29：需要一个一个字符输入时考虑使用-istreambuf-iterator"><a href="#条款29：需要一个一个字符输入时考虑使用-istreambuf-iterator" class="headerlink" title="条款29：需要一个一个字符输入时考虑使用 istreambuf_iterator"></a>条款29：需要一个一个字符输入时考虑使用 <code>istreambuf_iterator</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第二章 &lt;code&gt;vector&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 和第三章的关联容器的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-1</title>
    <link href="http://abumaster.com/2018/04/06/%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8STL-1/"/>
    <id>http://abumaster.com/2018/04/06/高效实用STL-1/</id>
    <published>2018-04-06T07:53:39.000Z</published>
    <updated>2018-04-07T11:00:27.125Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第一章容器的介绍。</p></div><a id="more"></a><h4 id="条款1：小心选择容器"><a href="#条款1：小心选择容器" class="headerlink" title="条款1：小心选择容器"></a>条款1：小心选择容器</h4><p><strong>容器的分类：</strong>  </p><ul><li>标准STL序列容器：<code>vector</code>、<code>string</code>、<code>deque</code>和<code>list</code>。  </li><li>标准STL关联容器：<code>map</code>、<code>set</code>和<code>multiset</code>、<code>multimap</code>。  </li><li>非标准序列容器：<code>slist</code>和<code>rope</code>，单向链表和重型字符串。  </li><li>非标准关联容器：包括基于散列表的容器<code>hash_**</code>。  </li><li>标准非STL容器：数组、<code>bitset</code>、<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。  </li></ul><p>容器的选择可以考虑使用场景需要的算法的复杂度高低，如需要在容器的中间频繁插入删除元素，这时需要的容器可能是<code>list</code>，当需要在头尾插入删除元素，那么<code>deque</code>则是一个好的选择。<br>同时，也应该考虑到迭代器的能力，内存布局的兼容能力容器操作复杂度等等。  </p><h4 id="条款2：容器无关代码？"><a href="#条款2：容器无关代码？" class="headerlink" title="条款2：容器无关代码？"></a>条款2：容器无关代码？</h4><p>容器的使用真的与代码无关吗？考虑以下场景，<code>vector</code>和<code>list</code>在使用过程中，迭代器和内存布局是不一样的，因此，两个容器在使用过程中完全是不兼容的，许多方法是特有的，不能同时使用。当代码中的一个容器替换成另一个容器的时候，要考虑旧的代码对新的容器的适用性，保证不出现错误的使用，而导致编译错误。<br>一个比较方便的做法是使用 <code>typedef</code> 自定义迭代器类型。如代码不应这样写：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Widget &#123;...&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br><span class="line">Widget bestWidget;</span><br><span class="line"><span class="comment">// 给bestWidget一个值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt;::iterator i = <span class="comment">// 寻找和bestWidget相等的Widget</span></span><br><span class="line">    find(vw.begin(), vw.end(), bestWidget);</span><br></pre></td></tr></table></figure></p><p>其中如果更换迭代器的话，需要查找所有的 <code>vector&lt;Widget&gt;</code> 然后改成新的容器，高效的写法是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Widget &#123; ... &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Widget&gt; WidgetContainer;         <span class="comment">//Widget类型的容器类型</span></span><br><span class="line"><span class="keyword">typedef</span> WidgetContainer::iterator WCIterator;   <span class="comment">//迭代器</span></span><br><span class="line">WidgetContainer cw;</span><br><span class="line">Widget bestWidget;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">WCIterator i = find(cw.begin(), cw.end(), bestWidget);</span><br></pre></td></tr></table></figure></p><p>这种做法，直接改 <code>typedef</code> 那两行就行。<br>如果不想用 <code>typedef</code> 将使用的容器暴露给用户，那么可以使用 <code>class</code> 将内部使用的容器私有化，只对用户提供统一的调用接口，当根据需求需要改变容器时，对用户代码不必进行过多的更改。  </p><h4 id="条款3：容器内对象的拷贝"><a href="#条款3：容器内对象的拷贝" class="headerlink" title="条款3：容器内对象的拷贝"></a>条款3：容器内对象的拷贝</h4><div class="note info"><p>主旨：使容器内对象拷贝操作的轻量而正确。</p></div>  <p>一个好的做法是，将对象数组（容器）改为指针的数组（容器），毕竟指针的拷贝比对象的拷贝要快。</p><h4 id="条款4：用-empty-替换-size-0"><a href="#条款4：用-empty-替换-size-0" class="headerlink" title="条款4：用 empty 替换 size()==0"></a>条款4：用 <code>empty</code> 替换 <code>size()==0</code></h4><p>当判断一个容器中元素是否为空时，通常使用 <code>empty()</code> 它是常数时间的，而用 <code>size()==0</code> 来判断则是线性时间。  </p><h4 id="条款5：使用空间成员函数"><a href="#条款5：使用空间成员函数" class="headerlink" title="条款5：使用空间成员函数"></a>条款5：使用空间成员函数</h4><p>空间成员函数可以操作一个区间内的元素，而不是使用循环来对单个元素进行操作，具体的应用场景为，将容器内的元素用另一个容器中的元素替代，成段拷贝，区间赋值等等如。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( size_type count, <span class="keyword">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( InputIt first, InputIt last )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="条款6：C-的解析"><a href="#条款6：C-的解析" class="headerlink" title="条款6：C++的解析"></a>条款6：C++的解析</h4><blockquote><p>C++里面的一条通用规则，几乎任何东西都能被分析为函数声明  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Widget &#123;...&#125;; <span class="comment">// 假设Widget有默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">()</span></span>; <span class="comment">// 函数名w，返回一个Widget类型</span></span><br></pre></td></tr></table></figure><p>造成这种歧义出现的主要原因是，编译器无法知道你是调用构造还是函数声明，当有一个含有<code>int</code>类型的文件，需要从中读出放入<code>list</code>中，有如下代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.不正确的写法</span></span><br><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="comment">//想用迭代器构造这个list，但实际上却是在声明一个函数</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile), istream_iterator&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.正确的写法</span></span><br><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="comment">//定义两个迭代器</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; dataBegin(dataFile);</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; dataEnd;</span><br><span class="line"><span class="comment">//用迭代器初始化list</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(dataBegin, dataEnd);</span><br></pre></td></tr></table></figure></p><h4 id="条款7：销毁容器前记得释放动态申请的空间"><a href="#条款7：销毁容器前记得释放动态申请的空间" class="headerlink" title="条款7：销毁容器前记得释放动态申请的空间"></a>条款7：销毁容器前记得释放动态申请的空间</h4><p>当容器中保存着的是 <code>new</code> 申请到的动态对象时，当作用域失效后，容器自己的空间会由系统回收，但是动态申请的空间不会回收，这时需要手动回收空间。需要注意的是：手动释放以及异常处理。比较好的一种做法是使用智能指针，来智能管理内存空间。  </p><h4 id="条款8：永不建立-auto-ptr-的容器"><a href="#条款8：永不建立-auto-ptr-的容器" class="headerlink" title="条款8：永不建立 auto_ptr 的容器"></a>条款8：永不建立 <code>auto_ptr</code> 的容器</h4><p><code>auto_ptr</code> 的容器（COAPs）是被 <strong>禁止</strong> 的。  </p><h4 id="条款9：删除选项中仔细选择"><a href="#条款9：删除选项中仔细选择" class="headerlink" title="条款9：删除选项中仔细选择"></a>条款9：删除选项中仔细选择</h4><ul><li>去除一个容器中有特定值的所有对象：<br>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove</code>惯用法。如果容器是<code>list</code>，使用<code>list::remove</code>。如果容器是标准关联容器，使用它的<code>erase</code>成员函数。</li><li>去除一个容器中满足一个特定判定式的所有对象：<br>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove_if</code>惯用法。如果容器是<code>list</code>，使用<code>list::remove_if</code>。如果容器是标准关联容器，使用<code>remove_copy_if</code>和<code>swap</code>，或写一个循环来遍历容器元素，当你把迭代器传给<code>erase</code>时记得后置递增它。</li><li>在循环内做某些事情（除了删除对象之外）：<br>如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用<code>erase</code>时记得都用它的返回值更新你的迭代器。如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给<code>erase</code>时记得后置递增它。</li></ul><h4 id="条款10：注意分配器的协定和约束"><a href="#条款10：注意分配器的协定和约束" class="headerlink" title="条款10：注意分配器的协定和约束"></a>条款10：注意分配器的协定和约束</h4><h4 id="条款11：理解自定义分配器的正确用法"><a href="#条款11：理解自定义分配器的正确用法" class="headerlink" title="条款11：理解自定义分配器的正确用法"></a>条款11：理解自定义分配器的正确用法</h4><h4 id="条款12：STL容器线程安全性考虑"><a href="#条款12：STL容器线程安全性考虑" class="headerlink" title="条款12：STL容器线程安全性考虑"></a>条款12：STL容器线程安全性考虑</h4><p>多线程环境下对容器的操作如果没有特殊的处理是不安全的，不安全的处理应该包括以下方面：  </p><ul><li>保证多个线程读取容器内容时正确并且不能有写线程</li><li>多线程写时的互斥操作</li></ul><p>为了保证线程安全需要做的是通过 <strong>信号量</strong>、<strong>互斥锁</strong> 等线程同步原语，对容器的操作进行封装，常见的做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个锁类，构造时加锁，析构时自动释放</span></span><br><span class="line"><span class="keyword">class</span> Lock &#123; <span class="comment">// 的类的模板核心；</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 忽略了很多细节</span></span><br><span class="line">    Lock(<span class="keyword">const</span> Containers container): c(container)</span><br><span class="line">    &#123;</span><br><span class="line">        getMutexFor(c); <span class="comment">//在构造函数获取互斥量</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Lock()</span><br><span class="line">    &#123;</span><br><span class="line">        releaseMutexFor(c); <span class="comment">//在析构函数里释放它</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> Container&amp; c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#123; <span class="comment">//建立新代码块；</span></span><br><span class="line">    Lock&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; lock(v); <span class="comment">//获取互斥量</span></span><br><span class="line">    vector&lt;int&gt;::iterator first5(find(v.begin(), v.end(), 5));</span><br><span class="line">    <span class="keyword">if</span> (first5 != v.end()) &#123;</span><br><span class="line">        *first5 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//离开作用域，自动释放锁</span></span><br></pre></td></tr></table></figure></p><p>这种做法的优势是可以保证加锁和释放锁是成对出现的，同时也可以保证异常出现时可以正确释放锁。因为是局部变量，当作用域消失时就会自动释放。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第一章容器的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>日志库easyloggingpp使用</title>
    <link href="http://abumaster.com/2018/03/28/%E6%97%A5%E5%BF%97%E5%BA%93easyloggingpp%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2018/03/28/日志库easyloggingpp使用/</id>
    <published>2018-03-28T12:59:03.000Z</published>
    <updated>2018-03-29T08:29:07.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/muflihun/easyloggingpp">easyloggingpp</a> 是一个只需引用一个头文件的 <code>C++</code> 日志库，它具有轻量高效、可扩展、线程安全、可嵌入到自己开发模块等等特性。  </p></blockquote><a id="more"></a><pre><a href="#下载使用">下载使用</a><a href="#自定义配置">自定义配置</a>    <a href="#日志级别">日志级别</a>    <a href="使用配置文件">使用配置文件</a><a href="记录日志">记录日志</a>    <a href="基本操作">基本操作</a></pre><h3 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h3><p>从<a href="https://github.com/muflihun/easyloggingpp">easyloggingpp</a>下载最新的代码，通过 <code>CMake</code> 编译成独立的链接库，或者直接将 <code>easylogging++.h</code> 和 <code>easylogging++.cc</code> 源文件拷贝到自己的项目中，一起编译。官方示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"easylogging++.h"</span>              <span class="comment">//包含头文件</span></span></span><br><span class="line"></span><br><span class="line">INITIALIZE_EASYLOGGINGPP                <span class="comment">//用宏来表示初始化日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   LOG(INFO) &lt;&lt; <span class="string">"My first info log using default logger"</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后使用以下命令编译生成可执行文件，日志在控制台中显示，并且在项目目录下有日志文件生成。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cc easylogging++.cc -o prog -std=c++11</span><br></pre></td></tr></table></figure></p><h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>它最大的特性就是日志的高度可配置性，通过配置宏参数可以设置日志的级别和格式。以下列出了日志级别分类：</p><table><thead><tr><th style="text-align:left">Level</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Global</td><td style="text-align:left">通用日志级别，全局设置时使用</td></tr><tr><td style="text-align:left">Trace</td><td style="text-align:left">回溯某个特定事件的信息，比调试日志更有用</td></tr></tbody></table><p>Debug  | 开发过程中调试应用程序，调试开关要打开Fatal  | 可能导致应用程序中断的非常严重的错误事件Error   |  程序运行过程中的错误信息，程序继续运行Warning |  程序运行过程中的错误信息Info    |   应用程序当前的运行信息Verbose |   处理冗长的日志信息Unknown |   适用分层日志记录，完全关闭日志记录</p><h4 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  log_conf.conf 配置文件</span></span><br><span class="line">* GLOBAL:</span><br><span class="line">    ENABLED                     = <span class="literal">true</span></span><br><span class="line">    TO_FILE                     = <span class="literal">true</span></span><br><span class="line">    TO_STANDARD_OUTPUT          = <span class="literal">true</span></span><br><span class="line">    FORMAT                      = <span class="string">"[%level | %datetime] | %msg"</span></span><br><span class="line">    FILENAME                    = <span class="string">"log\\log_%datetime&#123;%Y%M%d&#125;.log"</span></span><br><span class="line">    SUBSECOND_PRECISION         =  6</span><br><span class="line">    PERFORMANCE_TRACKING        =  <span class="literal">true</span></span><br><span class="line">    MAX_LOG_FILE_SIZE           =  2097152 <span class="comment">## 2MB - Comment starts with two hashe</span></span><br><span class="line">    LOG_FLUSH_THRESHOLD         =  100 <span class="comment">## Flush after every 100 logs</span></span><br><span class="line"></span><br><span class="line">* TRACE:</span><br><span class="line">    FILENAME                    =   <span class="string">"log\\trace_log_%datetime&#123;%Y%M%d&#125;.log"</span></span><br><span class="line"></span><br><span class="line">* DEBUG:</span><br><span class="line">    FORMAT                      = <span class="string">"%datetime&#123;%d/%M&#125; %func %msg"</span></span><br><span class="line">    FILENAME                    = <span class="string">"log\\debug_log_%datetime&#123;%Y%M%d&#125;.log"</span></span><br><span class="line"></span><br><span class="line">* FATAL:</span><br><span class="line">    ENABLED                     = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">* ERROR:</span><br><span class="line">    FILENAME                    = <span class="string">"log\\error_log_%datetime&#123;%Y%M%d&#125;.log"</span></span><br><span class="line"></span><br><span class="line">* WARNING:</span><br><span class="line">    FILENAME                    = <span class="string">"log\\warning_log_%datetime&#123;%Y%M%d&#125;.log"</span></span><br><span class="line"></span><br><span class="line">* INFO:</span><br><span class="line">    FILENAME                    = <span class="string">"log\\info_log_%datetime&#123;%Y%M%d&#125;.log"</span></span><br><span class="line">    FORMAT                      = <span class="string">"[%host : %user] | %msg"</span></span><br><span class="line"></span><br><span class="line">* VERBOSE:</span><br><span class="line">    ENABLED                     = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>通过构造日志记录器来加载配置文件完成对日志的自定义，使用：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"easylogging++.h"</span></span></span><br><span class="line"></span><br><span class="line">INITIALIZE_EASYLOGGINGPP</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载配置文件，构造一个配置器对象</span></span><br><span class="line">    el::<span class="function">Configurations <span class="title">conf</span><span class="params">(<span class="string">"/path/to/my-conf.conf"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 重新配置一个单一日志记录器</span></span><br><span class="line">    el::Loggers::reconfigureLogger(<span class="string">"default"</span>, conf);</span><br><span class="line">    <span class="comment">// 用配置文件配置所有的日志记录器</span></span><br><span class="line">    el::Loggers::reconfigureAllLoggers(conf);</span><br><span class="line">    <span class="comment">// 所有的日志记录器都是从文件中配置完成的，可以使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="日志格式说明符"><a href="#日志格式说明符" class="headerlink" title="日志格式说明符"></a>日志格式说明符</h4><p>日志的输出格式可以自定义，库中提供了一些说明符来表示不同的含义：</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left"><code>%logger</code></td><td style="text-align:left">loggger ID  </td></tr><tr><td style="text-align:left"><code>%thread</code></td><td style="text-align:left">thread ID</td></tr><tr><td style="text-align:left"><code>%thread_name</code></td><td style="text-align:left">用来获取线程的名称，是使用 <code>el::Helpers::setThreadName(&quot;name1&quot;)</code> 来设置的线程标识名</td></tr><tr><td style="text-align:left"><strong><code>%level</code></strong></td><td style="text-align:left">日志的级别，诸如 <code>DEBUG</code>、<code>INFO</code>、<code>WARNING</code>等</td></tr><tr><td style="text-align:left"><code>%levshort</code></td><td style="text-align:left">日志级别的缩写</td></tr><tr><td style="text-align:left"><code>%vlevel</code></td><td style="text-align:left">使用详细记录，冗长记录级别</td></tr><tr><td style="text-align:left"><strong><code>%datetime</code></strong></td><td style="text-align:left">当前的时间，可以自定义时间的格式</td></tr><tr><td style="text-align:left"><strong><code>%user</code></strong></td><td style="text-align:left">当前运行程序的用户名</td></tr><tr><td style="text-align:left"><strong><code>%host</code></strong></td><td style="text-align:left">运行程序的机器名称</td></tr><tr><td style="text-align:left"><strong><code>%file</code></strong></td><td style="text-align:left">源程序的名称，包含完整的路径信息</td></tr><tr><td style="text-align:left"><code>%fbase</code></td><td style="text-align:left">只有文件的名称</td></tr><tr><td style="text-align:left"><strong><code>%line</code></strong></td><td style="text-align:left">运行到此处的代码行</td></tr><tr><td style="text-align:left"><strong><code>%func</code></strong></td><td style="text-align:left">函数的名称</td></tr><tr><td style="text-align:left"><strong><code>%loc</code></strong></td><td style="text-align:left">函数的名称以及行号</td></tr><tr><td style="text-align:left"><strong><code>%msg</code></strong></td><td style="text-align:left">日志信息</td></tr><tr><td style="text-align:left"><em><code>%</code></em></td><td style="text-align:left">转义字符</td></tr></tbody></table><p><strong>日期的格式</strong><br>通过上述的符号 <code>%datetime</code> 获取了时间，可以通过自定义的方式来格式化时间，常用的格式符如下：</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left"><code>%d</code></td><td style="text-align:left">一月中的几号</td></tr><tr><td style="text-align:left"><code>%a</code></td><td style="text-align:left">简写的星期几</td></tr><tr><td style="text-align:left"><code>%A</code></td><td style="text-align:left">全称星期几</td></tr><tr><td style="text-align:left"><code>%Y %M %d %H %m %s</code></td><td style="text-align:left">年月日时分秒</td></tr></tbody></table><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>有两种方式来记录日志<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOG(LEVEL) &lt;&lt; <span class="string">"info"</span>;               <span class="comment">//第一种：使用默认的日志记录器</span></span><br><span class="line">CLOG(LEVEL, logger ID) &lt;&lt; <span class="string">"info"</span>;   <span class="comment">//第二种：指定特定的日志记录器，可以自己注册</span></span><br></pre></td></tr></table></figure></p><p>库中注册的有三种：</p><ul><li>默认的日志记录器 ID: <code>dfault</code> ；</li><li>性能日志记录器 ID: <code>performance</code> ；</li><li>系统日志记录器 ID: <code>syslog</code>可以使用以下方式注册自己的日志记录器：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个ID为business的日志记录器，没有会自动创建</span></span><br><span class="line">el::Logger* businessLogger = el::Loggers::getLogger(<span class="string">"business"</span>);</span><br><span class="line"><span class="comment">//businessLogger -&gt;</span></span><br><span class="line"><span class="comment">//info(const char*, const T&amp;, const Args&amp;...)</span></span><br><span class="line"><span class="comment">//warn(const char*, const T&amp;, const Args&amp;...)</span></span><br><span class="line"><span class="comment">//error(const char*, const T&amp;, const Args&amp;...)</span></span><br><span class="line"><span class="comment">//debug(const char*, const T&amp;, const Args&amp;...)</span></span><br><span class="line"><span class="comment">//fatal(const char*, const T&amp;, const Args&amp;...)</span></span><br><span class="line"><span class="comment">//trace(const char*, const T&amp;, const Args&amp;...)</span></span><br><span class="line"><span class="comment">//verbose(int vlevel, const char*, const T&amp;, const Args&amp;...)</span></span><br><span class="line"><span class="comment">//来记录日志 可以使用 %v 来格式化数据</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="条件日志记录"><a href="#条件日志记录" class="headerlink" title="条件日志记录"></a>条件日志记录</h4><p>满足条件后，开始记录日志，不满足条件不会记录，使用如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOG_IF(condition, LEVEL)</span><br><span class="line">CLOG_IF(condition, LEVEL, logger ID)</span><br></pre></td></tr></table></figure></p><h4 id="记录特定次数日志"><a href="#记录特定次数日志" class="headerlink" title="记录特定次数日志"></a>记录特定次数日志</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOG_EVERY_N(n, LEVEL)</span><br><span class="line">CLOG_EVERY_N(n, LEVEL, logger ID)</span><br><span class="line"></span><br><span class="line">LOG_AFTER_N(n, LEVEL); <span class="comment">//Only logs when we have reached hit counts of n</span></span><br><span class="line">LOG_N_TIMES(n, LEVEL); <span class="comment">//Logs n times</span></span><br></pre></td></tr></table></figure><p>源文件 <code>sample</code> 下有使用示例。  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/muflihun/easyloggingpp&quot;&gt;easyloggingpp&lt;/a&gt; 是一个只需引用一个头文件的 &lt;code&gt;C++&lt;/code&gt; 日志库，它具有轻量高效、可扩展、线程安全、可嵌入到自己开发模块等等特性。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="日志库" scheme="http://abumaster.com/tags/%E6%97%A5%E5%BF%97%E5%BA%93/"/>
    
  </entry>
  
</feed>
