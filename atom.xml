<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2017-08-28T09:15:22.257Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018秋招-360</title>
    <link href="http://abumaster.com/2017/08/27/2018%E7%A7%8B%E6%8B%9B-360/"/>
    <id>http://abumaster.com/2017/08/27/2018秋招-360/</id>
    <published>2017-08-27T09:09:54.000Z</published>
    <updated>2017-08-28T09:15:22.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>360 2018秋招笔试编程题目解析。</p>
</blockquote>
<a id="more"></a>
<h4 id="卖粉笔问题"><a href="#卖粉笔问题" class="headerlink" title="卖粉笔问题"></a>卖粉笔问题</h4><p>有彩色粉笔<code>n</code>个，白色粉笔<code>m</code>个，<code>a</code>个彩色粉笔和<code>b</code>个白色粉笔打包可以卖<code>x</code>元，<code>c</code>个白色粉笔可以卖<code>y</code>元，<code>d</code>个彩色粉笔可以卖<code>z</code>元，问可以获得的最大收益。  </p>
<p><strong>解题思路1：</strong><br>首先想到的是动态规划问题，对于有<code>i</code>个彩色粉笔和<code>j</code>个白色粉笔，<code>dp[i][j]</code>表示可以卖到的最大值，那么这个最大值是如何求出的呢？<br>状态转移有以下几种情况：  </p>
<ul>
<li>只卖白色，<code>dp[i][j] = dp[i][j-c] + y</code>；  </li>
<li>只卖彩色，<code>dp[i][j] = dp[i-d][j] + z</code>；  </li>
<li>组合卖，<code>dp[i][j] = dp[i-a][j-b] + x</code>。<br>取三种情况的最大值，最后<code>dp[n][m]</code>就是所求的结果。<br>分析，双层循环，复杂度的<code>O(N*M)</code>。  </li>
</ul>
<p><strong>解题思路2：</strong><br>相对于动态规划要简单许多，要获得最大利润，最终的粉笔肯定有一个组合，假设为<code>x</code>对组合卖掉，那么白色粉笔还剩余<code>m-b*x</code>个，白色粉笔可以最多卖的钱数为<code>(m-b*x)/c * y</code>，同理可以得到彩色的所卖钱数。对于最终组合，其他的组合都不是最优的结果，所以，可以用组合卖的粉笔组数来进行最优解选择。<br>代码如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//最大收益</span></div><div class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//组合卖的盒数</span></div><div class="line"><span class="keyword">while</span> (index*a &lt;= n &amp;&amp; index*b &lt;= m)<span class="comment">//可以组合来卖</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp = index*x;<span class="comment">//组合卖的收益</span></div><div class="line">    temp += ((m - index*b) / c)*y;<span class="comment">//白色粉笔单独卖的收益</span></div><div class="line">    temp += ((n - index*a) / d)*z;<span class="comment">//彩色粉笔单独卖的收益</span></div><div class="line">    ans = (ans &gt; temp) ? ans : temp;<span class="comment">//更新收益最大值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>复杂度仅为<code>O(n)</code>性能得到了很大的提升。启示：想到最终状态，然后再步步推。  </p>
<h4 id="统计数组中前面比自己小的数字个数"><a href="#统计数组中前面比自己小的数字个数" class="headerlink" title="统计数组中前面比自己小的数字个数"></a>统计数组中前面比自己小的数字个数</h4><p>类似于这样的题：给定一个整数数组（下标由 <code>0</code> 到 <code>n-1</code>， <code>n</code> 表示数组的规模，取值范围由 0 到10000）。对于数组中的每个 <code>ai</code> 元素，请计算 <code>ai</code> 前的数中比它小的元素的数量。    </p>
<p><strong>思路1：</strong><br>暴力求解，复杂度太高，无法完全通过。  </p>
<p><strong>思路2：</strong><br><div class="note info"><p>分析：求ai前的数中比他小的元素数量，即，在<code>ai</code>之前的元素中区间<code>[0, ai-1]</code>的元素数量<br>构建线段树，节点中包含元素出现的次数，所有<code>count&gt;0</code> 的叶子结点表示元素存在；依次更新结点计数，所以后面的元素不影响前面的元素计数。</p>
</div><br><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5%E6%A0%91/10983506?fr=aladdin">线段树</a>是一种数据结构，是一种二叉搜索树，每个叶节点表示一个单元区间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> XianDuanTree</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> Node<span class="comment">//线段树的节点</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">int</span> start, end, count;</div><div class="line">        Node *left, *right;</div><div class="line">        Node(<span class="keyword">int</span> start, <span class="keyword">int</span> end) :start(start), end(end), count(<span class="number">0</span>), right(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//创建线段树，返回根节点</span></div><div class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="comment">//递归创建，返回条件</span></div><div class="line">        <span class="keyword">if</span> (start &gt; end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</div><div class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">            root-&gt;left = build(start, mid);</div><div class="line">            root-&gt;right = build(mid + <span class="number">1</span>, end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在线段树中查找区间</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (start &gt; end || root-&gt;start &gt; end || root-&gt;end &lt; start) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end) <span class="keyword">return</span> root-&gt;count;<span class="comment">//查找的区间包含root所指区间</span></div><div class="line">        <span class="keyword">int</span> mid = (root-&gt;start + root-&gt;end) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> leftCount = query(root-&gt;left, start, min(mid, end));</div><div class="line">        <span class="keyword">int</span> rightCount = query(root-&gt;right, max(mid, start), end);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> leftCount + rightCount;<span class="comment">//返回左右子树的查找数量</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//像线段树中插入value</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inset</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (root-&gt;left == root-&gt;right &amp;&amp; root-&gt;start == value)</div><div class="line">        &#123;</div><div class="line">            root-&gt;count += <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//递归查找合适的插入位置</span></div><div class="line">        <span class="keyword">int</span> mid = (root-&gt;start + root-&gt;end) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (value &lt;= mid)</div><div class="line">        &#123;</div><div class="line">            inset(root-&gt;left, value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            inset(root-&gt;right, value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//回溯自下而上更新count//右子树不一定存在所以进行判断</span></div><div class="line">        root-&gt;count = root-&gt;left-&gt;count + (root-&gt;right ? root-&gt;right-&gt;count : <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSamllerNum()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">        Node *root = build(<span class="number">0</span>, <span class="number">10005</span>);</div><div class="line">        <span class="keyword">int</span> n,temp;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</div><div class="line">            <span class="keyword">int</span> cnt = query(root, temp+<span class="number">1</span>, <span class="number">10005</span>);<span class="comment">//前面比他大的数，区间为[temp+1,maxn]，的数的数量</span></div><div class="line">            vec.push_back(cnt);</div><div class="line">            inset(root, temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> vec;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="简单数列"><a href="#简单数列" class="headerlink" title="简单数列"></a>简单数列</h4><p>题目描述见图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-28/45707399.jpg" alt=""><br><a href="http://www.cnblogs.com/qscqesze/p/5217014.html">类似的题目地址</a><br>思路：<br>交换0次和交换一次，显然可以直接暴力出来<br>现在考虑交换两次的情况，交换两次之后，答案为<code>s-2*a[i]-2*a[j]+2*b[i]+2*b[j]</code>（s为原来未交换的时候，两个数组的差值。我们把所有的<code>(a[i],a[j])</code>都存起来，为了使两数组之差最小，显然<code>2*(b[i]+b[j])</code>应该找到大于等于<code>(2*(a[i]+a[j])-s)</code>的第一个数然后这个东西直接二分就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2050</span>;</div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"><span class="keyword">int</span> b[maxn];</div><div class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span> ,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;two[maxn*maxn+<span class="number">5</span>];</div><div class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),s+=a[i];</div><div class="line">    <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]),s-=b[i];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s2 = <span class="number">1e18</span>;</div><div class="line">    <span class="comment">//交换一次后的结果</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="built_in">abs</span>(s + <span class="number">2</span>*b[j] - <span class="number">2</span>*a[i]);</div><div class="line">            <span class="keyword">if</span>(cur&lt;s2)</div><div class="line">            &#123;</div><div class="line">                s2 = cur;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">            two[++tot]=make_pair(<span class="number">2l</span>l*b[i]+<span class="number">2l</span>l*b[j],make_pair(i,j));</div><div class="line">    sort(two+<span class="number">1</span>,two+<span class="number">1</span>+tot);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s3 = <span class="number">1e18</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">2l</span>l*a[i]+<span class="number">2l</span>l*a[j]-s;</div><div class="line">            <span class="keyword">int</span> p = lower_bound(two+<span class="number">1</span>,two+<span class="number">1</span>+tot,make_pair(tmp,make_pair(<span class="number">0</span>,<span class="number">0</span>)))-two;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=max(<span class="number">1</span>,p<span class="number">-2</span>);t&lt;=min(tot,p+<span class="number">2</span>);t++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="built_in">abs</span>(s+two[t].first<span class="number">-2</span>ll*a[i]<span class="number">-2</span>ll*a[j]);</div><div class="line">                <span class="keyword">if</span>(cur&lt;s3)</div><div class="line">                &#123;</div><div class="line">                    s3 = cur;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = min(min(<span class="built_in">abs</span>(s),<span class="built_in">abs</span>(s2)),<span class="built_in">abs</span>(s3));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;360 2018秋招笔试编程题目解析。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="笔试" scheme="http://abumaster.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2018秋招-今日头条</title>
    <link href="http://abumaster.com/2017/08/27/2018%E7%A7%8B%E6%8B%9B-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    <id>http://abumaster.com/2017/08/27/2018秋招-今日头条/</id>
    <published>2017-08-27T09:09:22.000Z</published>
    <updated>2017-08-30T07:31:54.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今日头条2018秋招笔试，编程题目笔记。</p>
</blockquote>
<a id="more"></a>
<h4 id="第二题，求区间内最小值和区间元素和之间的乘积最大值"><a href="#第二题，求区间内最小值和区间元素和之间的乘积最大值" class="headerlink" title="第二题，求区间内最小值和区间元素和之间的乘积最大值"></a>第二题，求区间内最小值和区间元素和之间的乘积最大值</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/36221200.jpg" alt="">  </p>
<p>暴力解法，不可行。看了网上大神的分析，用 <strong>单调栈</strong> 的方法。<br><strong>单调栈</strong><br>单调栈是一个特殊的栈，栈中的元素大小按照其在栈中的位置，满足一定的单调性。<br>基本思想：<br><a href="http://blog.csdn.net/u013616945/article/details/77508372">参考</a>  </p>
<ul>
<li>将数组的每个值作为最小值，找到以此最小值的区间，统计区间和与此值的乘积，假设当前最小值 <code>num[k]</code> ，那么找到最左边小于该值的下标 <code>i</code> ，找到最右边小于该值的值的下标 <code>j</code> ，那么 <code>[i+1, j-1]</code> 是以 <code>num[k]</code> 为最小值所能达到的最大区间，那么计算 <code>Sum(i+1, j-1) * num[k]</code> 。  </li>
<li>按照上述遍历数组中的每一个值，（单调栈实现），维护一个最大值 <code>maxSum</code> 遍历完数组后，可解。  </li>
</ul>
<p>单调栈的实现：栈s<br>数组中元素入栈和出栈的规则如下：  </p>
<ol>
<li>s为空，或者当前元素 <code>num[i]</code> 的值大于等于当前栈顶元素，直接将 <code>num[i]</code> 的下标 <code>i</code> 压入栈；</li>
<li>当s不为空，且当前元素 <code>num[i]</code> 的值小于等于栈顶元素，那么依次从栈中弹出元素，直到 <code>num[i]</code> 大于栈顶元素，并在弹出过程中计算每一个数作为最小值区间的计算结果；  </li>
<li>如果数组遍历完成，但是栈非空，重复步骤2，直到栈空。  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">incr_stack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</div><div class="line">    <span class="keyword">int</span> n = num.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s.empty() || num[i] &gt;=num[s.top()]) &#123;<span class="comment">//规则1</span></div><div class="line">            s.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; num[s.top()] &gt;=num[i]) &#123;<span class="comment">//规则2</span></div><div class="line">                <span class="keyword">int</span> top = s.top();</div><div class="line">                s.pop();</div><div class="line">                <span class="keyword">int</span> tmp=s.empty()? vecSum(num, <span class="number">0</span>, i<span class="number">-1</span>) : vecSum(num, s.top()+ <span class="number">1</span>, i - <span class="number">1</span>);</div><div class="line">                <span class="keyword">int</span> curSum = num[top]*tmp;</div><div class="line">                maxSum = max(curSum, maxSum);</div><div class="line">            &#125;</div><div class="line">            s.push(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;<span class="comment">//规则3</span></div><div class="line">        <span class="keyword">int</span> top = s.top();</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">int</span> tmp=s.empty()? vecSum(num, <span class="number">0</span>, n<span class="number">-1</span>): vecSum(num, s.top()+ <span class="number">1</span>, n - <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> curSum =  num[top]*tmp;</div><div class="line">        maxSum = max(curSum, maxSum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/26465701">扩展题</a><br><div class="note info"><p>给一个数组，返回一个大小相同的数组。返回的数组的第i个位置的值应当是，对于原数组中的第i个元素，至少往右走多少步，才能遇到一个比自己大的元素（如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上-1）。<br><strong>简单的例子：</strong><br>input: 5,3,1,2,4<br>return: -1 3 1 1 -1<br><em>explaination:</em> 对于第0个数字5，之后没有比它更大的数字，因此是-1，对于第1个数字3，需要走3步才能达到4（第一个比3大的元素），对于第2和第3个数字，都只需要走1步，就可以遇到比自己大的元素。对于最后一个数字4，因为之后没有更多的元素，所以是-1。  </p>
</div></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextExceed(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result (input.size(), <span class="number">-1</span>);<span class="comment">//保存结果</span></div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; monoStack;<span class="comment">//单调栈</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); ++i) &#123;</div><div class="line">        <span class="comment">//如果栈不空，并且当前元素大于栈顶元素</span></div><div class="line">        <span class="keyword">while</span>(!monoStack.empty() &amp;&amp; input[monoStack.top()] &lt; input[i]) &#123;</div><div class="line">            result[monoStack.top()] = i - monoStack.top();<span class="comment">//求栈顶元素的结果</span></div><div class="line">            monoStack.pop();<span class="comment">//出栈</span></div><div class="line">        &#125;</div><div class="line">        monoStack.push(i);<span class="comment">//当前比栈顶小，压入栈</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="note warning"><p>给定n个非负数，代表直方图的高度，直方图的宽度为1，找到直方图所组成的矩形的最大面积。<br><em>input：</em> 2,1,5,6,2,3<br><em>output:</em> 10<br><em>explaination:</em> 5和6组成的矩形面积为10，返回10。   </p>
</div>  
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">            height.push_back(<span class="number">0</span>);</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</div><div class="line">                <span class="keyword">while</span>(index.size() &gt; <span class="number">0</span> &amp;&amp; height[index.back()] &gt;= height[i]) &#123;</div><div class="line">                    <span class="keyword">int</span> h = height[index.back()];</div><div class="line">                    index.pop_back();</div><div class="line">                    <span class="keyword">int</span> sidx = index.size() &gt; <span class="number">0</span> ? index.back() : <span class="number">-1</span>;</div><div class="line">                    ret = max(ret, h * (i-sidx<span class="number">-1</span>));</div><div class="line">                &#125;</div><div class="line">                index.push_back(i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h4 id="第三题，调度"><a href="#第三题，调度" class="headerlink" title="第三题，调度"></a>第三题，调度</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/66252799.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/54465329.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/34202462.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今日头条2018秋招笔试，编程题目笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="笔试" scheme="http://abumaster.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>牛客网校招模拟编程题(1-5)笔记</title>
    <link href="http://abumaster.com/2017/08/18/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%A0%A1%E6%8B%9B%E6%A8%A1%E6%8B%9F%E7%BC%96%E7%A8%8B%E9%A2%98-1-5-%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2017/08/18/牛客网校招模拟编程题-1-5-笔记/</id>
    <published>2017-08-18T06:43:17.000Z</published>
    <updated>2017-08-22T06:07:25.469Z</updated>
    
    <content type="html"><![CDATA[<p>牛客网上的2017年校招全国统一模拟试题的编程题目，比较难的一些题目汇总，做下记录。  </p>
<a id="more"></a>
<p><strong>1.猜数字游戏</strong><br><div class="note primary"><p>题目描述：<a href="https://www.nowcoder.com/test/5986669/summary">题目链接</a><br>牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中,牛牛玩家选择一个正整数,羊羊根据已给的提示猜这个数字。第i个提示是”Y”或者”N”,表示牛牛选择的数是否是i的倍数。<br>例如,如果提示是”YYNYY”,它表示这个数使1,2,4,5的倍数,但不是3的倍数。<br>注意到一些提示会出现错误。例如: 提示”NYYY”是错误的,因为所有的整数都是1的倍数,所以起始元素肯定不会是”N”。此外,例如”YNNY”的提示也是错误的,因为结果不可能是4的倍数但不是2的倍数。<br>现在给出一个整数n,表示已给的提示的长度。请计算出长度为n的合法的提示的个数。<br>例如 n = 5:<br>合法的提示有:<br>YNNNN YNNNY YNYNN YNYNY YYNNN YYNNY<br>YYNYN YYNYY YYYNN YYYNY YYYYN YYYYY<br>所以输出12  </p>
</div>  </p>
<p>合法的条件是存在倍数依赖的数字要么是全为Y要么全为N，分析：  </p>
<ul>
<li>第 i 个数是素数（如2,3,5,7…），那么在这一位上是Y或N与前面没有依赖，因此当前位的可能数目sum(i)是前面数目sum(i-1)的2倍；  </li>
<li>第 i 个数是偶数，但是却不是素数的幂，（如6,10…），那么这一位是Y或N完全取决于它的两个因子，如6取决于2和3,2和3是Y，6一定是Y。因此，sum(i)为sum(i-1)；  </li>
<li>第 i 个数是素数的幂，（如4,9,8…），它是不能唯一确定的，2取Y，4可以取Y也可以取N，所以对于4，将2,4加入集合取值的组合为NN，YN，YY三种情况，对于8来说，由2,4,8组成，共有NNN，YNN，YYN，YYY四种情况，依次类推就行了，相乘。  </li>
</ul>
<p>关键代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (vis[i])<span class="comment">//是倍数直接可以忽略掉不要重复计算</span></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)<span class="comment">//倍数</span></div><div class="line">    &#123;</div><div class="line">        vis[j] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求i的幂次</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mi = i;</div><div class="line">    <span class="keyword">while</span> (mi &lt;= n)</div><div class="line">    &#123;</div><div class="line">        cnt++;<span class="comment">//记录幂的数目</span></div><div class="line">        mi *= i;</div><div class="line">    &#125;</div><div class="line">    ans = ans * (cnt + <span class="number">1</span>) % MOD;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p><strong>2.庆祝六一</strong><br>题目描述：<br>牛家庄幼儿园为庆祝61儿童节举办庆祝活动,庆祝活动中有一个节目是小朋友们围成一个圆圈跳舞。牛老师挑选出n个小朋友参与跳舞节目,已知每个小朋友的身高h_i。为了让舞蹈看起来和谐，牛老师需要让跳舞的圆圈队形中相邻小朋友的身高差的最大值最小，牛老师犯了难，希望你能帮帮他。<br>如样例所示:<br>当圆圈队伍按照100,98,103,105顺时针排列的时候最大身高差为5，其他排列不会得到更优的解。  </p>
<p><a href="https://www.nowcoder.com/test/question/done?tid=10037688&amp;qid=104799#summary">分析</a><br>身高差最小，将两个差不多的身高的站一块。
如 9 8 7 6 6 7 8 9然后9和9再拉手不就可以了吗 ！所以将数据输入一个数组如【8 9 7 6 5 4 3 2】然后排序【2 3 4 5 6 7 8 9】然后遍历数组进入一个队列一个栈 现规定，索引为0,2,4，，，的依次进入队列Q1，索引为1,3,5，，，，的依次进入//栈S1，就形成一个队列2 4 6 8 （队列尾为8）和一个栈3 5 7 9（栈顶为9） 。然后出栈9 7 5 3依次进入队列尾 形成 2 4 6 8 9 7 5 3 就排队成功，2和3拉手就成圈，求每个元素与挨着的距离就可以了。<br>分析2：<br>动态规划，先将所有的小朋友按低到高排序，dp[i] 表示前i个小朋友最优排列的最大身高差，递推公式为： dp[i+1]=max(dp[i],arr[i+1]-arr[i-1])。  </p>
<p><strong>3.逃离农场</strong><br>题目描述：<br>牛牛在农场饲养了n只奶牛,依次编号为0到n-1, 牛牛的好朋友羊羊帮牛牛照看着农场.有一天羊羊看到农场中逃走了k只奶牛,但是他只会告诉牛牛逃走的k只奶牛的编号之和能被n整除。你现在需要帮牛牛计算有多少种不同的逃走的奶牛群。因为结果可能很大,输出结果对1,000,000,007取模。<br>例如n = 7 k = 4:<br>7只奶牛依次编号为0到6, 逃走了4只<br>编号和为7的有:{0, 1, 2, 4}<br>编号和为14的有:{0, 3, 5, 6}, {1, 2, 5, 6}, {1, 3, 4, 6},{2, 3, 4, 5}<br>4只牛的编号和不会大于18,所以输出5。<br>分析：<br>动态规划，令<code>dp[i][j][s]</code>表示从区间[0,i]中取j个数字，使它们的和与n取模后余数为s，满足这样条件的集合的个数。<br>状态转移方程如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j][s] = (dp[i<span class="number">-1</span>][j][s] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>][(n+s-i)%n]);</div></pre></td></tr></table></figure></p>
<p>转移的过程就是第i个数取还是不取，如果不取，那么就和方法i-1的个数相同；<br>如果取第i个数的话，那么就需要分两种情况，因为第i个数可能大于s，也有可能小于等于s。<br><em>情况1：</em>若<code>i&lt;=s</code>,此时我们需要从前i-1个数中取j-1个数，使他们的和与n的模为s-i。这样就能保证在加入i时，和模n等于s。<br><em>情况2：</em>如果i&gt;s,那么i-s为负数，注意本题的要求是组成和为n的倍数，因此这种情况下需要将<code>(s-i)%n</code>表示为<code>（s-i+n）%n</code>，因为<code>((s-i+n)%n+i)%n=s</code>。<br>可以压缩空间，减少空间复杂度。代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> modMin=<span class="number">1e9</span>+<span class="number">7</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line">  </span>&#123;</div><div class="line">    <span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">1005</span>];</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> n,k;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">      &#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">           &#123;</div><div class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;=<span class="number">1</span>;j--)</div><div class="line">               &#123;</div><div class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;n;s++)</div><div class="line">                    &#123;</div><div class="line">                       dp[j][s]=(dp[j][s]+dp[j<span class="number">-1</span>][(n+s-i)%n])%modMin;</div><div class="line">                    &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">         <span class="built_in">cout</span>&lt;&lt;dp[k][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.牛牛的数列</strong><br>题目描述：<br>牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。<br>输入描述:<br>输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;<br>第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。<br>输出描述:<br>输出一个整数,表示最长的长度。<br>输入例子:<br>6<br>7 2 3 1 5 6<br>输出例子:<br>5<br>分析：<br>动态规划问题，题目中改变一个数字所能达到的严格上升子序列的最大长度，可以假设有两段上升子序列，它们中间可以改变一个数字，使他们连接起来，找到它们之间最长的就行了。<br>因此，设<code>dp1[i]</code>表示i结尾的最长上升子序列的长度，<code>dp2[i]</code>表示以i开始的最长上升子序列长度。分别从前或从后扫描计算即可。<br>然后，扫描数列，对于第i个数，i是第一个数，那么长度为<code>dp2[i+1]+1</code>，如果i为最后一个数，那么长度为<code>dp1[i-1]+1</code>，其他情况，如果i+1的值与i-1之间差值大于1，那么长度为<code>dp2[i+1]+dp1[i-1]+1</code>，如果不大于1只能在前或者在后取一个值了，长度为<code>max(dp2[i+1]+1,dp1[i-1]+1)</code>。<br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> dp[maxn], dp1[maxn];</div><div class="line"><span class="keyword">int</span> data[maxn];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; data[i];</div><div class="line">    &#125;</div><div class="line">    dp[n - <span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//以i开始的上升子序列的长度</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (data[i] &lt; data[i + <span class="number">1</span>])</div><div class="line">            dp[i] = dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            dp[i] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    dp1[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)<span class="comment">//以i结尾的上升子序列的长度</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (data[i]&gt;data[i - <span class="number">1</span>])</div><div class="line">            dp1[i] = dp1[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            dp1[i] = <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>, m = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            m = dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            m = dp1[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data[i - <span class="number">1</span>] + <span class="number">1</span> &lt; data[i + <span class="number">1</span>])</div><div class="line">        &#123;</div><div class="line">            m = dp1[i - <span class="number">1</span>] + dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            m = max(dp[i + <span class="number">1</span>] + <span class="number">1</span>, dp1[i - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (m &gt; ret)</div><div class="line">            ret = m;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>5.创造新世界</strong><br><div class="note default"><p>众所周知计算机代码底层计算都是0和1的计算，牛牛知道这点之后就想使用0和1创造一个新世界！牛牛现在手里有n个0和m个1，给出牛牛可以创造的x种物品，每种物品都由一个01串表示。牛牛想知道当前手中的0和1可以最多创造出多少种物品。<br><em>输入描述</em><br>输入数据包括x+1行：<br>第一行包括三个整数x(2 ≤ x ≤ 20)，n(0 ≤ n ≤ 500)，m(0 ≤ m ≤ 500)，以空格分隔<br>接下来的x行，每行一个01串item[i]，表示第i个物品。每个物品的长度length(1 ≤ length ≤ 50)<br><em>输出描述</em><br>输出一个整数，表示牛牛最多能创造多少种物品  </p>
</div><br>分析：<br>典型的二维背包问题：<br>对于每件物品,当选择这件物品必须同时付出两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。<br>设第i件物品所需的两种代价分别为<code>a[i]</code>和<code>b[i]</code>，两种代价可付出的最大值（两种背包容量）分别为u和v。物品的价值为<code>w[i]</code>。状态转移方程：<br><code>dp[i][u][v] = max(dp[i-1][u][v] , w[i] + dp[i-1][u-a[i]][v-b[i]])</code><br>同样的进行空间压缩，我们可以得到二维数组的状态转移方程，u，v采用倒序，如下：
<code>dp[u][v] = max(dp[u-a[i]][v-b[i]]+w[i],dp[u][v])</code><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s_item</div><div class="line">&#123;</div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    <span class="keyword">int</span> _zero;</div><div class="line">    <span class="keyword">int</span> _one;</div><div class="line">    s_item()&#123; _zero = <span class="number">0</span>; _one = <span class="number">0</span>; str = <span class="string">""</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution_CreateWorld</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    s_item item[<span class="number">25</span>];</div><div class="line">    <span class="keyword">int</span> x, n, m;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; n &gt;&gt; m;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; item[i].str;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; item[i].str.size(); ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (item[i].str[j] == <span class="string">'0'</span>)</div><div class="line">                ++item[i]._zero;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item[i].str[j] == <span class="string">'1'</span>)</div><div class="line">                ++item[i]._one;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</div><div class="line">        &#123;</div><div class="line">            dp[i][j] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= item[i]._zero; --j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = m; k &gt;= item[i]._one; --k)</div><div class="line">            &#123;</div><div class="line">                dp[j][k] = max(dp[j - item[i]._zero][k - item[i]._one] + <span class="number">1</span>, dp[j][k]);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>6.优美的回文串</strong><br><div class="note info"><p>牛牛在书上看到一种字符串叫做回文串,当一个字符串从左到右和从右到左读都是一样的,就称这个字符串为回文串。牛牛又从好朋友羊羊那里了解到一种被称为优美的回文串的字符串,考虑一个长度为N只包含大写字母的字符串,写出它所有长度为M的连续子串(包含所有可能的起始位置的子串,相同的子串也要计入),如果这个字符串至少有K个子串都是回文串,我们就叫这个字符串为优美的回文串。现在给出一个N,牛牛希望你能帮他计算出长度为N的字符串有多少个是优美的回文串(每个位置都可以是’A’~’Z’的一个。)<br><em>输入描述:</em><br>输入数据包括三个整数N, M, K(2 ≤ N ≤ 11, 2 ≤ M ≤ N, 0 ≤ K ≤ 11).<br><em>输出描述:</em><br>输出一个整数,表示所求的字符串个数.<br><em>输入例子:</em><br>2 2 1<br><em>输出例子:</em><br>26 长度为2的字符串,它长度为2的子串只有它自身。长度为2的回文串有”AA”,”BB”,”CC”…”ZZ”,一共26种。  </p>
</div>
<a href="http://blog.csdn.net/scruelt/article/details/65940130?locationNum=1&amp;fps=1">参考</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客网上的2017年校招全国统一模拟试题的编程题目，比较难的一些题目汇总，做下记录。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读3：定时器</title>
    <link href="http://abumaster.com/2017/08/01/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://abumaster.com/2017/08/01/libev源码阅读3：定时器/</id>
    <published>2017-08-01T06:51:24.000Z</published>
    <updated>2017-08-01T13:12:55.814Z</updated>
    
    <content type="html"><![CDATA[<p>定时器作为libev的一个重要监测器，用于超时处理和周期执行任务，通过4叉最小堆管理定时器，据说高效利用CPU缓存。  </p>
<a id="more"></a>
<h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><p>堆是一种树形结构，分为最大堆和最小堆，分别是根节点是最大元素或最小元素，stl中利用二叉大顶堆实现优先级队列以及堆算法。<br>堆的节点一般存放在数组中，在数组的排列有一定的规律，堆没有节点漏洞，按层依次排列的，如堆是从数组array的索引为1的位置开始排列，那么某个节点位于i的位置，其左孩子位于2i处，右孩子位于2i+1处，父节点位于i/2处（/ 为取整）。从0开始排列，节点i的左右孩子节点的索引分别为2i+1，2i+2，父节点为(i-1)/2 。n叉堆的孩子[ni+1,…,ni+n]<br>对于堆的调整，一般用到向上调整和向下调整两种方式，下面结合代码详细注释。  </p>
<h4 id="四叉堆"><a href="#四叉堆" class="headerlink" title="四叉堆"></a>四叉堆</h4><p>libev中的四叉堆的根节点索引是3，从3开始依次向后排列，那么i节点的孩子的范围为[4(i-3)+1+3,…,4(i-3)+4+3]，父节点为(i-3-1)/4+3 。<br>堆元素的结构
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用缓存的情况下</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ev_tstamp at;</div><div class="line">    WT w;</div><div class="line">  &#125; ANHE;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_w(he)        (he).w     <span class="comment">/* access watcher, read-write */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_at(he)       (he).at    <span class="comment">/* access cached at, read-only */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_at_cache(he) (he).at = (he).w-&gt;at <span class="comment">/* update at from watcher */</span></span></div></pre></td></tr></table></figure></p>
<p>堆算法实现如下：<br><strong>downheap 函数：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_4HEAP <span class="comment">//如果定义了4叉堆</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DHEAP 4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP0 (DHEAP - 1) <span class="comment">/* index of first element in heap */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HPARENT(k) ((((k) - HEAP0 - 1) / DHEAP) + HEAP0) <span class="comment">//获得k的父节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UPHEAP_DONE(p,k) ((p) == (k)) <span class="comment">//是否更新完成</span></span></div><div class="line"></div><div class="line"><span class="comment">//从根向下调整，N为堆的元素个数，k表示要调整元素的索引</span></div><div class="line"><span class="function">inline_speed <span class="keyword">void</span></div><div class="line"><span class="title">downheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">    ANHE he = heap [k];<span class="comment">//先获得调整</span></div><div class="line">    ANHE *E = heap + N + HEAP0;<span class="comment">//结束的指针</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">        ev_tstamp minat; <span class="comment">//最小的元素</span></div><div class="line">        ANHE *minpos; <span class="comment">//最小元素的指针</span></div><div class="line">        ANHE *pos = heap + DHEAP * (k - HEAP0) + HEAP0 + <span class="number">1</span>;<span class="comment">//k的第一个孩子的指针</span></div><div class="line"></div><div class="line">        <span class="comment">//查找k的最小孩子</span></div><div class="line">        <span class="keyword">if</span> (expect_true (pos + DHEAP - <span class="number">1</span> &lt; E))<span class="comment">//最后一个孩子没有越界，有四个孩子</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在四个孩子中找最小的</span></div><div class="line">            (minpos = pos + <span class="number">0</span>), (minat = ANHE_at (*minpos));<span class="comment">//设置初值</span></div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">1</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">1</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">2</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">2</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">3</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">3</span>), (minat = ANHE_at (*minpos));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; E)<span class="comment">//有孩子，但是不是4个孩子</span></div><div class="line">        &#123;</div><div class="line">            (minpos = pos + <span class="number">0</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">1</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">1</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">1</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">2</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">2</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">2</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">3</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">3</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">3</span>), (minat = ANHE_at (*minpos));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="comment">//其他情况，没孩子，不用调整退出循环</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//当前节点小于最小孩子，已经是最小堆，不用调整退出</span></div><div class="line">        <span class="keyword">if</span> (ANHE_at (he) &lt;= minat)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//否则将最小元素调到k的位置</span></div><div class="line">        heap [k] = *minpos;</div><div class="line">        ev_active (ANHE_w (*minpos)) = k;<span class="comment">//将时间监测器设置为索引k</span></div><div class="line"></div><div class="line">        k = minpos - heap;<span class="comment">//设置下一次调整的根节点</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    heap [k] = he;<span class="comment">//将元素填充到k中</span></div><div class="line">    ev_active (ANHE_w (he)) = k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有定义四叉堆的宏，那么就是简单的二叉堆的定义和调整。<br><strong>upheap 函数：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从k向根调整</span></div><div class="line"><span class="function">inline_speed <span class="keyword">void</span></div><div class="line"><span class="title">upheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">    ANHE he = heap [k];<span class="comment">//先记录k位置的元素</span></div><div class="line">    <span class="comment">//循环调整</span></div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> p = HPARENT (k);<span class="comment">//获得k的父节点</span></div><div class="line">        <span class="comment">//是否等于父节点（调整完成）或者父节点的元素小于当前的</span></div><div class="line">        <span class="keyword">if</span> (UPHEAP_DONE (p, k) || ANHE_at (heap [p]) &lt;= ANHE_at (he))</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        heap [k] = heap [p];<span class="comment">//</span></div><div class="line">        ev_active (ANHE_w (heap [k])) = k;</div><div class="line">        k = p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  heap [k] = he;</div><div class="line">  ev_active (ANHE_w (he)) = k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>adjust 和 reheap 函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* move an element suitably so it is in a correct place */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span></div><div class="line"><span class="title">adjustheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (k &gt; HEAP0 &amp;&amp; ANHE_at (heap [k]) &lt;= ANHE_at (heap [HPARENT (k)]))</div><div class="line">    upheap (heap, k);<span class="comment">//k的元素小于父节点的元素，向上调整</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    downheap (heap, N, k);<span class="comment">//向下调整</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* rebuild the heap: this function is used only once and executed rarely */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span></div><div class="line"><span class="title">reheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">  <span class="comment">/* we don't use floyds algorithm, upheap is simpler and is more cache-efficient */</span></div><div class="line">  <span class="comment">/* also, this is easy to implement and correct for both 2-heaps and 4-heaps */</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i)<span class="comment">//直接向上调整，简单高效</span></div><div class="line">    upheap (heap, i + HEAP0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="超时监视器"><a href="#超时监视器" class="headerlink" title="超时监视器"></a>超时监视器</h4><p><strong>基本数据结构</strong><br>相对时间。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_timer</div><div class="line">&#123;</div><div class="line">    <span class="comment">//EV_WATCHER_TIME (ev_timer)</span></div><div class="line">    <span class="keyword">int</span> active;   </div><div class="line">    <span class="keyword">int</span> pending;  </div><div class="line">    <span class="keyword">int</span> priority;  </div><div class="line">    <span class="keyword">void</span> *data;  </div><div class="line">    <span class="keyword">void</span> (*cb)(<span class="keyword">struct</span> ev_loop *loop, <span class="keyword">struct</span> ev_timer *w, <span class="keyword">int</span> revents);    </div><div class="line">  </div><div class="line">    ev_tstamp at; <span class="comment">//定时器第一次触发的时间点</span></div><div class="line">    ev_tstamp repeat; <span class="comment">/* rw */</span> <span class="comment">//每隔几秒触发一次，0表示只触发一次</span></div><div class="line">&#125; ev_timer;</div></pre></td></tr></table></figure></p>
<p><strong>初始化超时监视器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化，调用两个宏来初始化成员</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_timer_init(ev,cb,after,repeat) \</div><div class="line">do &#123; ev_init ((ev), (cb)); \</div><div class="line">    ev_timer_set ((ev),(after),(repeat)); \</div><div class="line">    &#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_init(ev,cb_) do &#123;            \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;active  =   \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;pending = 0;    \</div><div class="line">  ev_set_priority ((ev), 0);            \</div><div class="line">  ev_set_cb ((ev), cb_);            \</div><div class="line">&#125; while (0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_timer_set(ev,after_,repeat_)      \</div><div class="line">do &#123; ((ev_watcher_time *)(ev))-&gt;at = (after_); \</div><div class="line">    (ev)-&gt;repeat = (repeat_); &#125; while (0)</span></div></pre></td></tr></table></figure></p>
<p><strong>启动超时器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">noinline</div><div class="line"><span class="keyword">void</span></div><div class="line"><span class="title">ev_timer_start</span> <span class="params">(EV_P_ ev_timer *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (expect_false (ev_is_active (w)))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    ev_at (w) += mn_now;<span class="comment">//设置at时间点，此时间点触发，相对于mn_now，当前日历时间</span></div><div class="line"></div><div class="line">    assert ((<span class="string">"libev: ev_timer_start called with negative timer repeat value"</span>, w-&gt;repeat &gt;= <span class="number">0.</span>));</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">    <span class="comment">//将timer加入到堆中并向上调整，active表示的是堆数组中的下标</span></div><div class="line">    ++timercnt;</div><div class="line">    ev_start (EV_A_ (W)w, timercnt + HEAP0 - <span class="number">1</span>);</div><div class="line">    array_needsize (ANHE, timers, timermax, ev_active (w) + <span class="number">1</span>, EMPTY2);</div><div class="line">    ANHE_w (timers [ev_active (w)]) = (WT)w;</div><div class="line">    ANHE_at_cache (timers [ev_active (w)]);</div><div class="line">    upheap (timers, ev_active (w));</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">    <span class="comment">/*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>停止计时器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">noinline</div><div class="line"><span class="keyword">void</span></div><div class="line"><span class="title">ev_timer_stop</span> <span class="params">(EV_P_ ev_timer *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    clear_pending (EV_A_ (W)w);<span class="comment">//从pending中移除</span></div><div class="line">    <span class="keyword">if</span> (expect_false (!ev_is_active (w)))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> active = ev_active (w);<span class="comment">//获得定时器在堆中的索引</span></div><div class="line">        assert ((<span class="string">"libev: internal timer heap corruption"</span>, ANHE_w (timers [active]) == (WT)w));</div><div class="line">        --timercnt;<span class="comment">//数量减一</span></div><div class="line">        <span class="keyword">if</span> (expect_true (active &lt; timercnt + HEAP0))</div><div class="line">        &#123;</div><div class="line">            timers [active] = timers [timercnt + HEAP0];<span class="comment">//最后一个元素补充上来</span></div><div class="line">            adjustheap (timers, timercnt, active);<span class="comment">//调整</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ev_at (w) -= mn_now;</div><div class="line">    ev_stop (EV_A_ (W)w);</div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="周期定时器"><a href="#周期定时器" class="headerlink" title="周期定时器"></a>周期定时器</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时器作为libev的一个重要监测器，用于超时处理和周期执行任务，通过4叉最小堆管理定时器，据说高效利用CPU缓存。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读2：运行流程</title>
    <link href="http://abumaster.com/2017/07/31/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/07/31/libev源码阅读2：运行流程/</id>
    <published>2017-07-31T10:39:49.000Z</published>
    <updated>2017-07-31T13:38:14.246Z</updated>
    
    <content type="html"><![CDATA[<p>一般的流程：创建默认的事件循环，创建一个事件监测器和回调函数并初始化（init），将监测器放入事件循环（start）中，循环开始等待事件（run）的到来。<br><a id="more"></a></p>
<p><strong>1.主要流程</strong><br>如果在libev中创建一个IO监测器，主循环等待IO事件的触发，触发后调用回调函数，执行相关操作。其主要流程如下：  </p>
<ul>
<li>首先调用<code>ev_default_loop</code>初始化<code>struct  ev_loop</code>结构；  </li>
<li>然后调用<code>ev_io_init</code>初始化监视器中的属性，该宏主要就是调用<code>ev_init</code>和<code>ev_io_set</code>；  </li>
<li>然后调用<code>ev_io_start</code>启动该监视器，该函数主要是将监视器添加到<code>loop-&gt;anfds</code>结构中，将监视的描述符添加到<code>((loop)-&gt;fdchanges)</code>中；</li>
<li>调用<code>ev_run</code>开始等待事件的触发。</li>
</ul>
<p>使用，官方提供的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a single header file is required</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ev.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // for puts</span></span></div><div class="line"><span class="comment">// every watcher type has its own typedef'd struct</span></div><div class="line"><span class="comment">// with the name ev_TYPE</span></div><div class="line">ev_io stdin_watcher;</div><div class="line">ev_timer timeout_watcher;</div><div class="line"><span class="comment">// all watcher callbacks have a similar signature</span></div><div class="line"><span class="comment">// this callback is called when data is readable on stdin</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">stdin_cb</span> <span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="built_in">puts</span> (<span class="string">"stdin ready"</span>);</div><div class="line">  <span class="comment">// for one-shot events, one must manually stop the watcher</span></div><div class="line">  <span class="comment">// with its corresponding stop function.</span></div><div class="line">  ev_io_stop (EV_A_ w);</div><div class="line">  <span class="comment">// this causes all nested ev_run's to stop iterating</span></div><div class="line">  ev_break (EV_A_ EVBREAK_ALL);</div><div class="line">&#125;</div><div class="line"><span class="comment">// another callback, this time for a time-out</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">timeout_cb</span> <span class="params">(EV_P_ ev_timer *w, <span class="keyword">int</span> revents)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="built_in">puts</span> (<span class="string">"timeout"</span>);</div><div class="line">  <span class="comment">// this causes the innermost ev_run to stop iterating</span></div><div class="line">  ev_break (EV_A_ EVBREAK_ONE);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="comment">// use the default event loop unless you have special needs</span></div><div class="line">  <span class="keyword">struct</span> ev_loop *loop = EV_DEFAULT;</div><div class="line">  <span class="comment">// initialise an io watcher, then start it</span></div><div class="line">  <span class="comment">// this one will watch for stdin to become readable</span></div><div class="line">  ev_io_init (&amp;stdin_watcher, stdin_cb, <span class="comment">/*STDIN_FILENO*/</span> <span class="number">0</span>, EV_READ);</div><div class="line">  ev_io_start (loop, &amp;stdin_watcher);</div><div class="line">  <span class="comment">// initialise a timer watcher, then start it</span></div><div class="line">  <span class="comment">// simple non-repeating 5.5 second timeout</span></div><div class="line">  ev_timer_init (&amp;timeout_watcher, timeout_cb, <span class="number">5.5</span>, <span class="number">0.</span>);</div><div class="line">  ev_timer_start (loop, &amp;timeout_watcher);</div><div class="line">  <span class="comment">// now wait for events to arrive</span></div><div class="line">  ev_run (loop, <span class="number">0</span>);</div><div class="line">  <span class="comment">// break was called, so exit</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中有几个奇怪的宏<code>EV_P EV_P_ EV_A EV_A_</code>，它们代表了：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EV_P  == <span class="keyword">struct</span> ev_loop* loop <span class="comment">//event parameter</span></div><div class="line">EV_P_ == EV_P, == <span class="keyword">struct</span> ev_loop* loop, </div><div class="line">EV_A  == loop <span class="comment">//event argument</span></div><div class="line">EV_A_ == EV_A, == loop,</div></pre></td></tr></table></figure></p>
<p><strong>2.ev_default_loop 函数</strong><br>假设定义了EV_MULTIPLICITY，多循环支持，返回一个ev_loop结构指针，否则返回一个整数。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> ev_loop * <span class="title">ev_default_loop</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (!ev_default_loop_ptr)</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_MULTIPLICITY</span></div><div class="line">      EV_P = ev_default_loop_ptr = &amp;default_loop_struct;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">      ev_default_loop_ptr = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//调用此函数初始化</span></div><div class="line">    loop_init (EV_A_ flags);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ev_backend (EV_A))</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_CHILD_ENABLE</span></div><div class="line">          ev_signal_init (&amp;childev, childcb, SIGCHLD);</div><div class="line">          ev_set_priority (&amp;childev, EV_MAXPRI);</div><div class="line">          ev_signal_start (EV_A_ &amp;childev);</div><div class="line">          ev_unref (EV_A); <span class="comment">/* child watcher should not keep loop alive */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ev_default_loop_ptr = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> ev_default_loop_ptr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以下是loop_init函数，初始化loop中的各个成员</span></div><div class="line"><span class="comment">/* initialise a loop structure, must be zero-initialised */</span></div><div class="line"><span class="function">noinline ecb_cold</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">loop_init</span> <span class="params">(EV_P_ <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (!backend)</div><div class="line">    &#123;</div><div class="line">        origflags = flags;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_REALTIME</span></div><div class="line">        <span class="keyword">if</span> (!have_realtime)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">struct</span> timespec ts;</div><div class="line">            <span class="keyword">if</span> (!clock_gettime (CLOCK_REALTIME, &amp;ts))</div><div class="line">                have_realtime = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_MONOTONIC</span></div><div class="line">        <span class="keyword">if</span> (!have_monotonic)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">struct</span> timespec ts;</div><div class="line">            <span class="keyword">if</span> (!clock_gettime (CLOCK_MONOTONIC, &amp;ts))</div><div class="line">                have_monotonic = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></div><div class="line">        <span class="keyword">if</span> (flags &amp; EVFLAG_FORKCHECK)</div><div class="line">            curpid = getpid ();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(flags &amp; EVFLAG_NOENV)</div><div class="line">          &amp;&amp; !enable_secure ()</div><div class="line">          &amp;&amp; getenv (<span class="string">"LIBEV_FLAGS"</span>))</div><div class="line">            flags = atoi (getenv (<span class="string">"LIBEV_FLAGS"</span>));</div><div class="line"></div><div class="line">        ev_rt_now          = ev_time ();</div><div class="line">        mn_now             = get_clock ();</div><div class="line">        now_floor          = mn_now;</div><div class="line">        rtmn_diff          = ev_rt_now - mn_now;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">        invoke_cb          = ev_invoke_pending;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        io_blocktime       = <span class="number">0.</span>;</div><div class="line">        timeout_blocktime  = <span class="number">0.</span>;</div><div class="line">        backend            = <span class="number">0</span>;</div><div class="line">        backend_fd         = <span class="number">-1</span>;</div><div class="line">        sig_pending        = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_ASYNC_ENABLE</span></div><div class="line">        async_pending      = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        pipe_write_skipped = <span class="number">0</span>;</div><div class="line">        pipe_write_wanted  = <span class="number">0</span>;</div><div class="line">        evpipe [<span class="number">0</span>]         = <span class="number">-1</span>;</div><div class="line">        evpipe [<span class="number">1</span>]         = <span class="number">-1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_INOTIFY</span></div><div class="line">        fs_fd              = flags &amp; EVFLAG_NOINOTIFY ? <span class="number">-1</span> : <span class="number">-2</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_SIGNALFD</span></div><div class="line">        sigfd              = flags &amp; EVFLAG_SIGNALFD  ? <span class="number">-2</span> : <span class="number">-1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(flags &amp; EVBACKEND_MASK))</div><div class="line">            flags |= ev_recommended_backends ();</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_IOCP</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_IOCP  )) backend = iocp_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_PORT</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_PORT  )) backend = port_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_KQUEUE</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_KQUEUE)) backend = kqueue_init (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_EPOLL</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_EPOLL )) backend = epoll_init  (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_POLL</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_POLL  )) backend = poll_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_SELECT</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_SELECT)) backend = select_init (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="comment">//如上一章介绍的函数，初始化调用前事件，准备好了，其实什么也没做</span></div><div class="line">        <span class="comment">//表示在此期间等待监测器到来</span></div><div class="line">        ev_prepare_init (&amp;pending_w, pendingcb);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE</span></div><div class="line">        ev_init (&amp;pipe_w, pipecb);<span class="comment">//初始化监测器的pipe</span></div><div class="line">        ev_set_priority (&amp;pipe_w, EV_MAXPRI);<span class="comment">//设置为最大优先级</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.ev_io_init 函数</strong><br>初始化io监测器，初始化结构中的成员，上一节中介绍了。<br><strong>4.ev_io_start 函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_io_start</span> <span class="params">(EV_P_ ev_io *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">int</span> fd = w-&gt;fd;<span class="comment">//获得监视器的描述符</span></div><div class="line">  <span class="comment">//监视器没开始</span></div><div class="line">  <span class="keyword">if</span> (expect_false (ev_is_active (w)))</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with negative fd"</span>, fd &gt;= <span class="number">0</span>));</div><div class="line">  <span class="comment">//屏蔽其他的</span></div><div class="line">  <span class="comment">//0x80 0x01 0x02 events的取值</span></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with illegal event mask"</span>, !(w-&gt;events &amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));</div><div class="line"></div><div class="line">  EV_FREQUENT_CHECK;</div><div class="line">  <span class="comment">//调整优先级并设置为活动状态，</span></div><div class="line">  ev_start (EV_A_ (W)w, <span class="number">1</span>);</div><div class="line">  <span class="comment">//调整loop-&gt;anfds数组的大小，并将监测器加入到[fd]的链表中</span></div><div class="line">  array_needsize (ANFD, anfds, anfdmax, fd + <span class="number">1</span>, array_init_zero);</div><div class="line">  wlist_add (&amp;anfds[fd].head, (WL)w);</div><div class="line"></div><div class="line">  <span class="comment">/* common bug, apparently */</span></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with corrupted watcher"</span>, ((WL)w)-&gt;next != (WL)w));</div><div class="line"></div><div class="line">  fd_change (EV_A_ fd, w-&gt;events &amp; EV__IOFDSET | EV_ANFD_REIFY);</div><div class="line">  w-&gt;events &amp;= ~EV__IOFDSET;<span class="comment">//掩码消除</span></div><div class="line">  EV_FREQUENT_CHECK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//fd_change函数</span></div><div class="line"><span class="comment">/* something about the given fd changed */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span> <span class="title">fd_change</span> <span class="params">(EV_P_ <span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> reify = anfds [fd].reify;</div><div class="line">  anfds [fd].reify |= flags;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (expect_true (!reify))<span class="comment">//以前不存在，调整大小加入变化数组中</span></div><div class="line">    &#123;</div><div class="line">      ++fdchangecnt;</div><div class="line">      array_needsize (<span class="keyword">int</span>, fdchanges, fdchangemax, fdchangecnt, EMPTY2);</div><div class="line">      fdchanges [fdchangecnt - <span class="number">1</span>] = fd;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.ev_run 函数</strong><br>主要功能循环等待事件的到来。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ev_run</span> <span class="params">(EV_P_ <span class="keyword">int</span> flags)</span></div><div class="line"></span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">  ++loop_depth;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  assert ((<span class="string">"libev: ev_loop recursion during release detected"</span>, loop_done != EVBREAK_RECURSE));</div><div class="line">  loop_done = EVBREAK_CANCEL;</div><div class="line"></div><div class="line">  EV_INVOKE_PENDING; <span class="comment">/* in case we recurse, ensure ordering stays nice and clean */</span></div><div class="line"></div><div class="line">  <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_VERIFY &gt;= 2</span></div><div class="line">      ev_verify (EV_A);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></div><div class="line">      <span class="keyword">if</span> (expect_false (curpid)) <span class="comment">/* penalise the forking check even more */</span></div><div class="line">        <span class="keyword">if</span> (expect_false (getpid () != curpid))</div><div class="line">          &#123;</div><div class="line">            curpid = getpid ();</div><div class="line">            postfork = <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FORK_ENABLE</span></div><div class="line">      <span class="comment">/* we might have forked, so queue fork handlers */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (postfork))</div><div class="line">        <span class="keyword">if</span> (forkcnt)</div><div class="line">          &#123;</div><div class="line">            queue_events (EV_A_ (W *)forks, forkcnt, EV_FORK);</div><div class="line">            EV_INVOKE_PENDING;</div><div class="line">          &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PREPARE_ENABLE</span></div><div class="line">      <span class="comment">/* queue prepare watchers (and execute them) */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (preparecnt))</div><div class="line">        &#123;</div><div class="line">          queue_events (EV_A_ (W *)prepares, preparecnt, EV_PREPARE);</div><div class="line">          EV_INVOKE_PENDING;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (expect_false (loop_done))</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* we might have forked, so reify kernel state if necessary */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (postfork))</div><div class="line">        loop_fork (EV_A);</div><div class="line"></div><div class="line">      <span class="comment">//检测fd</span></div><div class="line">      fd_reify (EV_A);</div><div class="line"></div><div class="line">      <span class="comment">/* 计算阻塞的时间 */</span></div><div class="line">      &#123;</div><div class="line">        ev_tstamp waittime  = <span class="number">0.</span>;</div><div class="line">        ev_tstamp sleeptime = <span class="number">0.</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* remember old timestamp for io_blocktime calculation */</span></div><div class="line">        ev_tstamp prev_mn_now = mn_now;</div><div class="line"></div><div class="line">        <span class="comment">/* update time to cancel out callback processing overhead */</span></div><div class="line">        time_update (EV_A_ <span class="number">1e100</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* from now on, we want a pipe-wake-up */</span></div><div class="line">        pipe_write_wanted = <span class="number">1</span>;</div><div class="line"></div><div class="line">        ECB_MEMORY_FENCE; <span class="comment">/* make sure pipe_write_wanted is visible before we check for potential skips */</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (expect_true (!(flags &amp; EVRUN_NOWAIT || idleall || !activecnt || pipe_write_skipped)))</div><div class="line">          &#123;</div><div class="line">            waittime = MAX_BLOCKTIME;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timercnt)</div><div class="line">              &#123;</div><div class="line">                ev_tstamp to = ANHE_at (timers [HEAP0]) - mn_now;</div><div class="line">                <span class="keyword">if</span> (waittime &gt; to) waittime = to;</div><div class="line">              &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PERIODIC_ENABLE</span></div><div class="line">            <span class="keyword">if</span> (periodiccnt)</div><div class="line">              &#123;</div><div class="line">                ev_tstamp to = ANHE_at (periodics [HEAP0]) - ev_rt_now;</div><div class="line">                <span class="keyword">if</span> (waittime &gt; to) waittime = to;</div><div class="line">              &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">            <span class="comment">/* don't let timeouts decrease the waittime below timeout_blocktime */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (waittime &lt; timeout_blocktime))</div><div class="line">              waittime = timeout_blocktime;</div><div class="line"></div><div class="line">            <span class="comment">/* at this point, we NEED to wait, so we have to ensure */</span></div><div class="line">            <span class="comment">/* to pass a minimum nonzero value to the backend */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (waittime &lt; backend_mintime))</div><div class="line">              waittime = backend_mintime;</div><div class="line"></div><div class="line">            <span class="comment">/* extra check because io_blocktime is commonly 0 */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (io_blocktime))</div><div class="line">              &#123;</div><div class="line">                sleeptime = io_blocktime - (mn_now - prev_mn_now);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (sleeptime &gt; waittime - backend_mintime)</div><div class="line">                  sleeptime = waittime - backend_mintime;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (expect_true (sleeptime &gt; <span class="number">0.</span>))</div><div class="line">                  &#123;</div><div class="line">                    ev_sleep (sleeptime);</div><div class="line">                    waittime -= sleeptime;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">        ++loop_count;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        assert ((loop_done = EVBREAK_RECURSE, <span class="number">1</span>)); <span class="comment">/* assert for side effect */</span></div><div class="line">        backend_poll (EV_A_ waittime);</div><div class="line">        assert ((loop_done = EVBREAK_CANCEL, <span class="number">1</span>)); <span class="comment">/* assert for side effect */</span></div><div class="line"></div><div class="line">        pipe_write_wanted = <span class="number">0</span>; <span class="comment">/* just an optimisation, no fence needed */</span></div><div class="line"></div><div class="line">        ECB_MEMORY_FENCE_ACQUIRE;</div><div class="line">        <span class="keyword">if</span> (pipe_write_skipped)</div><div class="line">          &#123;</div><div class="line">            assert ((<span class="string">"libev: pipe_w not active, but pipe not written"</span>, ev_is_active (&amp;pipe_w)));</div><div class="line">            ev_feed_event (EV_A_ &amp;pipe_w, EV_CUSTOM);</div><div class="line">          &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* update ev_rt_now, do magic */</span></div><div class="line">        time_update (EV_A_ waittime + sleeptime);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* queue pending timers and reschedule them */</span></div><div class="line">      timers_reify (EV_A); <span class="comment">/* relative timers called last */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PERIODIC_ENABLE</span></div><div class="line">      periodics_reify (EV_A); <span class="comment">/* absolute timers called first */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_IDLE_ENABLE</span></div><div class="line">      <span class="comment">/* queue idle watchers unless other events are pending */</span></div><div class="line">      idle_reify (EV_A);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_CHECK_ENABLE</span></div><div class="line">      <span class="comment">/* queue check watchers, to be executed first */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (checkcnt))</div><div class="line">        queue_events (EV_A_ (W *)checks, checkcnt, EV_CHECK);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">      EV_INVOKE_PENDING;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">while</span> (expect_true (</div><div class="line">    activecnt</div><div class="line">    &amp;&amp; !loop_done</div><div class="line">    &amp;&amp; !(flags &amp; (EVRUN_ONCE | EVRUN_NOWAIT))</div><div class="line">  ));</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (loop_done == EVBREAK_ONE)</div><div class="line">    loop_done = EVBREAK_CANCEL;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">  --loop_depth;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> activecnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的流程：创建默认的事件循环，创建一个事件监测器和回调函数并初始化（init），将监测器放入事件循环（start）中，循环开始等待事件（run）的到来。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读1：数据结构</title>
    <link href="http://abumaster.com/2017/07/31/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/07/31/libev源码阅读1：数据结构/</id>
    <published>2017-07-31T02:08:24.000Z</published>
    <updated>2017-07-31T07:32:55.837Z</updated>
    
    <content type="html"><![CDATA[<p>libev 是一个高性能事件循环网络库，用于开发高性能网络应用。  </p>
<a id="more"></a>
<p><strong>1.基础宏定义</strong><br>libev中的监视器数据结构的实现是用宏定义以及结构体来实现继承关系，基本的宏定义，展开。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 所有的监视器共有的数据 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER(type)            \</div><div class="line">  int active; <span class="comment">/* private */</span>         \</div><div class="line">  int pending; <span class="comment">/* private */</span>            \</div><div class="line">  <span class="comment">//EV_DECL_PRIORITY /* private */        \</span></span></div><div class="line">  <span class="keyword">int</span> priority; \</div><div class="line">  <span class="comment">//EV_COMMON /* rw */                \</span></div><div class="line">  <span class="keyword">void</span> *data; \</div><div class="line">  <span class="comment">//EV_CB_DECLARE (type) /* private */</span></div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER_LIST(type)           \</div><div class="line">  EV_WATCHER (type)             \</div><div class="line">  struct ev_watcher_list *next; <span class="comment">/* private */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER_TIME(type)           \</div><div class="line">  EV_WATCHER (type)             \</div><div class="line">  ev_tstamp at;     <span class="comment">/* private */</span></span></div></pre></td></tr></table></figure></p>
<p><strong>2.监视器基类</strong><br>由上面的宏定义可以推断，libev的监视器的实现是从watcher，watcher_list和watcher_time三类中派生出去，分为这三个大类，三个基类。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本监视器 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">&#125; ev_watcher;</div><div class="line"><span class="comment">//监视器链表 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher_list</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="comment">//list的下一个节点</span></div><div class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</div><div class="line">&#125; ev_watcher_list;</div><div class="line"><span class="comment">//时间监视器 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher_time</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="comment">//计时器时间</span></div><div class="line">  ev_tstamp at;</div><div class="line">&#125; ev_watcher_time;</div></pre></td></tr></table></figure></p>
<p><strong>3.监视的事件</strong><br>libev从三个监视器基类中派生出以下几种类，用于监视事件的变化，主要的分类和作用如下：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ev_io</code></td>
<td>IO 可读可写</td>
</tr>
<tr>
<td><code>ev_singnal</code></td>
<td>信号处理</td>
</tr>
<tr>
<td><code>ev_timer</code></td>
<td>定时器</td>
</tr>
<tr>
<td><code>ev_periodic</code></td>
<td>周期任务</td>
</tr>
<tr>
<td><code>ev_child</code></td>
<td>子进程状态变化</td>
</tr>
<tr>
<td><code>ev_fork</code></td>
<td>开辟子进程</td>
</tr>
<tr>
<td><code>ev_stat</code></td>
<td>文件属性变化</td>
</tr>
<tr>
<td><code>ev_async</code></td>
<td>激活线程</td>
</tr>
<tr>
<td><code>ev_cleanup</code></td>
<td>退出触发</td>
</tr>
<tr>
<td><code>ev_idle</code></td>
<td>空闲时执行</td>
</tr>
<tr>
<td><code>ev_embed</code></td>
<td>嵌入其他事件循环</td>
</tr>
<tr>
<td><code>ev_prepare</code></td>
<td>eventloop之前</td>
</tr>
<tr>
<td><code>ev_check</code></td>
<td>eventloop之后</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//io监视器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_io</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER_LIST (ev_io) //展开宏</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> fd;     <span class="comment">/* ro */</span></div><div class="line">  <span class="keyword">int</span> events; <span class="comment">/* ro */</span></div><div class="line">&#125; ev_io;</div><div class="line"><span class="comment">//定时器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_timer</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER_TIME (ev_timer) //展开</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  ev_tstamp at;</div><div class="line"></div><div class="line">  ev_tstamp repeat; <span class="comment">/* rw */</span></div><div class="line">&#125; ev_timer;</div><div class="line"><span class="comment">//空闲时触发</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_idle</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER (ev_idle) 展开</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line"></div><div class="line">&#125; ev_idle;</div></pre></td></tr></table></figure>
<p>关系图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-31/44673487.jpg" alt=""><br>这种继承关系，可以用指针进行类型自由转换。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-31/72453924.jpg" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//激活监测器，不管是何类型</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_start</span> <span class="params">(<span class="keyword">struct</span> ev_loop *loop, ev_watcher* w, <span class="keyword">int</span> active)</span>  </div><div class="line"></span>&#123;  </div><div class="line">  <span class="comment">//...  </span></div><div class="line">  w-&gt;active = active;  </div><div class="line">  <span class="comment">//...  </span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">wlist_add</span> <span class="params">(ev_watcher_list **head, ev_watcher_list *elem)</span>  </div><div class="line"></span>&#123;  </div><div class="line">  elem-&gt;next = *head;  </div><div class="line">  *head = elem;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_io_start</span> <span class="params">(<span class="keyword">struct</span> ev_loop *loop, ev_io *w)</span>  </div><div class="line"></span>&#123;   </div><div class="line">  <span class="comment">//将ev_io退化为ev_watcher使用这个ev_start函数</span></div><div class="line">  ev_start (loop, (ev_watcher*)w, <span class="number">1</span>);  </div><div class="line">  <span class="comment">//转换成ev_watcher_list指针插入到list中</span></div><div class="line">  wlist_add (&amp;anfds[fd].head, (ev_watcher_list *)w);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.监视事件的初始化和设置</strong><br>ev的设置也被定义为宏macro，提供了两种方式：  </p>
<ul>
<li><code>ev_init</code> 和 <code>ev_TYPE_set</code> 一起使用；  </li>
<li>使用 <code>ev_TYPE_init</code> 进行初始化。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_init(ev,cb_) do &#123;            \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;active  =   \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;pending = 0;    \</div><div class="line">  ev_set_priority ((ev), 0);            \</div><div class="line">  ev_set_cb ((ev), cb_);            \</div><div class="line">&#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_io_set(ev,fd_,events_)  \</div><div class="line"> do &#123; (ev)-&gt;fd = (fd_); (ev)-&gt;events = (events_) | EV__IOFDSET; &#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_io_init(ev,cb,fd,events)   \</div><div class="line"> do &#123; ev_init ((ev), (cb)); \</div><div class="line">    ev_io_set ((ev),(fd),(events)); &#125; while (0)</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;libev 是一个高性能事件循环网络库，用于开发高性能网络应用。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-容器</title>
    <link href="http://abumaster.com/2017/07/19/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8/"/>
    <id>http://abumaster.com/2017/07/19/STL源码剖析-容器/</id>
    <published>2017-07-19T07:04:58.000Z</published>
    <updated>2017-08-18T06:41:03.766Z</updated>
    
    <content type="html"><![CDATA[<h4 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h4><p><em>容器</em> 用于存放数据，数据在其中的排列具有一定的规律。STL中根据数据的排列方式将容器分为了 <strong>序列式容器</strong> 和 <strong>关联式容器</strong> 两种。其中的分类关系如下图所示：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/20670842.jpg" alt=""><br><a id="more"></a></p>
<h4 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h4><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>vector连续线性空间存储，支持随机访问，类似数组。<br>vector的迭代器是一个T类型的原生指针；<br>vector的空间不是按需分配而是按照多分配的原则，比实际需要的空间要大，也就是说会保留一部分的备用空间用于插入元素，分别定义了三个迭代器指向了目前使用空间的头和尾，可用空间的尾。<code>start finish end_of_storage</code> 定义了函数 <code>size() 和 capacity</code> 分别表示使用空间的大小，以及最大容纳的大小；<br>vector的空间扩充，当没有足够的备用空间用于插入新的元素的时候，这时vecto需要进行空间的扩展，会申请一块原始大小二倍的新空间然后将旧的空间中的元素拷贝入新的空间，也就是说原始的迭代器在执行插入操作后会失效；<br>vector存在的缺点，就是可能浪费一部分空间。  </p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>list 在stl中的实现是一个双向链表，节点结构是有一个指向后一个节点和前一个节点的指针以及节点中的数据，每次插入和删除元素都要重新配置和释放节点，空间按需分配，插入操作不会改变迭代器。<br>list迭代器设计，内部依然是一个指针，指向了list的节点，内部定义了stl迭代器标准的接口，并实现了双向迭代器具有的操作，自增，自减，取值，比较等；<br>list数据结构，双向循环链表，一些操作就是链表的指针的移动；<br>一个内部函数<code>transfer(position, first, last)</code>将[first,last)内的元素移动到position之前。为splice、merge、sort提供基础。操作见图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/87239144.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (position != last) </div><div class="line">    &#123;</div><div class="line">        (*(link_type((*last.node).prev))).next = position.node; <span class="comment">// (1)</span></div><div class="line">        (*(link_type((*first.node).prev))).next = last.node; <span class="comment">// (2)</span></div><div class="line">        (*(link_type((*position.node).prev))).next = first.node; <span class="comment">// (3)</span></div><div class="line">        link_type tmp = link_type((*position.node).prev); <span class="comment">// (4)</span></div><div class="line">        (*position.node).prev = (*last.node).prev; <span class="comment">// (5)</span></div><div class="line">        (*last.node).prev = (*first.node).prev;  <span class="comment">// (6)</span></div><div class="line">        (*first.node).prev = tmp; <span class="comment">// (7)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>list 本身提供了排序的成员函数，不用stl算法（接受随机迭代器）。  </p>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>deque由一些列连续的空间组成，可以分别在头尾扩展插入。有一个中控器map指向连续的一段段的缓冲区。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/26926563.jpg" alt=""><br>deque的迭代器，包括了
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</div><div class="line">-----------------------------</div><div class="line">| cur | first | last | node |</div><div class="line">-----------------------------</div><div class="line">当前指向，缓冲区的开始和结束</div><div class="line">在map中的位置</div><div class="line">***/</span></div></pre></td></tr></table></figure></p>
<p>deque的数据结构，迭代器start指向第一个节点，finish指向最后一个节点，map指向中控器，是连续的空间，每个元素都是一个指针，指向了一个节点（缓冲区）。<br>在deque上进行元素操作时，考虑在中控器的移动。  </p>
<h5 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h5><p>stack先进后出，没有迭代器，queue先进先出，它们都是以deque为底部数据结构（默认），进行一定的限制保证它们各自的特性，不被称为容器，而是被称为配接器。  </p>
<h5 id="heap算法和优先级队列"><a href="#heap算法和优先级队列" class="headerlink" title="heap算法和优先级队列"></a>heap算法和优先级队列</h5><p>堆不是stl容器组件，但是却是优先级队列的底层实现。<br>它是一棵二叉树，根节点元素是最大或者最小元素，每次插入和取出根节点后都会重新排列保持它的这个特性。  </p>
<h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>主要有set集合和map映射表两种，底部以红黑二叉树实现。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;容器概述&quot;&gt;&lt;a href=&quot;#容器概述&quot; class=&quot;headerlink&quot; title=&quot;容器概述&quot;&gt;&lt;/a&gt;容器概述&lt;/h4&gt;&lt;p&gt;&lt;em&gt;容器&lt;/em&gt; 用于存放数据，数据在其中的排列具有一定的规律。STL中根据数据的排列方式将容器分为了 &lt;strong&gt;序列式容器&lt;/strong&gt; 和 &lt;strong&gt;关联式容器&lt;/strong&gt; 两种。其中的分类关系如下图所示：&lt;br&gt;&lt;img src=&quot;http://oo7zsi4t8.bkt.clouddn.com/17-7-29/20670842.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>像素反卷积网络</title>
    <link href="http://abumaster.com/2017/07/11/%E5%83%8F%E7%B4%A0%E5%8F%8D%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://abumaster.com/2017/07/11/像素反卷积网络/</id>
    <published>2017-07-11T07:30:10.000Z</published>
    <updated>2017-07-25T09:07:16.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Pixel Deconvolutional Networks Hongyang Gao etc. 2017.1.7 主要介绍了对于传统反卷积操作的新解读。读此论文，做如下笔记。  </p>
</blockquote>
<a id="more"></a>
<p><strong>1.引子</strong><br>反卷积层被广泛地应用在各种各样的深度模型中用于上采样，其中包括了用于语义分割的编码-解码网络、用于无监督学习的深度生成模型。反卷积层容易造成棋盘问题，使得输出的特征图的临近像素没有直接的关系。为了解决这个问题，提出了一种像素反卷积层，在输出特征图的临近像素之间建立一个直接的关系。是对反卷积操作的新的解读，因此可以取代任何的使用反卷积层的网络模型中的反卷积层。效率有所下降但是可以通过实现来解决。实验结果比较良好。  </p>
<p><strong>2.像素反卷积层</strong><br>新的层中的中间特征图是按照顺序生成，后面的特征图的生成依赖前面的。如此。<br>反卷积网络中的棋盘问题。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-24/77481511.jpg" alt=""><br>卷积层对输入特征图进行不同的卷积核卷积生成了中间特征图，然后上采样生成了输出特征图，其相邻的像素是没有直接联系的，因为是不同的卷积核操作生成的。<br>输入特征图Fin，输出特征图Fout，中间特征图的计算：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/57088763.jpg" alt=""><br>像素反卷积层，PixelDCL，改用了一种中间特征图的关联生成形式，生成了序列化的特征图，彼此依赖，如图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-24/26503601.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/92585659.jpg" alt=""><br>移除中间特征图和输入特征图之间的关联，因为，中间特征已经包含了输入特征图的信息，去掉不但可以提高计算效率，还能减小模型的参数。计算时只需第一个中间特征图依赖输入特征图，其他的中间特征图依赖前面计算过的特征图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/42661592.jpg" alt=""><br><strong>分析（ 4*4 的输入特征图，上采样为 8*8 的特征图）：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/85425689.jpg" alt=""><br>第一步：2*2的卷积核对输入特征进行卷积操作生成第一个中间特征图，紫色的；<br>第二步：对第一个中间特征进行卷积操作生成第二个中间特征；<br>第三步：扩展和组合前两个特征图，生成8*8的特征图；<br>第四步：对此特征图进行marked卷积，卷积核大小改为3，保持8的大小；<br>第五步：组合两个大小为8的特征图，生成最终的大小为8的输出特征图。  </p>
<p><a href="https://github.com/divelab/PixelDCN">源码地址</a>  </p>
<p><strong>3.结果</strong><br>在图像语义分割上的结果：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/55128940.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Pixel Deconvolutional Networks Hongyang Gao etc. 2017.1.7 主要介绍了对于传统反卷积操作的新解读。读此论文，做如下笔记。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>使用深度学习技术的图像语义分割最新综述</title>
    <link href="http://abumaster.com/2017/07/10/%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9B%BE%E5%83%8F%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E6%9C%80%E6%96%B0%E7%BB%BC%E8%BF%B0/"/>
    <id>http://abumaster.com/2017/07/10/使用深度学习技术的图像语义分割最新综述/</id>
    <published>2017-07-10T08:32:14.000Z</published>
    <updated>2017-07-29T06:58:05.506Z</updated>
    
    <content type="html"><![CDATA[<p>A Review on Deep Learning Techniques Applied to Semantic Segmentation [A. Garcia-Garcia, S. Orts-Escolano, S.O. Oprea, V. Villena-Martinez, and J. Garcia-Rodriguez] 2017年4月22  </p>
<a id="more"></a>
<div class="note sucess"><p>文章的主要贡献：  </p>
<ul>
<li>对现有用于图像语义分割的数据集的研究；  </li>
<li>深度有组织地对使用深度学习的图像语义分割重要算法它们的起源和贡献进行回顾；  </li>
<li>对它们的性能进行粗略的评估；  </li>
<li>对上述结果进行讨论，并对未来的研究方向进行探讨。  </li>
</ul>
</div>
<h4 id="术语和背景概念"><a href="#术语和背景概念" class="headerlink" title="术语和背景概念"></a>术语和背景概念</h4><p>图像语义分割不是一个孤立的领域，而是一个从粗略到精细的自然的推理过程：预测输入图像中物体的类别，如果多类物体则预测多个类别；定位不同类别物体的位置；为图像中的每一个像素分类（图像语义分割）；对同一类物体的不同物体进行区分（实例分割）。  </p>
<p><strong>数据预处理和增强</strong> 对于小的数据集，可以相应作出改变来增大数据集，往往会带来更好的效果。比如1500张图像的数据集可以缩放成不同的尺度，进行不同的旋转，进行不同的伽马变换，生成大数据集。  </p>
<h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-10/64022244.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-10/39234174.jpg" alt="">  </p>
<p>当前，大多数优秀的深度学习技术用于图像语义分割都来自一个共同的先导者：全卷积网络（Long），这种方法的优势就是利用当前存在的CNNs作为有力的视觉模型，可以学习分层特征。通过改变一些著名的分类网络：改变最后的全连接层为全卷积层，输出特征图来取代分类得分。这些特征图（空域图）通过分数阶卷积（也被称为反卷积）来产生稠密像素级标记的输出图。反卷积网络的工作是一个里程碑式的工作，因为它展示了如何用CNNs训练端对端来解决视觉问题，是深度学习用于图像语义分割的基石。<br><strong>缺陷</strong>：缺少不同特征的感知，阻碍了在具体问题和场景中的应用。固有的空间不变性，使它不能将全局的上下文信息考虑进去，默认不能感知实例，在高分辨率上不能达到实时的处理速度，不能适应无结构的数据，例如3-D点云和模型。<br>对于它的种种缺陷，不同的方法提供不同的改善方向和效果，主要分为以下几个方向。  </p>
<h5 id="解码变种"><a href="#解码变种" class="headerlink" title="解码变种"></a>解码变种</h5><p>这是一种具有两个组件的网络，分别包含了编码器（卷积网络）和解码器（反卷积网络）。与普通的全卷积网络不同之处在于对低分辨率的特征图的处理，通过一个解码网络的东西。<br>SegNet，解码阶段是由一系列的上采样和卷积层组成的，上采样对应了编码过程的最大池化。上采样过的特征图通过一组可以训练的卷积核进行卷积生成了稠密特征图。经过解码后的图像与原始输入图像具有了相同的分辨率，然后经过一层softmax层分类器产生最终的分割图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-26/13339329.jpg" alt="">  </p>
<h5 id="整合上下文信息"><a href="#整合上下文信息" class="headerlink" title="整合上下文信息"></a>整合上下文信息</h5><p><em>图像语义分割的一个问题就是需要整合不同空间尺度的信息</em>。这意味着局部信息和全局信息的平衡，一方面，细粒度或者局部信息对于获得良好的像素级预测精度是非常重要的，另一方面，整合全局上下文信息，可以解决分割图局部模糊性。传统的CNNs网络因为池化层的存在是不能感知全局信息的，有许多方法可以使CNNs感知全局信息，比如，使用条件随机场作为后续的处理，膨胀卷积，多尺度聚合，甚至将上下文模型推广到另一种深度网络中如RNNs。<br><strong>条件随机场</strong><br>解决上述的问题，一种可能的方法优化输出图，提高捕捉细节的能力，是用条件随机场作为后期处理。条件随机场（CRF）可以组合低层次的像素级别的信息，这些是CNN无法做到的，其中DeepLab应用了全连接的条件随机场作为分割图的后续处理，像素作为图的节点，建立全连接充分考虑了短程和远程的连接。另一个CRFasRNN，将条件随机场作为网络的一部分进行端对端的训练。  </p>
<blockquote>
<p>[1] Semantic image segmentation with deep convolutional nets and fully connected crfs<br>[2] Conditional random fields as recurrent neural networks</p>
</blockquote>
<p><strong>膨胀卷积</strong><br>也叫阿托斯卷积，通过增大卷积核的步伐来进行卷积操作，获得更宽的接受域。<br><strong>多尺度聚合</strong><br>首先[1]提出了将全卷积网络分为两个路径，图像分为原图和二倍图，分别放入浅层网络和全卷积网络，将全卷积网络的输出上采样结合浅层输出经过一系列的卷积的到最终的输出图。对尺度感知非常敏感？<br>[2]用了不同的思路，四个相同的网络，感知由粗糙到精细的尺度信息，如图，序列进行处理得到最终的输出。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-26/27217990.jpg" alt=""><br>[4]提出了n个全卷积网络的结构，分别对应处理不同的尺度，分为两个阶段学习：第一个分别独立训练，第二融合各网络的输出，得到最终的输出图。  </p>
<blockquote>
<p>[1] Multi-scale convolutional architecture for semantic segmentation<br>[2] A multi-scale cnn for affordance segmentation in rgb images<br>[3] Predicting depth, surface normals and semantic labels with a common multi-scale convolutional architecture<br>[4] Multiscale fully convolutional network with application to industrial inspection  </p>
</blockquote>
<p><strong>特征融合</strong><br>提取不同层的特征，包含了不同的局部上下文信息，将之融合。<br><strong>递归神经网络</strong>  </p>
<h5 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h5><p>实例分割是语义分割之后的一步，同时也是与其他低级像素分割技术相比最具有挑战性的问题。主要是将同类物品的不同实例区别开。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A Review on Deep Learning Techniques Applied to Semantic Segmentation [A. Garcia-Garcia, S. Orts-Escolano, S.O. Oprea, V. Villena-Martinez, and J. Garcia-Rodriguez] 2017年4月22  &lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>多线程库c++11</title>
    <link href="http://abumaster.com/2017/07/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%93c-11/"/>
    <id>http://abumaster.com/2017/07/09/多线程库c-11/</id>
    <published>2017-07-09T10:32:25.000Z</published>
    <updated>2017-07-10T13:48:30.784Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11 标准中的多线程库，包含了封装的thread类以及用于同步的mutex、atomic和条件变量。<br><a id="more"></a></p>
<h4 id="thread类"><a href="#thread类" class="headerlink" title="thread类"></a>thread类</h4><p>使用包含头文件<thread>，std::thread。<br><strong>构造函数</strong><br>常用的构造函数：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn, <span class="keyword">class</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span> <span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了线程执行函数，第二个可选的线程函数所需的参数。<br>为了控制线程同步，可以设置原子变量atomic类型的全局变量；或者传入一个原子变量参数的引用；或者使用一个成员变量。<a href="http://www.cplusplus.com/reference/thread/thread/thread/">例子</a>，参见cplusplus网站。<br>赋值运算符，可以直接移动分配，不拷贝。<br><strong>等待和独立运行</strong><br>创建线程后可以调用<code>join</code>来阻塞等待线程的结束，同样也提供了一个函数<code>joinable</code>来测试线程是否可以被join，如果想让线程独立于主线程后台运行可以调用<code>detach</code>，使线程分离出去在后台运行，这是测试能否被join则返回的是false，同样主线程也不能调用join来等待线程的结束。<br><strong>this_thread 类</strong><br>表示当前进程，提供了一组函数。  </p>
<ul>
<li><code>get_id</code> 返回一个<code>thread::id</code>类型，标识了当前线程的id。  </li>
<li><code>yield</code> 让步，为其他线程提供调用的机会。  </li>
<li><code>sleep_until</code> 阻塞直到设置的时间到了，绝对的时间。  </li>
<li><code>sleep_for</code> 阻塞到指定的时间，相对时间。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 11 标准中的多线程库，包含了封装的thread类以及用于同步的mutex、atomic和条件变量。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c语言中的struct-option结构</title>
    <link href="http://abumaster.com/2017/07/03/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84struct-option%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/07/03/c语言中的struct-option结构/</id>
    <published>2017-07-03T12:52:19.000Z</published>
    <updated>2017-07-03T13:27:20.575Z</updated>
    
    <content type="html"><![CDATA[<p>C语言知识拾遗，struct option 结构体。</p>
<a id="more"></a>
<p><code>struct option</code> 指明了一个长参数，在一些控制台程序中经常用到，需要指明不同的参数来运行程序。如开源软件<strong>webbench</strong>运行<code>./webbench -h</code>后会出现一些可选项，指定不同的参数，程序会做出不同的相应。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-3/68613055.jpg" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> option &#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//name表示的是长参数名</span></div><div class="line">	<span class="keyword">int</span> has_arg；</div><div class="line">	<span class="keyword">int</span> *flag;</div><div class="line">	<span class="keyword">int</span> val; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数说明：<br><em>name</em> 表示长参数的名称；<br><em>has_arg</em> 表示参数名称后面是否需要跟着参数，no_argument(0)不需要，required_argument(1)一定要跟个参数，optional_argument(2)可以有也可以没有；<br><em>flag</em> 决定了<code>getopt_long</code>的返回值，如果为NULL，返回val字段的数值；如果不为NULL，则会使其指向的内容变为val中的值，并且返回0；若未发现长选项，那么指向不变；<br><em>val</em> 指定的默认值。  </p>
<p><strong>长命令参数的解析</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</div></pre></td></tr></table></figure></p>
<p>参数说明：<br><code>argc</code> 和 <code>argv</code> 是命令行参数；<br><code>optstring</code> 选项参数组成的字符串，如果一个字母后面跟着一个冒号如 <code>t:</code>，那么表示这个选项后需要参数；<br><code>longopts</code> 是需要的自定义的option结构体；<br><code>longindex</code> 指定一个索引指针。  </p>
<p><strong>例子</strong>：  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言知识拾遗，struct option 结构体。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-迭代器和traits编程技法</title>
    <link href="http://abumaster.com/2017/06/27/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8Ctraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/"/>
    <id>http://abumaster.com/2017/06/27/STL源码剖析-迭代器和traits编程技法/</id>
    <published>2017-06-27T06:46:37.000Z</published>
    <updated>2017-06-30T02:38:56.651Z</updated>
    
    <content type="html"><![CDATA[<p>STL源码剖析，第三章 迭代器和traits编程技法的读书笔记。</p>
<a id="more"></a>
<div class="note info"><p><em>迭代器</em> 是一种类似指针的对象，各种行为中最重要的是内容提领(dereference)和成员访问(member access)。最重要的是对 <code>operator*</code> 和 <code>operator-&gt;</code> 进行重载。  </p>
</div>  
<h4 id="迭代器的相应型别"><a href="#迭代器的相应型别" class="headerlink" title="迭代器的相应型别"></a>迭代器的相应型别</h4><p>相应型别（associated type）是迭代器所指之物的型别。<br>应用场景：算法中可能用到一个以迭代器所指型别类型的变量，这时如何获取呢？C++ 不支持<code>typeof</code>。<br>解决方法：利用函数模板的参数推导机制，可以推导出型别。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span></div><div class="line"></span>&#123;</div><div class="line">	T tmp; <span class="comment">// T 所指之物的类别 int</span></div><div class="line">	<span class="comment">// ... 这里做原本func做的工作</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span></div><div class="line"><span class="keyword">void</span> <span class="title">func</span><span class="params">(I iter)</span></div><div class="line"></span>&#123;</div><div class="line">	func_impl(iter, *iter); <span class="comment">// func 的工作全部移往 func_impl</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	func(&amp;i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Traits-编程技法"><a href="#Traits-编程技法" class="headerlink" title="Traits 编程技法"></a>Traits 编程技法</h4><p>上述的参数推导机制，无法推导出函数返回值的型别。有一种方法：内嵌型别来解决，内嵌一个类型声明 value type 。如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> MyIter &#123;</div><div class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌式声明（nested type）</span></div><div class="line">	T* ptr;</div><div class="line">	MyIter(T* p=<span class="number">0</span>) : ptr(p) &#123; &#125;</div><div class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="keyword">typename</span> I::value_type <span class="comment">// 这一行是 func 的回返值型別</span></div><div class="line">func(I ite)</div><div class="line">&#123; <span class="keyword">return</span> *ite; &#125;</div><div class="line"><span class="comment">// 调用</span></div><div class="line">MyIter&lt;<span class="keyword">int</span>&gt; ite(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</div><div class="line"><span class="built_in">cout</span> &lt;&lt; func(ite); <span class="comment">// 输出：8</span></div></pre></td></tr></table></figure></p>
<p><strong>并不是所有的迭代器都可以内嵌型别，如原生指针不是 class type，就无法定义型别。</strong>因此，对一般化概念进行特定情况处理，模板偏特化（template partial specialization）可以做到。<br>所谓<em>偏特化</em>是针对任意template参数更进一步限制条件设计出的一个特化版本。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;typeneme T&gt;</div><div class="line"><span class="keyword">class</span> C&lt;T*&gt; &#123;...&#125;<span class="comment">//T为原生指针的情况，是T为任何类型的进一步条件限制</span></div></pre></td></tr></table></figure></p>
<p><strong>特征萃取机</strong><br>负责将迭代器或者原生指针中的特征提取出来。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-30/21514523.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>迭代器各个型别的意义：<br><code>value type</code> 迭代器所指对象的型别。<br><code>difference_type</code> 两个迭代器之间的距离，也可以用来表示一个容器的最大容量。<br><code>reference</code> 引用类型。<br><code>pointer</code> 指针类型。<br><code>iterator_category</code> 迭代器的分类。<br>迭代器通常分为五类：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input Iterator</td>
<td>不允许外部改变，只读</td>
</tr>
<tr>
<td>Output Iterator</td>
<td>只写</td>
</tr>
<tr>
<td>Forward Iterator</td>
<td>单向移动，可读可写</td>
</tr>
<tr>
<td>Bidirectional Iterator</td>
<td>双向移动，区间内可读可写</td>
</tr>
<tr>
<td>Random Access Iterator</td>
<td>随机访问，涵盖所有指针的算术能力</td>
</tr>
</tbody>
</table>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-30/63413455.jpg" alt=""><br><strong>Traits</strong>编程技法。部分源码剖析，<a href="http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html">参考</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于标记迭代器类型</span></div><div class="line"><span class="keyword">struct</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> output_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> forward_iterator_tag : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> bidirectional_iterator_tag : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> random_access_iterator_tag : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> input_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> input_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                  value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance           difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                 pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                 reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> output_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> forward_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                    value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance             difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                   pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                   reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> bidirectional_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> random_access_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_NAMESPACES</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Category, <span class="keyword">class</span> T, <span class="keyword">class</span> Distance = <span class="keyword">ptrdiff_t</span>,</div><div class="line">          <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt;</div><div class="line"><span class="keyword">struct</span> iterator &#123;</div><div class="line">  <span class="keyword">typedef</span> Category  iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T         value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance  difference_type;</div><div class="line">  <span class="keyword">typedef</span> Pointer   pointer;</div><div class="line">  <span class="keyword">typedef</span> Reference reference;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_NAMESPACES */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></div><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_traits定义</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line"><span class="comment">// 用于traits出迭代其所指对象的型别</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 迭代器类型, STL提供五种迭代器</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代器所指对象的型别</span></div><div class="line">  <span class="comment">// 如果想与STL算法兼容, 那么在类内需要提供value_type定义</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</div><div class="line"></div><div class="line">  <span class="comment">// 这个是用于处理两个迭代器间距离的类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</div><div class="line"></div><div class="line">  <span class="comment">// 直接指向对象的原生指针类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</div><div class="line"></div><div class="line">  <span class="comment">// 这个是对象的引用类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 针对指针提供特化版本</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;T*&gt;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 针对指向常对象的指针提供特化</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;<span class="keyword">const</span> T*&gt;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_traits支持函数</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_category(const Iterator&amp;)           返回迭代器类别</span></div><div class="line"><span class="comment">// distance_type(const Iterator&amp;)               返回表示迭代器距离的类型</span></div><div class="line"><span class="comment">// value_type(const Iterator&amp;)                  返回迭代器所指对象的类型</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</div><div class="line"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</div><div class="line">  <span class="keyword">return</span> category();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</div><div class="line"><span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</div><div class="line"><span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子：使用，如一个动物接收机构，不同的动物对应不同的处理，但是对于外界来说只有一个共同的接口，内部不同的动物有不同的方法，用虚函数可以实现，但是用traits编程技巧，也能很好的实现这个需求。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义不同的动物标签</span></div><div class="line"><span class="keyword">struct</span> cat_tag&#123;&#125;;</div><div class="line"><span class="keyword">struct</span> dog_tag&#123;&#125;;</div><div class="line"><span class="comment">//不同的动物类</span></div><div class="line"><span class="keyword">struct</span> dog&#123;</div><div class="line">	<span class="keyword">typedef</span> dog_tag animal_type;<span class="comment">//内嵌动物类型</span></div><div class="line">	<span class="comment">//typedef T value_type;</span></div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> cat &#123;</div><div class="line">	<span class="keyword">typedef</span> cat_tag animal_type;</div><div class="line">	<span class="comment">//typedef T value_type;</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//获取动物类型</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> AnimalTraits &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::animal_type animal_type;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">//不同的动物有不同的处理</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;  <span class="keyword">void</span> _Accept(T dog, dog_tag)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is dog accept..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> _Accept(T cat, cat_tag)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is cat accept..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//提供外部通用的接口</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Accept</span><span class="params">(T animal)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> AnimalTraits&lt;T&gt;::animal_type type;</div><div class="line">	_Accept(animal, type());<span class="comment">//依据类别的临时变量决定调用哪个</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL源码剖析，第三章 迭代器和traits编程技法的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-空间配置器</title>
    <link href="http://abumaster.com/2017/06/24/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://abumaster.com/2017/06/24/STL源码剖析-空间配置器/</id>
    <published>2017-06-24T08:15:31.000Z</published>
    <updated>2017-06-24T11:18:21.109Z</updated>
    
    <content type="html"><![CDATA[<p>《STL 源码剖析》读书笔记，第2章 空间配置器（allocator）。</p>
<a id="more"></a>
<h4 id="空间的配置和释放"><a href="#空间的配置和释放" class="headerlink" title="空间的配置和释放"></a>空间的配置和释放</h4><blockquote>
<p>内存配置 -&gt; 对象构造 -&gt; 对象析构 -&gt; 内存释放</p>
</blockquote>
<p>考虑到小内存块可能造成内存碎片的问题，SGI设计了双层配置器，对于大的内存块直接使用以及配置器，直接调用 <code>malloc()</code> 和 <code>free()</code> 函数，其中定义了内存不足的处理函数机制；而对于较小的内存申请（128 bytes 为界限），使用二级配置器，使用了内存池技术（内存的申请和释放交由内存池管理），可以保证效率和减少内存碎片。两个配置器的使用取决于 <code>__USE__MALLOC</code> 宏的定义。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/43353252.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></div><div class="line">...</div><div class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</div><div class="line"><span class="keyword">typedef</span> malloc_alloc alloc; <span class="comment">// 令 alloc 为第一级配置器</span></div><div class="line"><span class="meta"># <span class="meta-keyword">else</span></span></div><div class="line">...</div><div class="line"><span class="comment">// 令 alloc 为第二级配置器</span></div><div class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span></span></div></pre></td></tr></table></figure></p>
<p>包装一个接口提供给用户使用，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</div><div class="line"><span class="keyword">class</span> simple_alloc &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></div><div class="line">		</span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*)  Alloc::allocate (n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">		</span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></div><div class="line">		</span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></div><div class="line">		</span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="第二级配置器剖析"><a href="#第二级配置器剖析" class="headerlink" title="第二级配置器剖析"></a>第二级配置器剖析</h4><p>规定申请的空间小于 128 bytes 时，使用二级配置器完成。二级配置器由自由链表（free-list）组成。内存需求以8的倍数对齐。16个 <em>free-lists</em> 各自管理大小分别为 8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128 bytes 的小额区块。需要哪个大小直接从链表中调拨。<br><strong>链表结构</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> obj &#123;</div><div class="line">	<span class="keyword">union</span> obj * free_list_link;</div><div class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析：<br>union共用存储空间。<code>free_list_link</code> 指向下一个 obj ；第二个字段，可以看成一个指针，指向了实际的区块。<code>client_data</code> 为数组名称，是数组的首地址，因此是一个指针，指向了obj的地址，即<code>&amp;obj == obj-&gt;client_data</code>。实现了链表结点只使用一个指针的大小空间, 却能同时做索引和指向内存区域。<br><strong>空间配置函数 allocate()</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n must be &gt; 0</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></div><div class="line"></span>&#123;</div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	obj * result;</div><div class="line">	<span class="comment">// 大于128的调用一级配置器</span></div><div class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)</div><div class="line">		<span class="keyword">return</span>(malloc_alloc::allocate(n));	</div><div class="line">	<span class="comment">// 寻找自由链表中的合适的大小</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	result = *my_free_list;</div><div class="line">	<span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 沒找到可用的 free list ，重新填充</span></div><div class="line">		<span class="keyword">void</span> *r = refill(ROUND_UP(n)); <span class="comment">//</span></div><div class="line">		<span class="keyword">return</span> r;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 调整空闲链表</span></div><div class="line">	*my_free_list = result -&gt; free_list_link;</div><div class="line">	<span class="keyword">return</span> (result);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>示意图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/14223605.jpg" alt=""><br><strong>空间释放函数 deallocate()</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 不可以是 0</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></div><div class="line"></span>&#123;</div><div class="line">	obj *q = (obj *)p;</div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	<span class="comment">// 大於 128 请求一级配置器</span></div><div class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</div><div class="line">		malloc_alloc::deallocate(p, n);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 根据大小寻找对应的 free list</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	<span class="comment">// 重新调整 free list ，回收区块进链表</span></div><div class="line">	q -&gt; free_list_link = *my_free_list;</div><div class="line">	*my_free_list = q;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示意图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/78747924.jpg" alt=""><br>配置和释放的过程：  </p>
<ul>
<li>根据请求的大小，找到16个free lists中对应的list或者请求一级配置器；  </li>
<li>然后将第一块空闲区返回给用户，没有空闲的可以到内存池中再重新注入一些空闲的数据块。<br><strong>重新填充 free lists</strong><br>分配时，发现free list中没有空闲的区块，则从内存池中填充一部分新区快，默认为20个新区快。内存池中没有那么多也可能会少于20个。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回一个大小为n的对象，恰当时候可以为free list增加新的节点</span></div><div class="line"><span class="comment">//n已经是8的倍数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> nobjs = <span class="number">20</span>;</div><div class="line">	<span class="comment">//从内存池中申请 nobjs 个大小为 n 的对象(n*objs)，chunk指向这块内存</span></div><div class="line">	<span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);<span class="comment">//nobjs为引用参数</span></div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	obj * result;</div><div class="line">	obj * current_obj, * next_obj;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="comment">//只得到了一块，那么直接返回，不需要加入free list中了</span></div><div class="line">	<span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</div><div class="line">	<span class="comment">//找到合适的free list</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	result = (obj*)chunk;<span class="comment">//返回的空间</span></div><div class="line">	<span class="comment">//指向下一个空闲块</span></div><div class="line">	*my_free_list = next_obj = (obj *)(chunk + n);</div><div class="line">	<span class="comment">//开始加入free list中</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123; <span class="comment">// 0的已经返回给用户</span></div><div class="line">		current_obj = next_obj;</div><div class="line">		next_obj = (obj *)((<span class="keyword">char</span> *)next_obj + n);</div><div class="line">		<span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;<span class="comment">//最后一个</span></div><div class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">//分成大小n的块，并连成链表</span></div><div class="line">			current_obj -&gt; free_list_link = next_obj;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span>(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>内存池</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </div><div class="line"><span class="keyword">char</span>*  </div><div class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">char</span> * result;  </div><div class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;  </div><div class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;  <span class="comment">// 计算内存池剩余容量  </span></div><div class="line">    <span class="comment">// 如果内存池中剩余内存&gt;=需要分配的内内存, 返回start_free指向的内存块,</span></div><div class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></div><div class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </div><div class="line">        result = start_free;  </div><div class="line">        start_free += total_bytes;  </div><div class="line">        <span class="keyword">return</span>(result);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span></div><div class="line">    <span class="comment">// 返回所能分配的最多的节点, 返回start_free指向的内存块  </span></div><div class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;  </div><div class="line">        nobjs = bytes_left/size;  </div><div class="line">        total_bytes = size * nobjs;  </div><div class="line">        result = start_free;  </div><div class="line">        start_free += total_bytes;  </div><div class="line">        <span class="keyword">return</span>(result);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 内存池剩余内存连一个节点也不够分配  </span></div><div class="line">    <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);  </div><div class="line">        <span class="comment">// 将剩余的内存分配给指定的free_list[FREELIST_INDEX(bytes_left)]  </span></div><div class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </div><div class="line">            obj * __VOLATILE * my_free_list =  </div><div class="line">                        free_list + FREELIST_INDEX(bytes_left);  </div><div class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </div><div class="line">            *my_free_list = (obj *)start_free;  </div><div class="line">        &#125;  </div><div class="line">        start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);  </div><div class="line">        <span class="comment">// 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span></div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;  </div><div class="line">           <span class="keyword">int</span> i;  </div><div class="line">           obj * __VOLATILE * my_free_list, *p;  </div><div class="line">           <span class="comment">//不打算配置较小的内存块</span></div><div class="line">           <span class="comment">//检索在free list中足够大的空闲块 </span></div><div class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </div><div class="line">                my_free_list = free_list + FREELIST_INDEX(i);  </div><div class="line">                p = *my_free_list;  </div><div class="line">                <span class="comment">// 找到了一个, 将其加入内存池中  </span></div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </div><div class="line">                    *my_free_list = p -&gt; free_list_link;  </div><div class="line">                    start_free = (<span class="keyword">char</span> *)p;  </div><div class="line">                    end_free = start_free + i;  </div><div class="line">                    <span class="comment">// 内存池更新完毕, 重新分配需要的内存</span></div><div class="line">                    <span class="comment">//递归调用</span></div><div class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </div><div class="line">                    <span class="comment">// 内存零头被编到了对应free list中  </span></div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助</span></div><div class="line">            <span class="comment">// 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span></div><div class="line">            <span class="comment">// 最好直接log, 然后让程序崩溃  </span></div><div class="line">        end_free = <span class="number">0</span>;   <span class="comment">// In case of exception.  </span></div><div class="line">            start_free = (<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);  </div><div class="line">        &#125;  </div><div class="line">        heap_size += bytes_to_get;  </div><div class="line">        end_free = start_free + bytes_to_get;  </div><div class="line">        <span class="comment">// 内存池更新完毕, 重新分配需要的内存  </span></div><div class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html">参考链接</a>。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《STL 源码剖析》读书笔记，第2章 空间配置器（allocator）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Nginx源码学习-数据结构</title>
    <link href="http://abumaster.com/2017/06/18/Nginx%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/06/18/Nginx源码学习-数据结构/</id>
    <published>2017-06-18T10:29:52.000Z</published>
    <updated>2017-06-20T11:24:52.414Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx源码学习中的数据结构，主要包括数组结构<code>ngx_array_t</code>、链表结构<code>ngx_list_t</code>、队列结构<code>ngx_queue_t</code>、哈希结构<code>ngx_hash_t</code>、字符串结构<code>ngx_string_t</code>。在内存池的基础之上进一步整合组织数据。  </p>
<a id="more"></a>
<h4 id="Nginx数组结构ngx-array-t"><a href="#Nginx数组结构ngx-array-t" class="headerlink" title="Nginx数组结构ngx_array_t"></a>Nginx数组结构ngx_array_t</h4><p>数组结构位于源文件<code>\Src\Core\Ngx_array.h{c}</code>  </p>
<h5 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">void</span>        *elts; <span class="comment">//指向数组空间的起始地址</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>   nelts; <span class="comment">//数组中实际的元素个数</span></div><div class="line">    <span class="keyword">size_t</span>       size; <span class="comment">//数组元素的大小</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>   nalloc; <span class="comment">//实际分配的空间</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>  *pool; <span class="comment">//数组交由此内存池来管理空间</span></div><div class="line">&#125; <span class="keyword">ngx_array_t</span>;<span class="comment">//数组头占用的空间为20字节，头+数据</span></div></pre></td></tr></table></figure>
<p>几种数据结构之间的关系图<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-18/21845022.jpg" alt="">  </p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p><strong>1.一个内联函数</strong><br>功能：在内存池<code>pool</code>上分配一块大小为<code>n*size</code>的空间，并将数组的<code>elts</code>指针指向这个空间的首地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化数组大小为n，参数：数组指针，内存池，数组空间的，每个元素大小</span></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline ngx_int_t</div><div class="line"><span class="title">ngx_array_init</span><span class="params">(<span class="keyword">ngx_array_t</span> *<span class="built_in">array</span>, <span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">/*</div><div class="line">     * set "array-&gt;nelts" before "array-&gt;elts", otherwise MSVC thinks</div><div class="line">     * that "array-&gt;nelts" may be used without having been initialized</div><div class="line">     */</span></div><div class="line"></div><div class="line">    <span class="built_in">array</span>-&gt;nelts = <span class="number">0</span>;<span class="comment">//数组中的元素个数为0</span></div><div class="line">    <span class="built_in">array</span>-&gt;size = size;<span class="comment">//每个元素的大小</span></div><div class="line">    <span class="built_in">array</span>-&gt;nalloc = n;<span class="comment">//分配n个空间，空间大小(n*size)</span></div><div class="line">    <span class="built_in">array</span>-&gt;pool = pool;</div><div class="line">	<span class="comment">//用内存池函数分配一个大小(n*size)的空间并将首地址返回给数组的elts</span></div><div class="line">    <span class="built_in">array</span>-&gt;elts = ngx_palloc(pool, n * size);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//成功初始化数组</span></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2.创建数组</strong><br>功能：提供数组元素的个数并且知道每个元素所占用的空间，在内存池p中创建一个有n个元素的数组。返回数组的指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_array_t</span> *</div><div class="line">ngx_array_create(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_array_t</span> *a;</div><div class="line"><span class="comment">//首先为数组的头分配一个空间，这个数组指针指向的是数组头的起始地址</span></div><div class="line">    a = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="keyword">ngx_array_t</span>));</div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//用内联函数初始化这个数组</span></div><div class="line">    <span class="keyword">if</span> (ngx_array_init(a, p, n, size) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.销毁数组</strong><br>功能：销毁数组实际上没有释放数组占用的内存空间，而是移动首尾指针，这样保证了效率。<br>代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></div><div class="line"><span class="title">ngx_array_destroy</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//数组所用的内存池</span></div><div class="line">    p = a-&gt;pool;</div><div class="line"><span class="comment">//数组不是内存池中的最后一个？还能删除？</span></div><div class="line">    <span class="keyword">if</span> ((u_char *) a-&gt;elts + a-&gt;size * a-&gt;nalloc == p-&gt;d.last) &#123;</div><div class="line">        p-&gt;d.last -= a-&gt;size * a-&gt;nalloc;<span class="comment">//将内存池的指针向前移动</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">//删除数组头</span></div><div class="line">    <span class="keyword">if</span> ((u_char *) a + <span class="keyword">sizeof</span>(<span class="keyword">ngx_array_t</span>) == p-&gt;d.last) &#123;</div><div class="line">        p-&gt;d.last = (u_char *) a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.向数组中插入元素</strong><br>功能：向数组指针a中插入元素，返回插入元素的空间地址
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_array_push</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>        *elt, *<span class="keyword">new</span>;</div><div class="line">    <span class="keyword">size_t</span>       size;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//数组中元素已经满了</span></div><div class="line">    <span class="keyword">if</span> (a-&gt;nelts == a-&gt;nalloc) &#123;</div><div class="line">        size = a-&gt;size * a-&gt;nalloc;<span class="comment">//此时数组的占用空间的大小</span></div><div class="line">        p = a-&gt;pool;</div><div class="line">    <span class="comment">//数组后面有多余的空间可以扩展</span></div><div class="line">        <span class="keyword">if</span> ((u_char *) a-&gt;elts + size == p-&gt;d.last</div><div class="line">            &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/*</div><div class="line">             * the array allocation is the last in the pool</div><div class="line">             * and there is space for new allocation</div><div class="line">             */</span></div><div class="line">	<span class="comment">//向后扩展一个元素的空间</span></div><div class="line">            p-&gt;d.last += a-&gt;size;</div><div class="line">            a-&gt;nalloc++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* allocate a new array */</span></div><div class="line">	<span class="comment">//没有多余的空间进行扩展，则重新申请一个数组，大小为当前的2倍</span></div><div class="line">            <span class="keyword">new</span> = ngx_palloc(p, <span class="number">2</span> * size);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">	<span class="comment">//将原数组元素拷贝到新的数组中，并设置新数组的一些参数（老数组没有销毁）</span></div><div class="line">            ngx_memcpy(<span class="keyword">new</span>, a-&gt;elts, size);</div><div class="line">            a-&gt;elts = <span class="keyword">new</span>;</div><div class="line">            a-&gt;nalloc *= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//将指针指向下一个空闲区域</span></div><div class="line">    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;</div><div class="line">    a-&gt;nelts++;</div><div class="line">	<span class="comment">//返回这个空闲空间的指针</span></div><div class="line">    <span class="keyword">return</span> elt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加n个元素<code>void * ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)</code>。  </p>
<h4 id="Nginx链表结构ngx-list-t"><a href="#Nginx链表结构ngx-list-t" class="headerlink" title="Nginx链表结构ngx_list_t"></a>Nginx链表结构ngx_list_t</h4><h5 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_list_part_s  <span class="keyword">ngx_list_part_t</span>;</div><div class="line"><span class="comment">//链表节点结构</span></div><div class="line"><span class="keyword">struct</span> ngx_list_part_s &#123;</div><div class="line">    <span class="keyword">void</span>             *elts;<span class="comment">//实际指向的内存区域大小为size*nalloc</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        nelts;<span class="comment">//元素的个数</span></div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *next;<span class="comment">//下一个节点的地址</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//链表头结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *last;<span class="comment">//指向链表最后一个节点</span></div><div class="line">    <span class="keyword">ngx_list_part_t</span>   part;<span class="comment">//链表头中也有一个节点</span></div><div class="line">    <span class="keyword">size_t</span>            size;<span class="comment">//每个元素的大小</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        nalloc;<span class="comment">//链表包含的空间，实际分配的空间个数</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *pool;<span class="comment">//在此内存池中分配</span></div><div class="line">&#125; <span class="keyword">ngx_list_t</span>;</div></pre></td></tr></table></figure>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-18/25501941.jpg" alt="">  </p>
<h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><p><strong>1.内联函数-链表的初始化</strong><br>功能：初始化链表实体，头结点
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline ngx_int_t</div><div class="line"><span class="title">ngx_list_init</span><span class="params">(<span class="keyword">ngx_list_t</span> *<span class="built_in">list</span>, <span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="built_in">list</span>-&gt;part.elts = ngx_palloc(pool, n * size);<span class="comment">//实际存储空间</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;part.elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">list</span>-&gt;part.nelts = <span class="number">0</span>;<span class="comment">//当前元素个数</span></div><div class="line">    <span class="built_in">list</span>-&gt;part.next = <span class="literal">NULL</span>;<span class="comment">//下一个没有</span></div><div class="line">    <span class="built_in">list</span>-&gt;last = &amp;<span class="built_in">list</span>-&gt;part;<span class="comment">//最后一个指向了自己</span></div><div class="line">    <span class="built_in">list</span>-&gt;size = size;<span class="comment">//大小</span></div><div class="line">    <span class="built_in">list</span>-&gt;nalloc = n;<span class="comment">//元素的个数</span></div><div class="line">    <span class="built_in">list</span>-&gt;pool = pool;<span class="comment">//内存池</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</div><div class="line"> *</div><div class="line"> *  the iteration through the list:</div><div class="line"> *</div><div class="line"> *  part = &amp;list.part;//先获得链表头中的节点</div><div class="line"> *  data = part-&gt;elts;//获得数据的存储区域</div><div class="line"> *</div><div class="line"> *  for (i = 0 ;; i++) &#123;</div><div class="line"> *判断此节点中元素的个数，依次取出</div><div class="line"> *      if (i &gt;= part-&gt;nelts) &#123;</div><div class="line"> *          if (part-&gt;next == NULL) &#123;//无下一个节点则跳出</div><div class="line"> *              break;</div><div class="line"> *          &#125;</div><div class="line"> *取出下一个节点</div><div class="line"> *          part = part-&gt;next;</div><div class="line"> *          data = part-&gt;elts;</div><div class="line"> *          i = 0;</div><div class="line"> *      &#125;</div><div class="line"> *进行此节点中的数据操作</div><div class="line"> *      ...  data[i] ...</div><div class="line"> *</div><div class="line"> *  &#125;</div><div class="line"> */</span></div></pre></td></tr></table></figure></p>
<p><strong>2.创建链表</strong><br>功能：创建一个链表，指定内存池，个数以及每个元素的大小
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_list_t</span> *</div><div class="line">ngx_list_create(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_list_t</span>  *<span class="built_in">list</span>;</div><div class="line"><span class="comment">//为链表头分配空间大小sizeof(ngx_list_t) = 28B</span></div><div class="line">    <span class="built_in">list</span> = ngx_palloc(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_list_t</span>));</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//调用内联函数进行链表的初始化，包含一个节点的链表头</span></div><div class="line">    <span class="keyword">if</span> (ngx_list_init(<span class="built_in">list</span>, pool, n, size) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//返回此链表头结点</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.添加结点</strong><br>功能：向链表中添加一个元素，返回添加元素数据区的地址
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_list_push</span><span class="params">(<span class="keyword">ngx_list_t</span> *l)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>             *elt;</div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *last;</div><div class="line"><span class="comment">//得到链表中的最后一个节点，在链表的尾部插入新的节点</span></div><div class="line">    last = l-&gt;last;</div><div class="line"><span class="comment">//最后一个节点的元素个数已经满了</span></div><div class="line">    <span class="keyword">if</span> (last-&gt;nelts == l-&gt;nalloc) &#123;</div><div class="line">	<span class="comment">//需要重新创建一个链表节点</span></div><div class="line">        last = ngx_palloc(l-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_list_part_t</span>));</div><div class="line">        <span class="keyword">if</span> (last == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//为节点分配空间</span></div><div class="line">        last-&gt;elts = ngx_palloc(l-&gt;pool, l-&gt;nalloc * l-&gt;size);</div><div class="line">        <span class="keyword">if</span> (last-&gt;elts == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//设置新节点信息</span></div><div class="line">        last-&gt;nelts = <span class="number">0</span>;</div><div class="line">        last-&gt;next = <span class="literal">NULL</span>;</div><div class="line">	<span class="comment">//连接到链表中</span></div><div class="line">        l-&gt;last-&gt;next = last;</div><div class="line">        l-&gt;last = last;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//获得地址</span></div><div class="line">    elt = (<span class="keyword">char</span> *) last-&gt;elts + l-&gt;size * last-&gt;nelts;</div><div class="line">    last-&gt;nelts++;</div><div class="line"><span class="comment">//返回可用存储空间的地址</span></div><div class="line">    <span class="keyword">return</span> elt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.链表设计思路</strong><br>在链表头中设置一些链表节点的信息：<code>last</code>指针用于指向链表的最后一个节点，方便插入元素和数据；<code>part</code>链表头中的结点；<code>size</code>链表中存放元素的大小；<code>nalloc</code>一个节点所占用的空间，可以放元素的个数；<code>pool</code>指定内存池。<br>在链表节点中只存放了指向数据元素存储区的指针<code>elts</code>；当前节点存放的元素个数<code>nelts</code>；以及下一个节点指针<code>next</code>。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/93613137.jpg" alt="">  </p>
<h4 id="Nginx队列结构-ngx-queue-t"><a href="#Nginx队列结构-ngx-queue-t" class="headerlink" title="Nginx队列结构 ngx_queue_t"></a>Nginx队列结构 ngx_queue_t</h4><blockquote>
<p>Nginx 中的队列数据结构是用双向循环链表实现。节点结构为ngx_queue_t。 </p>
</blockquote>
<h5 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_queue_s  <span class="keyword">ngx_queue_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_queue_s &#123;<span class="comment">//队列的结构</span></div><div class="line">    <span class="keyword">ngx_queue_t</span>  *prev;<span class="comment">//前指针</span></div><div class="line">    <span class="keyword">ngx_queue_t</span>  *next;<span class="comment">//后指针</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h5><p>通过定义的一组宏来实现队列的基本操作。  </p>
<p><strong>1.初始化队列</strong><br>初始化头尾指针指向本身。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_init(q)  \</div><div class="line">    (q)-&gt;prev = q;         \</div><div class="line">    (q)-&gt;next = q</span></div></pre></td></tr></table></figure></p>
<p><strong>2.判断队列是否为空</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_empty(h)  \</div><div class="line">    (h == (h)-&gt;prev)</span></div></pre></td></tr></table></figure></p>
<p><strong>3.插入节点</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在头插入</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_insert_head(h, x)                                           \</div><div class="line">    (x)-&gt;next = (h)-&gt;next;                                                    \</div><div class="line">    (x)-&gt;next-&gt;prev = x;                                                      \</div><div class="line">    (x)-&gt;prev = h;                                                            \</div><div class="line">    (h)-&gt;next = x</span></div><div class="line"><span class="comment">//在尾插入</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_insert_tail(h, x)                                           \</div><div class="line">    (x)-&gt;prev = (h)-&gt;prev;                                                    \</div><div class="line">    (x)-&gt;prev-&gt;next = x;                                                      \</div><div class="line">    (x)-&gt;next = h;                                                            \</div><div class="line">    (h)-&gt;prev = x</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/20171048.jpg" alt=""><br><strong>4.访问</strong><br>队列的头结点是固定的，依次链接成了双向链表，进行访问数据。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_head(h)                                                     \</div><div class="line">    (h)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_last(h)                                                     \</div><div class="line">    (h)-&gt;prev</span></div><div class="line"><span class="comment">//哨兵，用于排序</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_sentinel(h)                                                 \</div><div class="line">    (h)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_next(q)                                                     \</div><div class="line">    (q)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_prev(q)                                                     \</div><div class="line">    (q)-&gt;prev</span></div></pre></td></tr></table></figure></p>
<p><strong>5.修改队列</strong><br>删除队列中的节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_remove(x)                                                   \</div><div class="line">    (x)-&gt;next-&gt;prev = (x)-&gt;prev;                                              \</div><div class="line">    (x)-&gt;prev-&gt;next = (x)-&gt;next;                                              \</div><div class="line">    (x)-&gt;prev = NULL;                                                         \</div><div class="line">    (x)-&gt;next = NULL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_remove(x)                                                   \</div><div class="line">    (x)-&gt;next-&gt;prev = (x)-&gt;prev;                                              \</div><div class="line">    (x)-&gt;prev-&gt;next = (x)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>分割队列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_split(h, q, n)                                              \</div><div class="line">    (n)-&gt;prev = (h)-&gt;prev;                                                    \</div><div class="line">    (n)-&gt;prev-&gt;next = n;                                                      \</div><div class="line">    (n)-&gt;next = q;                                                            \</div><div class="line">    (h)-&gt;prev = (q)-&gt;prev;                                                    \</div><div class="line">    (h)-&gt;prev-&gt;next = h;                                                      \</div><div class="line">    (q)-&gt;prev = n;</span></div></pre></td></tr></table></figure></p>
<p>h为队列头(即链表头指针)，将该队列从q节点将队列(链表)分割为两个队列(链表)，q之后的节点组成的新队列的头节点为n。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/10619716.jpg" alt=""><br>合并队列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_add(h, n)                                                   \</div><div class="line">    (h)-&gt;prev-&gt;next = (n)-&gt;next;                                              \</div><div class="line">    (n)-&gt;next-&gt;prev = (h)-&gt;prev;                                              \</div><div class="line">    (h)-&gt;prev = (n)-&gt;prev;                                                    \</div><div class="line">    (h)-&gt;prev-&gt;next = h;</span></div></pre></td></tr></table></figure></p>
<p>两个队列的头结点。最后只保留h头结点。  </p>
<h5 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h5><p>获取队列节点的数据，由队列基本结构和以上操作可知，nginx的队列操作只对链表指针进行简单的修改指向操作，并不负责节点数据空间的分配。<br>因此，用户在使用nginx队列时，要自己定义数据结构并分配空间，且在其中包含一个<code>ngx_queue_t</code>的指针或者对象，当需要获取队列节点数据时，使用<code>ngx_queue_data</code>宏，其定义如下:
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_data(q, type, link)                                         \</div><div class="line">    (type *) ((u_char *) q - offsetof(type, link))</span></div><div class="line"><span class="comment">//其中offsetof，是一个宏，用于计算成员在一个数据结构中的偏移量</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(s, m)   (size_t)&amp;(((s *)0)-&gt;m)</span></div><div class="line"><span class="comment">/*</div><div class="line">s是一个结构名，它有一个名为m的成员（s和m 是宏offsetof的形参，它实际是返回结构s的成员m的偏移地址.</div><div class="line">(s *)0 是骗编译器说有一个指向类（或结构）s的指针，其地址值0 </div><div class="line">&amp;((s *)0)-&gt;m   是要取得类s中成员变量m的地址. 因基址为0，这时m的地址当然就是m在s中的偏移</div><div class="line">最后转换size_t 型，即unsigned int。</div><div class="line"> */</span></div></pre></td></tr></table></figure></p>
<p>由该宏定义可以看出，一般定义队列节点结构(该结构类型为type)时，需要将真正的数据放在前面，而<code>ngx_queue_t</code>结构放在后面，故该宏使用减法计算整个节点结构的起始地址(需要进行类型转换)。  </p>
<p><em>获取队列中的中间元素</em>，奇数则返回中间的，偶数则会返回第二部分的第一个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_queue_t</span> *</div><div class="line">ngx_queue_middle(<span class="keyword">ngx_queue_t</span> *<span class="built_in">queue</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_queue_t</span>  *middle, *next;</div><div class="line"><span class="comment">//队列首元素</span></div><div class="line">    middle = ngx_queue_head(<span class="built_in">queue</span>);</div><div class="line"><span class="comment">//只有一个元素返回</span></div><div class="line">    <span class="keyword">if</span> (middle == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> middle;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//用一个指针记录</span></div><div class="line">    next = ngx_queue_head(<span class="built_in">queue</span>);</div><div class="line"><span class="comment">//两个指针向前移动</span></div><div class="line">    <span class="keyword">for</span> ( ;; ) &#123;</div><div class="line">        middle = ngx_queue_next(middle);</div><div class="line">        next = ngx_queue_next(next);</div><div class="line">        <span class="keyword">if</span> (next == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//next指针向前多移动一次</span></div><div class="line">        next = ngx_queue_next(next);</div><div class="line"><span class="comment">//到了尾返回middle</span></div><div class="line">        <span class="keyword">if</span> (next == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找中间位置，两个指针，middle移动一次，next移动两次，当next到达尾时，那么middle指向的是中间位置。  </p>
<p><em>排序</em>，稳定插入排序。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">ngx_queue_sort(ngx_queue_t *queue,</div><div class="line">    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *))</div><div class="line">&#123;</div><div class="line">    ngx_queue_t  *q, *prev, *next;</div><div class="line">//获得第一个元素</div><div class="line">    q = ngx_queue_head(queue);</div><div class="line">    if (q == ngx_queue_last(queue)) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">//获得下一个节点</div><div class="line">    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) &#123;</div><div class="line">//</div><div class="line">        prev = ngx_queue_prev(q);</div><div class="line">        next = ngx_queue_next(q);</div><div class="line">//</div><div class="line">        ngx_queue_remove(q);</div><div class="line">//</div><div class="line">        do &#123;</div><div class="line">            if (cmp(prev, q) &lt;= 0) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">//</div><div class="line">            prev = ngx_queue_prev(prev);</div><div class="line">//</div><div class="line">        &#125; while (prev != ngx_queue_sentinel(queue));</div><div class="line">//插入</div><div class="line">        ngx_queue_insert_after(prev, q);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Nginx哈希数据结构"><a href="#Nginx哈希数据结构" class="headerlink" title="Nginx哈希数据结构"></a>Nginx哈希数据结构</h4><p>哈希表是用于（key-value）对应的一种关系，为了直接由key来计算出value，需要构建一个哈希函数，并想方设法去避免冲突，尽量保证键值对的唯一性。<br>讲解详细的博文<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html">链接1</a>和<a href="http://www.nowamagic.net/academy/detail/3008088">链接2</a>。  </p>
<h5 id="hash-结构"><a href="#hash-结构" class="headerlink" title="hash 结构"></a>hash 结构</h5><p><strong>1.ngx_hash_t结构</strong><br>Nginx中的哈希结构为<code>ngx_hash_t</code>以及元素结构<code>ngx_hash_elt_t</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash元素结构</span></div><div class="line">    <span class="keyword">void</span>             *value; <span class="comment">//key对应的值(key, value)中的key</span></div><div class="line">    u_short           len; <span class="comment">//name长度</span></div><div class="line">    u_char            name[<span class="number">1</span>];<span class="comment">//要hash的数据，(key, value)中的key</span></div><div class="line">&#125; <span class="keyword">ngx_hash_elt_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash结构</span></div><div class="line">    <span class="keyword">ngx_hash_elt_t</span>  **buckets;<span class="comment">//哈希桶</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        size;<span class="comment">//哈希桶的个数</span></div><div class="line">&#125; <span class="keyword">ngx_hash_t</span>;</div></pre></td></tr></table></figure></p>
<p><strong>2.ngx_hash_init_t结构</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hash计算函数指针</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ngx_uint_t</span> <span class="params">(*ngx_hash_key_pt)</span> <span class="params">(u_char *data, <span class="keyword">size_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash初始化结构</span></div><div class="line">    <span class="keyword">ngx_hash_t</span>       *hash;<span class="comment">//指向待初始化的hash结构</span></div><div class="line">    ngx_hash_key_pt   key;<span class="comment">//hash函数指针</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        max_size;<span class="comment">//bucket的最大个数</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        bucket_size;<span class="comment">//每个bucket占用的空间</span></div><div class="line">    <span class="keyword">char</span>             *name;<span class="comment">//该hash结构的名字</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *pool;<span class="comment">//所需空间的由此内存池接管</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *temp_pool;<span class="comment">//临时文件</span></div><div class="line">&#125; <span class="keyword">ngx_hash_init_t</span>;</div></pre></td></tr></table></figure></p>
<p>通常是作为参数传递给<code>ngx_hash_init</code>函数。<br><strong>3.ngx_hash_key_t</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;  <span class="comment">//hash key结构  </span></div><div class="line">    <span class="keyword">ngx_str_t</span>         key;   <span class="comment">//key，为nginx的字符串结构  </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>  key_hash; <span class="comment">//由该key计算出的hash值(通过hash函数)  </span></div><div class="line">    <span class="keyword">void</span>    *value;  <span class="comment">//该key对应的值，组成一个键-值对&lt;key,value&gt;  </span></div><div class="line">&#125; <span class="keyword">ngx_hash_key_t</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;                    <span class="comment">//字符串结构  </span></div><div class="line">    <span class="keyword">size_t</span>      len;                <span class="comment">//字符串长度  </span></div><div class="line">    u_char     *data;               <span class="comment">//字符串内容  </span></div><div class="line">&#125; <span class="keyword">ngx_str_t</span>;</div></pre></td></tr></table></figure></p>
<p>该结构也主要用来保存要hash的数据，即键-值对<key,value>，在实际使用中，一般将多个键-值对保存在<code>ngx_hash_key_t</code>结构的数组中，作为参数传给<code>ngx_hash_init()</code>或<code>ngx_hash_wildcard_init()</code>函数。<br><strong>哈希结构的内存布局：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-20/23126191.jpg" alt="">  </p>
<center><a href="https://code.google.com/archive/p/nginxsrp/wikis/NginxCodeReview.wiki">图片来源 Google Code</a></center>  

<h5 id="hash-操作"><a href="#hash-操作" class="headerlink" title="hash 操作"></a>hash 操作</h5><p><strong>1.计算ngx_hash_elt_t的大小</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//name为ngx_hash_key_t</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HASH_ELT_SIZE(name)                                               \</div><div class="line">    (sizeof(void *) + ngx_align((name)-&gt;key.len + 2, sizeof(void *)))</span></div></pre></td></tr></table></figure></p>
<p><code>sizeof(void *)=4B</code>,4字节对齐。<br><strong>2.hash函数</strong><br>hash函数提供了几种计算hash的方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_hash(key, c)   ((ngx_uint_t) key * 31 + c)</span></div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_key(u_char *data, <span class="keyword">size_t</span> len);</div><div class="line"><span class="comment">//lc表示lower case，即字符串转换为小写后再计算hash值  </span></div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_key_lc(u_char *data, <span class="keyword">size_t</span> len);</div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_strlow(u_char *dst, u_char *src, <span class="keyword">size_t</span> n);</div><div class="line"><span class="comment">//如：</span></div><div class="line"><span class="keyword">ngx_uint_t</span></div><div class="line">ngx_hash_key(u_char *data, <span class="keyword">size_t</span> len)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_uint_t</span>  i, key;</div><div class="line"></div><div class="line">    key = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        key = ngx_hash(key, data[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> key;</div><div class="line">&#125;</div><div class="line"><span class="comment">//相当于：</span></div><div class="line"><span class="comment">/*</div><div class="line">Key[0] = data[0]  </div><div class="line">Key[1] = data[0]*31 + data[1]  </div><div class="line">Key[2] = (data[0]*31 + data[1])*31 + data[2]  </div><div class="line">...  </div><div class="line">Key[len-1] = ((((data[0]*31 + data[1])*31 + data[2])*31) ... data[len-2])*31 + data[len-1] </div><div class="line"> */</span></div><div class="line"><span class="comment">//key[len-1]即为传入的参数data对应的hash值。</span></div></pre></td></tr></table></figure></p>
<p><strong>3.hash初始化</strong><br>hash的初始化是用<code>ngx_hash_init</code>完成，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hinit hash结构指针；names 为ngx_hash_key_t结构数组；nelts为数组中元素个数</span></div><div class="line"><span class="comment">/*</div><div class="line">该函数初始化的结果就是将names数组保存的键-值对&lt;key,value&gt;，</div><div class="line">通过hash的方式将其存入相应的一个或多个hash桶(即代码中的buckets)中，</div><div class="line">该hash过程用到的hash函数一般为ngx_hash_key_lc等。</div><div class="line">hash桶里面存放的是ngx_hash_elt_t结构的指针(hash元素指针)，该指针指向一个基本连续的数据区。</div><div class="line">该数据区中存放的是经hash之后的键-值对&lt;key',value'&gt;，即ngx_hash_elt_t结构中的字段&lt;name,value&gt;。</div><div class="line">每一个这样的数据区存放的键-值对&lt;key',value'&gt;可以是一个或多个。</div><div class="line"> */</span></div><div class="line"></div><div class="line"><span class="keyword">ngx_int_t</span></div><div class="line">ngx_hash_init(<span class="keyword">ngx_hash_init_t</span> *hinit, <span class="keyword">ngx_hash_key_t</span> *names, <span class="keyword">ngx_uint_t</span> nelts)</div><div class="line">&#123;</div><div class="line">    u_char          *elts;</div><div class="line">    <span class="keyword">size_t</span>           len;</div><div class="line">    u_short         *test;</div><div class="line">    <span class="keyword">ngx_uint_t</span>       i, n, key, size, start, bucket_size;</div><div class="line">    <span class="keyword">ngx_hash_elt_t</span>  *elt, **buckets;</div><div class="line"><span class="comment">//允许的hash桶的最大数量为0，错误</span></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;max_size == <span class="number">0</span>) &#123;</div><div class="line">        ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                      <span class="string">"could not build %s, you should "</span></div><div class="line">                      <span class="string">"increase %s_max_size: %i"</span>,</div><div class="line">                      hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size);</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//对于数组中的每个元素，如果hash元素大小大于桶的容量，出错</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (hinit-&gt;bucket_size &lt; NGX_HASH_ELT_SIZE(&amp;names[n]) + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))</div><div class="line">        &#123;</div><div class="line">            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"could not build %s, you should "</span></div><div class="line">                          <span class="string">"increase %s_bucket_size: %i"</span>,</div><div class="line">                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//分配一块2*max_size大小的空间，没有在内存池上分配，只是临时的</span></div><div class="line">    test = ngx_alloc(hinit-&gt;max_size * <span class="keyword">sizeof</span>(u_short), hinit-&gt;pool-&gt;<span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (test == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//桶的大小减去4字节</span></div><div class="line">    bucket_size = hinit-&gt;bucket_size - <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line"><span class="comment">//确定起始位置</span></div><div class="line">    start = nelts / (bucket_size / (<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    start = start ? start : <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;max_size &gt; <span class="number">10000</span> &amp;&amp; nelts &amp;&amp; hinit-&gt;max_size / nelts &lt; <span class="number">100</span>) &#123;</div><div class="line">        start = hinit-&gt;max_size - <span class="number">1000</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (size = start; size &lt;= hinit-&gt;max_size; size++) &#123;</div><div class="line"></div><div class="line">        ngx_memzero(test, size * <span class="keyword">sizeof</span>(u_short));</div><div class="line"><span class="comment">//标记1：此块代码是检查bucket大小是否够分配hash数据</span></div><div class="line">        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">            <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"><span class="comment">//计算key和names中所有name长度，并保存在test[key]中</span></div><div class="line">            key = names[n].key_hash % size;</div><div class="line">            test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: %ui %ui \"%V\""</span>,</div><div class="line">                          size, key, test[key], &amp;names[n].key);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (test[key] &gt; (u_short) bucket_size) &#123;</div><div class="line">                <span class="keyword">goto</span> next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">goto</span> found;</div><div class="line"></div><div class="line">    next:</div><div class="line"></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size = hinit-&gt;max_size;</div><div class="line"></div><div class="line">    ngx_log_error(NGX_LOG_WARN, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                  <span class="string">"could not build optimal %s, you should increase "</span></div><div class="line">                  <span class="string">"either %s_max_size: %i or %s_bucket_size: %i; "</span></div><div class="line">                  <span class="string">"ignoring %s_bucket_size"</span>,</div><div class="line">                  hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size,</div><div class="line">                  hinit-&gt;name, hinit-&gt;bucket_size, hinit-&gt;name);</div><div class="line"></div><div class="line">found:<span class="comment">//找到</span></div><div class="line"><span class="comment">//test[i]初始化为4</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        test[i] = <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">    &#125;</div><div class="line"> <span class="comment">/** </div><div class="line">  * 标记2：与标记1代码基本相同，但此块代码是再次计算所有hash数据的总长度(标记1的检查已通过)</div><div class="line">  但此处的test[i]已被初始化为4，即相当于后续的计算再加上一个void指针的大小。</div><div class="line">  */</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        key = names[n].key_hash % size;</div><div class="line">        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (test[i] == <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//对test[i]按ngx_cacheline_size对齐(32位平台，ngx_cacheline_size=32)  </span></div><div class="line">        test[i] = (u_short) (ngx_align(test[i], ngx_cacheline_size));</div><div class="line">        len += test[i];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//在内存池中分配hash头及buckets数组(size个ngx_hash_elt_t*结构)</span></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;hash == <span class="literal">NULL</span>) &#123;</div><div class="line">        hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_wildcard_t</span>)</div><div class="line">                                             + size * <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_elt_t</span> *));</div><div class="line">        <span class="keyword">if</span> (hinit-&gt;hash == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_free(test);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buckets = (<span class="keyword">ngx_hash_elt_t</span> **)</div><div class="line">                      ((u_char *) hinit-&gt;hash + <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_wildcard_t</span>));</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buckets = ngx_pcalloc(hinit-&gt;pool, size * <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_elt_t</span> *));</div><div class="line">        <span class="keyword">if</span> (buckets == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_free(test);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    elts = ngx_palloc(hinit-&gt;pool, len + ngx_cacheline_size);</div><div class="line">    <span class="keyword">if</span> (elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        ngx_free(test);</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    elts = ngx_align_ptr(elts, ngx_cacheline_size);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (test[i] == <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buckets[i] = (<span class="keyword">ngx_hash_elt_t</span> *) elts;</div><div class="line">        elts += test[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        test[i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        key = names[n].key_hash % size;</div><div class="line">        elt = (<span class="keyword">ngx_hash_elt_t</span> *) ((u_char *) buckets[key] + test[key]);</div><div class="line"></div><div class="line">        elt-&gt;value = names[n].value;</div><div class="line">        elt-&gt;len = (u_short) names[n].key.len;</div><div class="line"></div><div class="line">        ngx_strlow(elt-&gt;name, names[n].key.data, names[n].key.len);</div><div class="line"></div><div class="line">        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (buckets[i] == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        elt = (<span class="keyword">ngx_hash_elt_t</span> *) ((u_char *) buckets[i] + test[i]);</div><div class="line"></div><div class="line">        elt-&gt;value = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngx_free(test);</div><div class="line"></div><div class="line">    hinit-&gt;hash-&gt;buckets = buckets;</div><div class="line">    hinit-&gt;hash-&gt;size = size;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">ngx_str_t</span>   val;</div><div class="line">        <span class="keyword">ngx_uint_t</span>  key;</div><div class="line"></div><div class="line">        elt = buckets[i];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (elt == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: NULL"</span>, i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (elt-&gt;value) &#123;</div><div class="line">            val.len = elt-&gt;len;</div><div class="line">            val.data = &amp;elt-&gt;name[<span class="number">0</span>];</div><div class="line"></div><div class="line">            key = hinit-&gt;key(val.data, val.len);</div><div class="line"></div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: %p \"%V\" %ui"</span>, i, elt, &amp;val, key);</div><div class="line"></div><div class="line">            elt = (<span class="keyword">ngx_hash_elt_t</span> *) ngx_align_ptr(&amp;elt-&gt;name[<span class="number">0</span>] + elt-&gt;len,</div><div class="line">                                                   <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>常用的有创建 hash 和在 hash 中进行查找两个操作，对于创建hash的操作,过程一般为：  </p>
<ul>
<li>构造一个 <code>ngx_hash_key_t</code> 为成员的数组， 包含 key, value 和 使用key计算出的一个hash值  </li>
<li>构建一个 <code>ngx_hash_init_t</code> 结构体的变量， 其中包含了 <code>ngx_hash_t</code> 的成员， 为hash的结构体， 还包括一些其他初始设置，如bucket的大小，内存池等   </li>
<li>调用 <code>ngx_hash_init</code> 传入 <code>ngx_hash_init_t</code> 结构， <code>ngx_hash_key_t</code> 的数组，和数组的长度， 进行初始化，这样 <code>ngx_hash_init_t</code>的hash成员就是我们要的hash结构  </li>
</ul>
<p>查找的过程很简单</p>
<ul>
<li>计算 key 的hash值  </li>
<li>使用 <code>ngx_hash_find</code> 进行查找，需要同时传入 hash值和key ,返回的就是value的指针
需要注意的是，nginx 的 hash 在查找时使用的是分桶后线性查找法，因此当分桶数确定时查找效率同其中的总 key-val 对数量成反比。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx源码学习中的数据结构，主要包括数组结构&lt;code&gt;ngx_array_t&lt;/code&gt;、链表结构&lt;code&gt;ngx_list_t&lt;/code&gt;、队列结构&lt;code&gt;ngx_queue_t&lt;/code&gt;、哈希结构&lt;code&gt;ngx_hash_t&lt;/code&gt;、字符串结构&lt;code&gt;ngx_string_t&lt;/code&gt;。在内存池的基础之上进一步整合组织数据。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>笔记：虚函数实现机制</title>
    <link href="http://abumaster.com/2017/06/10/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://abumaster.com/2017/06/10/笔记：虚函数实现机制/</id>
    <published>2017-06-10T15:26:43.000Z</published>
    <updated>2017-06-11T00:20:28.488Z</updated>
    
    <content type="html"><![CDATA[<p>C++的虚函数是实现多态的一种方法，那么它的实现机制如何，笔记记录如下。  </p>
<a id="more"></a>
<p>虚函数的实现机制就是：虚表和虚指针。虚函数在运行期间来确定类型，即动态绑定，而构造函数在构造对象的时候就应该知道类型，这也是构造函数不能声明为虚函数的原因。<br>先看一个例子，假设两个类A和B：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://ooo.0o0.ooo/2017/06/11/593c8c1a67649.png" alt="">  </p>
<p>虚函数地址的获得<br><code>A *p = new B;</code><br>p:是个指针。<br><code>(int *)p</code>：转换成 int 类型的指针<br><code>*(int *)p</code>：把转换成int 类型指针p 的内容取出<br><code>(int *)( *(int *)p)</code>：在转换成 int 类型的指针<br><code>(int *)( *(int *)p) +0</code>：取出第一个元素的地址<br><code>*((int *)( *(int *)p) +0)</code>：得到第一个元素的内容<br><code>(void *)(*((int *)( *(int *)p) +0))</code>：得到第一个元素的地址  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++的虚函数是实现多态的一种方法，那么它的实现机制如何，笔记记录如下。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx源码学习-内存池</title>
    <link href="http://abumaster.com/2017/06/08/Nginx%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <id>http://abumaster.com/2017/06/08/Nginx源码学习-内存池/</id>
    <published>2017-06-08T08:45:30.000Z</published>
    <updated>2017-06-09T08:40:44.377Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Nginx</strong> 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占用内存少，并发能力强。其编写简洁高效，有诸多学习之处。</p>
<a id="more"></a>
<div class="note info"><p>C/C++ 的内存管理，往往让人头痛。要时刻注意分配足够的内存，并在不用的时候记得释放内存，直接使用系统调用 <code>malloc/free, new/delete</code> 会有如下的一些弊端：  </p>
<ul>
<li>系统调用时根据最先匹配、最优匹配原则，有时会合并，产生额外的开销；  </li>
<li>频繁使用，会产生大量的内存碎片，降低程序运行速度；  </li>
<li>稍有不慎容易造成内存泄漏。  </li>
</ul>
<p><strong>内存池（memory pool）</strong>的出现代替了直接的系统调用。它是首先向系统申请足够大的空间，当需要时向内存池申请，而不是来进行系统调用，使用内存池可以对应解决以上的缺陷。  </p>
</div>  
<h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><p><em>注：Nginx源码中用 xx_xx_t 来表示type；用 xx_xx_s 表示struct。</em><br>在源码 <code>/Src/Core/Ngx_palloc.h{c}</code> 中<br><strong>内存池数据块类型 ngx_pool_data_t</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    u_char               *last;<span class="comment">//指向已用的数据结尾</span></div><div class="line">    u_char               *end;<span class="comment">//指向存储空间结尾(内存池结束位置)</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>           *next;<span class="comment">//下一个内存块</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>            failed;<span class="comment">//内存池分配错误次数</span></div><div class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</div></pre></td></tr></table></figure></p>
<p><strong>内存池头部结构 ngx_pool_s</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ngx_pool_s &#123;</div><div class="line">    <span class="keyword">ngx_pool_data_t</span>       d; <span class="comment">//内存池数据块</span></div><div class="line">    <span class="keyword">size_t</span>                max; <span class="comment">//内存池数据块的最大值</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>           *current; <span class="comment">//指向当前的内存池</span></div><div class="line">    <span class="keyword">ngx_chain_t</span>          *chain;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>     *large; <span class="comment">//指向大块内存</span></div><div class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup; <span class="comment">//释放内存时的回调函数</span></div><div class="line">    <span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>; <span class="comment">//日志信息</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_s 	<span class="keyword">ngx_pool_t</span>;</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-8/29000766.jpg" alt="">  </p>
<h4 id="内存池的基本操作"><a href="#内存池的基本操作" class="headerlink" title="内存池的基本操作"></a>内存池的基本操作</h4><p>内存池对外提供的函数如下：  </p>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建内存池</td>
<td><code>ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);</code></td>
</tr>
<tr>
<td>销毁内存池</td>
<td><code>void ngx_destroy_pool(ngx_pool_t *pool);</code></td>
</tr>
<tr>
<td>重置内存池</td>
<td><code>void ngx_reset_pool(ngx_pool_t *pool);</code></td>
</tr>
<tr>
<td>内存申请（对齐）</td>
<td><code>void *ngx_palloc(ngx_pool_t *pool, size_t size);</code></td>
</tr>
<tr>
<td>内存申请（不对齐）</td>
<td><code>void *ngx_pnalloc(ngx_pool_t *pool, size_t size);</code></td>
</tr>
<tr>
<td>内存申请并且置为0</td>
<td><code>void *ngx_pcalloc(ngx_pool_t *pool, size_t size);</code></td>
</tr>
<tr>
<td>内存清除</td>
<td><code>ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);</code></td>
</tr>
</tbody>
</table>
<h5 id="封装的系统调用"><a href="#封装的系统调用" class="headerlink" title="封装的系统调用"></a>封装的系统调用</h5><p>两个函数 <code>ngx_alloc</code> 和 <code>ngx_calloc</code> 对系统调用 <code>malloc</code> 进行封装。源码<code>./src/Os/Unix（Win32）/ngx_alloc.h/.c</code>。<br>调用malloc申请内存。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>  *p;</div><div class="line"></div><div class="line">    p = <span class="built_in">malloc</span>(size);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</div><div class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</div><div class="line">                      <span class="string">"malloc(%uz) failed"</span>, size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"malloc: %p:%uz"</span>, p, size);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>申请内存并且置0
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></div><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_calloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>  *p;</div><div class="line"></div><div class="line">    p = ngx_alloc(size, <span class="built_in">log</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p) &#123;</div><div class="line">        ngx_memzero(p, size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="内存池的创建"><a href="#内存池的创建" class="headerlink" title="内存池的创建"></a>内存池的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_pool_t</span> *</div><div class="line">ngx_create_pool(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//申请内存并对齐</span></div><div class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//sizeof(ngx_pool_t) = 40B	sizeof(ngx_pool_data_t) = 16B</span></div><div class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);<span class="comment">//指针设置到跳过内存池的头结构</span></div><div class="line">    p-&gt;d.end = (u_char *) p + size;<span class="comment">//内存池的结尾</span></div><div class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;d.failed = <span class="number">0</span>;</div><div class="line"><span class="comment">//可用的最大字节数</span></div><div class="line">    size = size - <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</div><div class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</div><div class="line"><span class="comment">//其他的一些设置</span></div><div class="line">    p-&gt;current = p;</div><div class="line">    p-&gt;chain = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;large = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"><span class="comment">//它调用了系统函数</span></div><div class="line"><span class="comment">/*</div><div class="line">函数：void * memalign (size_t boundary, size_t size) </div><div class="line">函数memalign将分配一个由size指定大小，地址是boundary的倍数的内存块。</div><div class="line">参数boundary必须是2的幂！函数memalign可以分配较大的内存块，并且可以为返回的地址指定粒度。</div><div class="line">*/</span></div></pre></td></tr></table></figure>
<p>nginx对内存的管理分为大内存与小内存，当某一个申请的内存大于某一个值时，就需要从大内存中分配空间，否则从小内存中分配空间。<br>nginx中的内存池是在创建的时候就设定好了大小，在以后分配小块内存的时候，如果内存不够，则是重新创建一块内存串到内存池中，而不是将原有的内存池进行扩张。当要分配大块内存是，则是在内存池外面再分配空间进行管理的，称为大块内存池。  </p>
<h5 id="内存的申请"><a href="#内存的申请" class="headerlink" title="内存的申请"></a>内存的申请</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !(NGX_DEBUG_PALLOC)</span></div><div class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;<span class="comment">//申请的空间小于内存池的最大空间</span></div><div class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//申请小内存</span></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></div><div class="line"></span>&#123;</div><div class="line">    u_char      *m;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"></div><div class="line">    p = pool-&gt;current;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        m = p-&gt;d.last;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (align) &#123;</div><div class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</div><div class="line">        &#125;<span class="comment">//是否需要对齐，需要则按NGX_ALIGNMENT对齐</span></div><div class="line">	</div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</div><div class="line">        	<span class="comment">//未使用的空间大于申请的，则不需要链接新的内存块了</span></div><div class="line">            p-&gt;d.last = m + size;<span class="comment">//移动使用空间末尾指针</span></div><div class="line">            <span class="keyword">return</span> m;<span class="comment">//返回新申请空间开始的指针(m, m+size)空间</span></div><div class="line">        &#125;</div><div class="line">		<span class="comment">//空间不够向链表的下一个节点查询</span></div><div class="line">        p = p-&gt;d.next;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">while</span> (p);</div><div class="line">    <span class="comment">//遍历完还是没有找到，那么再申请</span></div><div class="line">    <span class="keyword">return</span> ngx_palloc_block(pool, size);</div><div class="line">&#125;</div><div class="line"><span class="comment">//内存对齐</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                   \</div><div class="line">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    u_char      *m;</div><div class="line">    <span class="keyword">size_t</span>       psize;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>;</div><div class="line"><span class="comment">//计算第一块的大小</span></div><div class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</div><div class="line"><span class="comment">//申请与第一块内存相同大小的空间并用m指向</span></div><div class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//新的内存块，变为内存池类型</span></div><div class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</div><div class="line"><span class="comment">//初始化其中的数据</span></div><div class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</div><div class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</div><div class="line"><span class="comment">//申请内存的结尾设置</span></div><div class="line">    m += <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_data_t</span>);</div><div class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</div><div class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</div><div class="line"><span class="comment">//将新的内存块连接到内存池链表中</span></div><div class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</div><div class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</div><div class="line">            pool-&gt;current = p-&gt;d.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    p-&gt;d.next = <span class="keyword">new</span>;</div><div class="line"><span class="comment">//返回size大小的内存的起始指针(m, m+size)空间</span></div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于申请小的内存（申请大小 &lt; 设定的内存池数据块大小），基本流程就是，在内存池的链表中找空闲的内存，不满足条件的话再创建新的内存块并连接到内存池链表中，注意在内存池中申请内存，只是<strong>控制移动指针</strong>而已，这时注意字节的对齐，保证读写的高效。  </p>
<p><strong>大内存块的申请</strong><br>应用场景：当申请的内存比设置内存块大小大的时候，不能通过链接内存块的方法申请内存，这时需要申请大块内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//大块内存的结构，类似于一个链表，alloc指向实际的内存</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_large_s  <span class="keyword">ngx_pool_large_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_pool_large_s &#123;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>     *next;</div><div class="line">    <span class="keyword">void</span>                 *alloc;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>              *p;</div><div class="line">    <span class="keyword">ngx_uint_t</span>         n;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</div><div class="line"><span class="comment">//直接调用申请size大小的空间，p指向</span></div><div class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    n = <span class="number">0</span>;</div><div class="line"><span class="comment">//在大内存块链表中查找空的large</span></div><div class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</div><div class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</div><div class="line">            large-&gt;alloc = p;</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;<span class="comment">//为了效率，查找3次没有找到跳出</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//重新分配一块large sizeof(ngx_pool_large_t) = 8B</span></div><div class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</div><div class="line">        ngx_free(p);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//链接（插入）到链表的头</span></div><div class="line">    large-&gt;alloc = p;</div><div class="line">    large-&gt;next = pool-&gt;large;</div><div class="line">    pool-&gt;large = large;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-9/75412545.jpg" alt=""><br>过程：在已经有的大块内存中查找 <code>large-&gt;alloc == NULL</code> 的节点，不存在则会新建一个 <code>ngx_pool_large_s</code> 的节点，插入大块内存链表的头，并且使 <code>large-&gt;alloc == new</code>。  </p>
<h5 id="内存池的重置和清理"><a href="#内存池的重置和清理" class="headerlink" title="内存池的重置和清理"></a>内存池的重置和清理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></div><div class="line"><span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">ngx_pool_t</span>        *p;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</div><div class="line"><span class="comment">//重置所有大块内存区</span></div><div class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</div><div class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</div><div class="line">            ngx_free(l-&gt;alloc);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//重置所有小块内存区</span></div><div class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</div><div class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</div><div class="line">        p-&gt;d.failed = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pool-&gt;current = pool;</div><div class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</div><div class="line">    pool-&gt;large = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">ngx_int_t</span></div><div class="line">ngx_pfree(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</div><div class="line"><span class="comment">//只针对大内存进行释放</span></div><div class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</div><div class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</div><div class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                           <span class="string">"free: %p"</span>, l-&gt;alloc);</div><div class="line">            ngx_free(l-&gt;alloc);</div><div class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> NGX_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_DECLINED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在使用内存池时，可以使用<code>ngx_palloc</code>进行分配，使用<code>ngx_pfree</code>释放。而对于大内存，这样做是没有问题的，而对于小内存就不一样了，分配的小内存，不会进行释放。因为大内存块的分配只对前3个内存块进行检查，否则就直接分配内存，所以大内存块的释放必须及时。<br><code>void ngx_destroy_pool(ngx_pool_t *pool)</code> 函数是用于完全释放内存池中申请的空间。  </p>
<p>Nginx内存池支持通过回调函数，对外部资源的清理。<code>ngx_pool_cleanup_t</code>是回调函数结构体，它在内存池中以链表形式保存，在内存池进行销毁时，循环调用这些回调函数对数据进行清理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_cleanup_s  <span class="keyword">ngx_pool_cleanup_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_pool_cleanup_s &#123;</div><div class="line">    ngx_pool_cleanup_pt   handler;</div><div class="line">    <span class="keyword">void</span>                 *data;</div><div class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-9/40148825.jpg" alt="">   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt; 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占用内存少，并发能力强。其编写简洁高效，有诸多学习之处。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-网络IPC</title>
    <link href="http://abumaster.com/2017/06/05/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9CIPC/"/>
    <id>http://abumaster.com/2017/06/05/UNIX环境高级编程-网络IPC/</id>
    <published>2017-06-05T02:34:09.000Z</published>
    <updated>2017-06-07T02:37:54.501Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程， 第16章 网络IPC：套接字 读书笔记。不同计算机进行通信的机制。</p>
<a id="more"></a>
<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p><strong>套接字</strong> 是通信端点的对象，也有套接字描述符，类似于文件描述符，许多操作也可以直接应用到套接字描述符上。创建一个套接字：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line"><span class="comment">//成功返回套接字描述符，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p>参数说明：<br><em>domain</em> 确定通信的特性，通常有 <code>AF_INET</code> 最常用，表示IPv4因特网域。<br><em>type</em> 套接字类型，tcp和udp的通信协议分别对应 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code> ，面向连接的字节流和面向无连接的报文。<br><em>protocol</em> 通常为零，默认协议。  </p>
<p>关闭套接字：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</div></pre></td></tr></table></figure></p>
<p><em>how</em> 的类别决定关闭的方式：  </p>
<ul>
<li>SHUT_RD 关闭读端，无法从套接字读取数据；  </li>
<li>SHUT_WR 关闭写端，无法向套接字写数据；  </li>
<li>SHUT_RDWR 同时关闭读写，无法向套接字读写数据。  </li>
</ul>
<p>有 <code>close</code> 为何还要用 <code>shutdown</code> 这是因为：<code>close</code> 的调用是在最后一个活动关闭时才释放，而 <code>shutdown</code> 可以使套接字处于非活动状态，不用关心引用的多少；同时，也可以关闭一端。  </p>
<h4 id="关于地址"><a href="#关于地址" class="headerlink" title="关于地址"></a>关于地址</h4><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>字节序是处理器的架构特性，指示像整数这样的大数据类型的内部字节顺序。分为<em>大端字节序（big-endian）</em>和<em>小端模式（little-endian）</em>。<br>TCP/IP协议使用的是大端字节序，异构计算机可以直接进行通信，不会混淆。字节序的转换可以在本地计算机上完成，常用到的函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);<span class="comment">//返回以网络字节序表示的32位整数</span></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);<span class="comment">//返回以网络字节序表示的16位整数</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netint32);<span class="comment">//返回以主机字节序表示的32位整数</span></div><div class="line"><span class="keyword">uint32_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);<span class="comment">//返回以主机字节序表示的16位整数</span></div></pre></td></tr></table></figure></p>
<p>大端：低地址放着高位数据，高地址放着低位数据。<br>小端：低地址放着低位数据，高地址放着高位数据。  </p>
<h5 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h5><p>地址标识了特定通信域的套接字端点，不同格式的地址传入套接字函数，可以用一个统一的结构来保存这个地址，被转换为 <code>sockaddr</code> 结构。因特网地址则定义在：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="keyword">struct</span> in_addr &#123;</div><div class="line">	<span class="keyword">in_addr_t</span> s_addr; <span class="comment">//IPv4地址</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> sockaddr_in &#123;</div><div class="line">	<span class="keyword">sa_family_t</span> sin_family;</div><div class="line">	<span class="keyword">in_port_t</span> sin_port;</div><div class="line">	<span class="keyword">struct</span> in_addr sin_addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>in_port_t</code> 为 <code>uint16_t</code> 类型的，而 <code>in_addr_t</code> 是 <code>uint32_t</code> 类型的。不同的系统下可以自由实现和添加额外的字段。<br>有时，地址的格式不易于人去查看，因此要转换为表达式格式（p），点分十进制。计算机理解的是数值格式（n）。BSD网络软件提供了函数 <code>inet_addr</code> 和 <code>inet_ntoa</code> 用于两者之间的转换。只用于IPv4。下面的函数则可以适用不同协议。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str,\</div><div class="line">						<span class="keyword">socklen_t</span> size)</span></span>;<span class="comment">//成功返回地址字符串指针</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</div><div class="line"><span class="comment">//成功返回1，无效返回0，失败返回-1</span></div></pre></td></tr></table></figure></p>
<h5 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h5><p><strong>1.获得给定计算机的主机信息</strong><br>通过调用 <code>gethostent</code> 函数，返回一个 <code>hostent</code> 结构的数据结构。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> hostent *<span class="title">gethostent</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//成功返回指针，失败返回NULL</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sethostent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>; <span class="comment">//打开主机数据文件，</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endhostent</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//关闭</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> hostent &#123;</div><div class="line">	<span class="keyword">char</span> *h_name; <span class="comment">//host name</span></div><div class="line">	<span class="keyword">char</span> **h_aliases; <span class="comment">//pointer of alternate host name array</span></div><div class="line">	<span class="keyword">int</span> h_addrtype; <span class="comment">//address type</span></div><div class="line">	<span class="keyword">int</span> h_length;</div><div class="line">	<span class="keyword">char</span> **h_addr_list; <span class="comment">//pointer to array of network addresses</span></div><div class="line">	.</div><div class="line">	.</div><div class="line">	.</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>返回地址为网络字节序。<br><strong>2.获取网络名字和网络号</strong>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnetbyaddr</span><span class="params">(<span class="keyword">unint32_t</span> net, <span class="keyword">int</span> type)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnetbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnet</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnetent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endnetent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> netent &#123;</div><div class="line">	<span class="keyword">char</span> *n_name;</div><div class="line">	<span class="keyword">char</span> **n_aliasses;</div><div class="line">	<span class="keyword">int</span> n_addrtype;</div><div class="line">	<span class="keyword">uint32_t</span> n_net;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样，网络号按照网络字节序返回，地址类型为一个地址族常量（AF_INET）。<br><strong>3.服务和端口号</strong><br>服务是由地址的端口号部分表示的。每个服务由一个唯一的、熟知的端口号表示。如ssh的端口号是22，http的端口号80等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="comment">//由服务名字来获得信息</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</div><div class="line"><span class="comment">//由端口号来获得信息</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</div><div class="line"><span class="comment">//顺序扫描服务数据库</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservenmt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setservent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endservent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> servent &#123;</div><div class="line">	<span class="keyword">char</span> *s_name;</div><div class="line">	<span class="keyword">char</span> **s_aliases;</div><div class="line">	<span class="keyword">int</span> s_port;</div><div class="line">	<span class="keyword">char</span> *s_proto;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>4.两个函数</strong><br>函数 <code>getaddrinfo</code> 允许将一个主机名和服务名映射到一个地址。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">const</span> <span class="keyword">char</span> *service, \</div><div class="line">				<span class="keyword">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result )</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> addrinfo &#123;</div><div class="line">    <span class="keyword">int</span> ai_flags;        <span class="comment">//AI_PASSIVE,AI_CANONNAME,AI_NUMERICHOST</span></div><div class="line">    <span class="keyword">int</span> ai_family;        <span class="comment">//AF_INET,AF_INET6</span></div><div class="line">    <span class="keyword">int</span> ai_socktype;    <span class="comment">//SOCK_STREAM,SOCK_DGRAM</span></div><div class="line">    <span class="keyword">int</span> ai_protocol;    <span class="comment">//IPPROTO_IP, IPPROTO_IPV4, IPPROTO_IPV6 etc.</span></div><div class="line">    <span class="keyword">size_t</span> ai_addrlen;            <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">char</span>* ai_canonname;            <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">struct</span> sockaddr* ai_addr;    <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">struct</span> addrinfo* ai_next;    <span class="comment">//must be zero or a null pointer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>hostname</em>:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)<br><em>service</em>：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等<br><em>hints</em>：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。<br><em>result</em>：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。<br><em>返回值</em>：0成功，非0出错  </p>
<p>函数 <code>getnameinfo</code> 将地址转换成主机名或服务名。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="keyword">socklen_t</span> salen, <span class="keyword">char</span> *host, \</div><div class="line">				<span class="keyword">size_t</span> hostlen, <span class="keyword">char</span> *serv, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</div></pre></td></tr></table></figure></p>
<p>例子：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//using getnameinfo()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HO 128</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sockaddr_in sa_in;</div><div class="line">	<span class="keyword">char</span> host[MAX_HO], service[MAX_HO];</div><div class="line">	<span class="keyword">int</span> flags;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</div><div class="line">		err_sys(<span class="string">"Usage: a.out &lt;IP&gt; &lt;port&gt;"</span>);</div><div class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">	<span class="comment">//init addr</span></div><div class="line">	sa_in.sin_family = AF_INET;</div><div class="line">	sa_in.sin_port = htons(port);</div><div class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;sa_in.sin_addr.s_addr);</div><div class="line">	flags = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	err = getnameinfo((<span class="keyword">struct</span> sockaddr *)(&amp;sa_in), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr),\</div><div class="line">			host, <span class="keyword">sizeof</span>(host), service, <span class="keyword">sizeof</span>(service), flags);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		gai_strerror(err);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"host := %s ; service := %s\n"</span>, host, service);</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="套接字与地址"><a href="#套接字与地址" class="headerlink" title="套接字与地址"></a>套接字与地址</h5><p>套接字中没有包含太多信息，只是一个描述符，并不知道通信的端口和I地址，而建立客户和服务器之间的连接时，往往需要这些信息，所以，在编程过程中要将socket函数产生的套接字与地址相关联。地址结构类似：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IPv4  </span></div><div class="line"><span class="keyword">struct</span> sockaddr_in  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_len;      <span class="comment">//IPv4地址长度  </span></div><div class="line">    <span class="keyword">short</span> <span class="keyword">int</span>      sin_family;   <span class="comment">//指代协议簇，在TCP套接字编程只能是AF_INET  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;     <span class="comment">//存储端口号（使用网络字节顺序），数据类型是一个16为的无符号整形类型  </span></div><div class="line">    <span class="keyword">struct</span>         in_addr sin_addr;<span class="comment">//存储IP地址，IP地址是一个in_add结构体（结构在下面）  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];     <span class="comment">//为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节  </span></div><div class="line">&#125;; </div><div class="line"><span class="keyword">struct</span> in_addr  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;   <span class="comment">//按照网络字节顺序存储IP地址  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这时需要一个函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第二个参数就是套接字地址结构对象了，它将与第一个参数套接字描述符进行绑定，这里的套接字地址结构参数的类型是通用套接字地址结构类型，因此，在实际调用的时候需要强制转换了。  </p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>在处理面向连接的网络服务时，开始交换数据前，必须在请求服务的套接字（客户端）和提供服务的套接字（服务器）之间建立连接。 <code>connect</code> 函数可以建立这样一个连接。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div><div class="line"><span class="comment">//成功返回0，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p><em>addr</em> 表示是想与之通信的服务器地址。  </p>
<p><strong>服务器</strong>调用 <code>listen</code> 来宣告可以接受连接请求。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>;</div><div class="line"><span class="comment">//成功返回文件描述符，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p><em>backlog</em> 指定了可以连接的数量，超过这一个值则拒绝连接。<br>服务器能够接受到请求，那么会再调用 <code>accept</code> 来获得连接请求并建立连接。<br>它返回的是调用 <code>connect</code> 函数的客户端的套接字描述符。如果不关心客户端的地址信息，则可以忽略后两个参数，将它们设为NULL。当 <code>accept</code> 没有连接请求时，服务器会阻塞直到下一个请求的到来，另外可以使用 <code>pool</code> 和 <code>select</code> 来等待一个请求的到来。<br>基本流程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * 套接字类型，地址，长度，可以连接数量</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> alen, </div><div class="line">		<span class="keyword">int</span> qlen)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</div><div class="line">	<span class="comment">//1.创建套接字</span></div><div class="line">	<span class="keyword">if</span>((fd = socket(addr-&gt;sa_family, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">	<span class="comment">//2.绑定套接字和地址</span></div><div class="line">	<span class="keyword">if</span>(bind(fd, addr, alen) &lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		err = errno;</div><div class="line">		<span class="keyword">goto</span> errout;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//3.准备连接</span></div><div class="line">	<span class="keyword">if</span>(type == SOCK_STREAM || type == SOCK_SEQPACKET)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(listen(fd, qlen) &lt; <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			err = errno;</div><div class="line">			<span class="keyword">goto</span> errout;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">errout:</div><div class="line">	close(fd);</div><div class="line">	errno = err;</div><div class="line">	<span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><strong>send和recv函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></div><div class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);  </div><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</div></pre></td></tr></table></figure></p>
<p>它们的前三个参数类似于<code>read</code> 和 <code>write</code>函数，最后一个参数一般为0。<br>send函数的参数  </p>
<ul>
<li>sockfd：指定发送端套接字描述符。</li>
<li>buff：存放要发送数据的缓冲区</li>
<li>nbytes: 实际要发送的数据的字节数</li>
<li>flags： 一般设置为0  </li>
</ul>
<p>recv函数的参数  </p>
<ul>
<li>sockfd: 接收端套接字描述符</li>
<li>buff：用来存放recv函数接收到的数据的缓冲区</li>
<li>nbytes: 指明buff的长度</li>
<li>flags: 一般设置为0</li>
</ul>
<p><strong>sendto和recvfrom函数</strong><br>这是面向无连接的数据传输，sockfd中不包含地址信息，所以需要指定地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</div><div class="line">    		<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="keyword">int</span> destlen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</div><div class="line">			<span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程， 第16章 网络IPC：套接字 读书笔记。不同计算机进行通信的机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-进程间通信</title>
    <link href="http://abumaster.com/2017/05/30/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://abumaster.com/2017/05/30/UNIX环境高级编程-进程间通信/</id>
    <published>2017-05-30T07:12:26.000Z</published>
    <updated>2017-06-04T13:00:38.863Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第14章 进程间通信IPC读书笔记。</p>
<a id="more"></a>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/36378614.jpg" alt="">  </p>
<div class="note primary"><p><strong>进程间通信</strong>( <em>inteprocess communication</em> ) 的目的是：
进行数据传输，不同进程协作处理一些数据；资源共享，多个进程间共享数据；通知事件，一个进程向其他进程通知一个事件发生；<br>进程间的通信主要分为：pipe，fifo，消息队列，信号量，共享存储，uds，套接字。</p>
</div>  
<h4 id="pipe和fifo"><a href="#pipe和fifo" class="headerlink" title="pipe和fifo"></a>pipe和fifo</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>pipe又称管道，提供了一个半双工的父子进程之间通信的机制。创建管道很简单：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>
<p>fd[0]可以用来读数据，fd[1]可以用来写数据。它们中间会有一个缓冲区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmd,<span class="keyword">const</span> <span class="keyword">char</span>* type)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE* fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>打开的是一个可执行的命令，<code>type</code>只能是 <code>r</code> 和 <code>w</code> 可能会返回执行命令的结果。实现上我们值得思考一下，就是 <code>popen</code> 通常来说肯定是创建了一个进程，然后FILE里面记录的 <code>fd</code> 必然和这个进程号做了一个绑定。不然我们在 <code>pclose</code> 使用 <code>FILE*</code>必须能够找到，我们应该 <code>wait</code> 什么进程终止。 在 <code>pclose</code> 必须 <code>fclose</code> 掉句柄，不然如果作为一输入命令的话那么会一直等待输入完成。  </p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/1955979.jpg" alt=""><br><strong>实例</strong><br>通过 <code>popen</code> 对输入进行变换的程序。向标准输出一个提示，从标准输入读取一行，使用 <code>popen</code> 可以在标准输入和输出之间添加一个程序来对输入进行变换处理，（当然也可以写成一个函数的形式来解决），基本流程如图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/54057635.jpg" alt=""><br>从标准输入读入字符，将其转换成小写的程序。<br><figure class="highlight c"><figcaption><span>myuclc.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>((c = getchar()) != EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">isupper</span>(c))</div><div class="line">			c=<span class="built_in">tolower</span>(c);</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">putchar</span>(c) == EOF)</div><div class="line">			err_sys(<span class="string">"output error"</span>);</div><div class="line">		<span class="keyword">if</span>(c==<span class="string">'\n'</span>)</div><div class="line">			fflush(<span class="built_in">stdout</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>编译为可执行文件myuclc，然后通过程序调用它。<br><figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">char</span> line[MAXLINE];</div><div class="line">	FILE *fpin;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>((fpin=popen(<span class="string">"./myuclc"</span>,<span class="string">"r"</span>)) == <span class="literal">NULL</span>)</div><div class="line">		err_sys(<span class="string">"popen error"</span>);</div><div class="line">	<span class="keyword">for</span>( ; ;)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">fputs</span>(<span class="string">"prompt&gt; "</span>, <span class="built_in">stdout</span>);</div><div class="line">		fflush(<span class="built_in">stdout</span>);</div><div class="line">		<span class="keyword">if</span>(fgets(line, MAXLINE, fpin) == <span class="literal">NULL</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">fputs</span>(line, <span class="built_in">stdout</span>) == EOF)</div><div class="line">			err_sys(<span class="string">"fputs error to pipe"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(pclose(fpin) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"pclose error"</span>);</div><div class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>  </p>
<p><strong>协同进程</strong><br>当一个程序产生某个过滤程序的输入，并且又读取该过滤程序的输出时，该过滤程序被称为 <em>协同进程coprocess</em> ，<code>popen</code> 只提供连接到另一进程的单向管道，所以需要两个单向管道。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/12251209.jpg" alt="">  </p>
<h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><blockquote>
<p>FIFO通常被称为命名管道，它是一种文件类型.stat结构中的st_mode指明其类型，可以用宏S_ISFIFO 进行测试。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="comment">//成功返回0，失败返回-1</span></div></pre></td></tr></table></figure>
<p>类似于管道，若用<code>write</code>写一个没有进程为读而打开的FIFO，则会产生SIG_PIPE信号，若FIFO最后一个写进程关闭了该FIFO，那么会为读进程产生一个文件结束标志。 
FIFO用途：  </p>
<ul>
<li>将数据从一条管道线传送到另一条，无需创建临时文件；  </li>
<li>用于客户进程-服务器进程的程序中，客户服务器之间传送数据。  </li>
</ul>
<p><strong>实例</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/10176095.jpg" alt=""><br>通常打开FIFO的方式有四种：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY);<span class="comment">//读，阻塞</span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY | O_NONBLOCK);<span class="comment">//非阻塞  </span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY);<span class="comment">//写，阻塞，一直等待</span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY | O_NONBLOCK);<span class="comment">//写，非阻塞</span></div><div class="line"><span class="comment">//阻塞情况下，没有对应端打开也会一直等待不返回</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/70265253.jpg" alt="">  </p>
<div class="note primary"><p><strong>XPS IPC</strong> 即消息队列、信号量、共享存储。</p>
</div>  
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。<br>流程： <code>msgget</code> 创建或打开一个现存的队列， <code>msgsnd</code> 将消息添加到队列尾端， <code>msgrcv</code> 用于从队列中取消息。 
使用 <code>key_t ftok(const char *path, int id);</code>来创建键值， <em>path</em> 必须存在，使用 <em>id</em> 的8位，组合。
消息队列相关的 API 有四个，必须包含的头文件。 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>1.打开或者创建一个队列</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。<br>如果没有消息队列与健值key相对应，并且msgflg中包含了IPC_CREAT标志位或key参数为IPC_PRIVATE时创建新的队列。<br>参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果。<br>调用返回：成功返回消息队列描述字，否则返回-1。  </p>
<p><strong>2.读取消息</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中。msqid为消息队列描述字；消息返回后存储在msgp指向的地址，msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），msgtyp为请求读取的消息类型；读消息标志msgflg可以为以下几个常值的或：  </p>
<ul>
<li>IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG</li>
<li>IPC_EXCEPT 与msgtyp&gt;0配合使用，返回队列中第一个类型不为msgtyp的消息</li>
<li>IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失。</li>
</ul>
<p>调用返回：成功返回读出消息的实际字节数，否则返回-1。  </p>
<p><strong>3.向队列发送一个消息</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定。对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：</p>
<ul>
<li>当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量；</li>
<li>当前消息队列的消息数（单位”个”）不小于消息队列的总容量（单位”字节数”），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节。</li>
</ul>
<p>调用返回：成功返回0，否则返回-1。  </p>
<p><strong>4.垃圾桶函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID。  </p>
<ul>
<li>IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；</li>
<li>IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员。</li>
<li>IPC_RMID：删除msqid标识的消息队列；</li>
</ul>
<p><strong>消息队列编程模型：</strong><br>接受消息端：申明消息类型——&gt; msgget建立消息队列 ——&gt;循环接收消息msgrcv——&gt;结束判断strcmp——&gt;msgctl(IPC_RMID)删除消息<br>发送消息端：申明消息类型——&gt;msgget建立消息队列——&gt;循环输入数据到消息中——&gt;msgsend向队列发送消息——结束判断strcmp——&gt;msgctl删除消息  </p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p><em>信号量（semaphore）</em> 是一个计数器，用于多进程对共享数据的访问。<br><strong>工作原理</strong>，为了获得共享资源，进程需要：  </p>
<ul>
<li>测试控制资源的信号量；  </li>
<li>若此信号量值为正，则可以使用信号量，并将信号量减1，表示使用了一个资源单位；  </li>
<li>若此信号量值为0，进程休眠，直到信号量大于0，进程唤醒，重复上述。  </li>
</ul>
<p><strong>1.semget函数</strong><br>获取或者创建信号量集。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> flag)</span></span>;</div><div class="line"><span class="comment">//成功返回信号量ID，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p>第一个参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget函数并提供一个键，再由系统生成一个相应的信号标识符（semget函数的返回值），只有semget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。<br>第二个参数nsems指定需要的信号量数目，创建新集合的时候非零指定值，引用现有的集合则可以为0。<br>第三个参数flag，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。  </p>
<p><strong>2.semop函数</strong><br>自动执行信号量集合上的操作数组，原子操作，改变信号量的值。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>;</div></pre></td></tr></table></figure></p>
<p>sem_id是由semget返回的信号量标识符，sembuf结构的定义如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sembuf&#123;  </div><div class="line">    <span class="keyword">short</span> sem_num;<span class="comment">//除非使用一组信号量，否则它为0  </span></div><div class="line">    <span class="keyword">short</span> sem_op;<span class="comment">//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，  </span></div><div class="line">                    <span class="comment">//一个是+1，即V（发送信号）操作。  </span></div><div class="line">    <span class="keyword">short</span> sem_flg;<span class="comment">//通常为SEM_UNDO,使操作系统跟踪信号，  </span></div><div class="line">                    <span class="comment">//并在进程没有释放该信号量而终止时，操作系统释放信号量  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>一个例子</strong><br>设置一个信号量，使多进程之间共享。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> semun</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> val;</div><div class="line">	<span class="keyword">struct</span> semid_ds *buf;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//创建信号量</span></div><div class="line">sem_id = semget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span>|IPC_CREAT);</div><div class="line"></div><div class="line"><span class="comment">//初始化信号量，使用前必须这样做</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">union</span> semun sem_union;</div><div class="line"></div><div class="line">	sem_union.val = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union)==<span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">union</span> semun sem_union;</div><div class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"del semvalue error"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//p操作</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sembuf sem_b;</div><div class="line">	sem_b.sem_num = <span class="number">0</span>;</div><div class="line">	sem_b.sem_op = <span class="number">-1</span>;</div><div class="line">	sem_b.sem_flg = SEM_UNDO;</div><div class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//v操作</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sembuf sem_b;</div><div class="line">	sem_b.sem_num = <span class="number">0</span>;</div><div class="line">	sem_b.sem_op = <span class="number">1</span>;</div><div class="line">	sem_b.sem_flg = SEM_UNDO;</div><div class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.semctl函数</strong><br>控制信号量信息。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd,...<span class="comment">/* union semun arg */</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>如果有第四个参数，它通常是一个union semum结构，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> semun&#123;  </div><div class="line">    <span class="keyword">int</span> val;  </div><div class="line">    <span class="keyword">struct</span> semid_ds *buf;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>共享存储允许两个或更多的进程共享以给定的存储区。无需进程间的复制，是一种最快的IPC。多个进程对同一存储区的同步访问。<br><strong>1.shmget函数</strong><br>获取一个共享存储标识符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</div><div class="line"><span class="comment">//成功返回共享存储ID，出错返回-1</span></div></pre></td></tr></table></figure></p>
<p>第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。<br>不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget函数的返回值），只有shmget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。<br>第二个参数，size以字节为单位指定需要共享的内存容量。<br>第三个参数，flag是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。<br><strong>2.shmat函数</strong><br>第一次创建完共享内存时，它还不能被任何进程访问，shmat函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数，是semget返回的存储空间标识；<br>第二个参数，为0，则连接到第一个可用的地址上，推荐使用；非0并且没有指定SHM_RND，则连接到<em>addr</em>指定的地址；<br>第三个参数，是一组标志位，通常为0。<br><strong>3.shmdt函数</strong><br>用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>addr 参数是调用 <code>shmat</code> 的返回值。<br><strong>4.shmctl函数</strong><br>对共享存储段进行多种操作。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数，shmid是shmget函数返回的共享内存标识符。<br>第二个参数，cmd是要采取的操作，它可以取下面的三个值 ：  </p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。  </li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值。  </li>
<li>IPC_RMID：删除共享内存段。<br>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。
shmid_ds结构至少包括以下成员：  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> shmid_ds  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">uid_t</span> shm_perm.uid;  </div><div class="line">    <span class="keyword">uid_t</span> shm_perm.gid;  </div><div class="line">    <span class="keyword">mode_t</span> shm_perm.mode;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>例子</strong><br>设计流程，注意多进程同时读写的问题。<br>创建共享存储，获得共享存储标识符；将共享存储连接到进程空间，获得首地址指针；设置存储空间格式；读写存储区。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第14章 进程间通信IPC读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-高级IO</title>
    <link href="http://abumaster.com/2017/05/26/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/"/>
    <id>http://abumaster.com/2017/05/26/UNIX环境高级编程-高级IO/</id>
    <published>2017-05-26T07:01:48.000Z</published>
    <updated>2017-05-27T08:27:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程，第14章 高级I/O 读书笔记。高级 I/O 包括：非阻塞 I/O，记录锁、系统V流机制、I/O多路转换、存储映射 I/O 。  </p>
<a id="more"></a>
<h4 id="I-O多路转换"><a href="#I-O多路转换" class="headerlink" title="I/O多路转换"></a>I/O多路转换</h4><p><strong>应用场景：</strong> 在服务器编程模型中，客户请求到来时，服务器开启一个进程去服务，但是请求量很大时，服务器不可能一直开启的进程无法满足大量请求。这时，一个进程去服务多个客户，多个客户由于情况不同，不能在一个客户身上浪费太多的时间（阻塞），这时就引入了 I/O 多路复用的技术。<br><div class="note info"><p>其实，解决多用户请求可以用到的方法主要有：非阻塞IO，通过一种叫做 <em>轮询</em> 的方法进行遍历多个描述符，符合要求就去读，不符合下一个，这样在“路上”浪费一些时间，避免使用这种方法；还有一种 <em>异步IO</em> 的方法，核心思想是当一个描述符准备好后，用信号通知，这种方法有一定的系统限制；比较好的方法就是 <em>IO多路转换</em> 了，下面详细介绍。</p>
</div>  </p>
<h5 id="select和pselect函数"><a href="#select和pselect函数" class="headerlink" title="select和pselect函数"></a>select和pselect函数</h5><p>传向<code>select</code>的参数告诉内核：  </p>
<ul>
<li>关心的描述符；  </li>
<li>对于每个描述符关心的状态（读、写）；  </li>
<li>愿意等待的时间。<br>返回时，内核告诉我们：  </li>
<li>已准备好的描述符数量；  </li>
<li>对于读、写、异常的状态的每一个，哪些描述符已准备好。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds,</div><div class="line">			fd_set *<span class="keyword">restrict</span> writefds,</div><div class="line">			fd_set *<span class="keyword">restrict</span> exceptfds,</div><div class="line">			<span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</div><div class="line"><span class="comment">//返回值：准备就绪的描述符，超时返回0，失败返回-1</span></div><div class="line"><span class="keyword">struct</span> timeval &#123;</div><div class="line">	<span class="keyword">long</span> tv_sec; <span class="comment">//seconds</span></div><div class="line">	<span class="keyword">long</span> tv_usec; <span class="comment">//microseconds</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>关于返回值有三种情况：  </p>
<ul>
<li><code>tvpr==NULL</code> 永远等待，有描述符准备好或捕获到一个信号中断等待；  </li>
<li><code>tvpr-&gt;tv_sec==0 &amp;&amp; tvpr-&gt;tv_usec==0</code> 完全不等待；  </li>
<li>有一个不等于0，则是等待特定时间。<br>中间的三个参数指定描述符集的指针，可以通过以下API来设置。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//清空集合</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>; </div><div class="line"><span class="comment">//将一个给定的文件描述符加入集合之中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">//将一个给定的文件描述符从集合中删除   </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   </div><div class="line"><span class="comment">//检查集合中指定的文件描述符是否可以读写</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一个参数表示最大的描述符加1。为了限制在指定的范围内查找。<br><div class="note warning"><p><code>select</code> 有三个可能的返回值。<br>1.返回值 -1 表示出错。<br>2.返回值 0 表示没有描述符准备好，所有描述符集被清零。<br>3.正返回值，表示准备好的描述符数量，在描述符集中对应的位表示准备好的描述符。</p>
</div><br><code>pselect</code> 为 <code>select</code> 的变形，不同点在于，超时的结构，更精细的粒度来控制超时时间；可以设定信号屏蔽字。 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfd1, fd_set *readfds, </div><div class="line">			fd_set *writefds, fd_set exceptfds, </div><div class="line">			<span class="keyword">const</span> <span class="keyword">struct</span> timespec *tsptr, </div><div class="line">			<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>缺点：</strong>  </p>
<ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 </li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 </li>
<li>select支持的文件描述符数量太小了，默认是1024</li>
</ol>
<h5 id="pool函数"><a href="#pool函数" class="headerlink" title="pool函数"></a>pool函数</h5><p><code>pool</code>函数可用于任何类型的文件描述符，不是为每个状态构造一个描述符集，而是构造了一个 <code>poolfd</code> 结构数组，每个数组元素指定一个描述符编号以及对其关心的状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"><span class="keyword">struct</span> pollfd&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">short</span> events; <span class="comment">//常用的读POLLIN/写POLLOUT</span></div><div class="line">    <span class="keyword">short</span> revents; <span class="comment">//在fd上出现的event，可忽略设置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>poll</code> 第一个参数是一个fd数组集合, 每个fd关联一个pollfd结构, 该结构说明fd的关心状态是读还是写<br><code>poll</code> 第二个参数是第一个参数中fd的个数<br><code>poll</code> 第三个参数是等待时间, -1表示无限等待, 0表示不等待, 其它正值表示可等待的毫秒数<br><strong>流程：</strong>将结构数组中的元素<code>events</code>成员设置为标志（POOLIN POOLOUT等），通过设置这些来告诉内核我们对该描述符关心的是什么，返回时内核设置 <code>revents</code> 来对于该描述符上已经发生了什么事件。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> poolfd pfds[<span class="number">2</span>];<span class="comment">//定义poolfd结构数组</span></div><div class="line">pfds[<span class="number">0</span>].fd=STDIN_FILENO;<span class="comment">//关心的描述符</span></div><div class="line">pfds[<span class="number">0</span>].events=POOLIN;<span class="comment">//对于fd关心的events</span></div><div class="line">...</div><div class="line">pool(pfds, <span class="number">2</span>, <span class="number">-1</span>);<span class="comment">//设置pool，永远等待</span></div><div class="line"><span class="comment">//判断是否有满足的返回</span></div><div class="line"><span class="keyword">if</span>(pfds[<span class="number">0</span>].revents &amp; POOLIN) <span class="comment">//满足</span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h4><div class="note info"><p><em>存储映射I/O（Memory-mapped I/O）</em> 使一个磁盘文件和存储空间的一个缓冲区相映射，于是当从缓冲区中取数据，就相当于读文件中对应字节，向缓冲区写数据相当于自动写到文件中相应字节。可以在不使用 <code>read</code> 和 <code>write</code> 情况下执行IO。</p>
</div>  
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>首先，通知内核将一个文件映射到存储区中，调用 <code>mmap</code> 函数。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> filedes, <span class="keyword">off_t</span> off)</span></span>;</div><div class="line"><span class="comment">//返回值：若成功则返回映射区的起始地址，出错返回MAP_FAILED</span></div></pre></td></tr></table></figure></p>
<p> <em>addr</em> 参数用于指定映射存储区的起始地址，一般设置为0，表示由系统选择该映射区的起始地址，函数返回地址是映射区的起始地址。<br> <em>filedes</em> 指定要被映射文件的描述符，先要打开该文件。<br> <em>len</em> 表示映射的字节数。 <em>off</em> 映射文件在文件中的起始偏移量。<br> <em>prot</em> protect参数说明对映射存储区的保护要求。<br><code>PROT_READ, PROT_WRITE, PROT_EXEC, PROT_NONE</code> 可读可写可执行及不可访问。<br><img src="http://images.cnitblog.com/i/507263/201405/132119172653497.png" alt="">  </p>
<p>其他函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="comment">//更改一个现存映射存储区的权限</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</div><div class="line"><span class="comment">//将页冲洗到被映射的文件中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="comment">//解除映射</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">caddr_t</span> addr, <span class="keyword">size_t</span> len)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>应用：</strong> 参考<a href="http://blog.csdn.net/ctthuangcheng/article/details/9278107">ctthuangcheng 博客</a>的例子。  </p>
<ul>
<li>改变文件的内容，拷贝文件  </li>
<li>进程间共享文件  </li>
<li>父子进程通信  </li>
</ul>
<p>关于内存映射区的地址：<br>将文件或者其他东西映射到内存是以页面大小为单位进行分配的，往往被分配的映射区大小是页面大小的整数倍，如果不够一个页面则强制变为一个页面大小。文件大小到映射区大小之间的映射关系分为三种情况：</p>
<ul>
<li>文件大小等于映射区大小，此时映射区的大小分配</li>
<li>文件大小大于映射区大小</li>
<li>文件大小小于映射区大小</li>
</ul>
<p>如图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-27/49590422.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程，第14章 高级I/O 读书笔记。高级 I/O 包括：非阻塞 I/O，记录锁、系统V流机制、I/O多路转换、存储映射 I/O 。  &lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-线程</title>
    <link href="http://abumaster.com/2017/05/24/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/05/24/UNIX环境高级编程-线程/</id>
    <published>2017-05-24T02:52:22.000Z</published>
    <updated>2017-05-25T07:53:21.247Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第 11、12 章线程和线程控制。</p>
<a id="more"></a>
<div class="note primary"><p>单进程程序中需要处理多个任务时，通常用到多线程来分别处理各个任务，各个线程可以共享进程的资源。Linux中线程函数位于 <em>libpthread</em> 共享库中，因此在编译程序时要加上 <em>lpthread</em> 选项。 </p>
</div>  
<h4 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h4><p><strong>线程标识</strong> 如进程ID一样，线程也有一个为一个标识，只在进程环境中有效，用 _pthread_t_ 数据类型表示，不是一个整数，因此有专门的函数来比较两个线程的ID。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;<span class="comment">//相等返回非零</span></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);<span class="comment">//调用线程的线程ID</span></div></pre></td></tr></table></figure></p>
<p><strong>线程创建</strong> 可以直接调用 <code>pthread_create</code> 函数来创建一个新的线程，线程的执行顺序是不定的，无法保证哪个线程先运行，新的线程可以继承和调用线程的浮点环境和信号屏蔽字，多个线程可以共同访问进程的资源。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_create(pthread_t *restrict tidp,</div><div class="line">					const pthread_attr_t *restrict attr,</div><div class="line">					void *(*start_rtn)(void *),</div><div class="line">					void *restrict arg);</div></pre></td></tr></table></figure></p>
<p>成功返回0，失败返回错误编号。 <em>tidp</em> 表示新创建线程的ID， <em>attr</em> 定制各种不同的线程属性， _start_rtn_ 新创建线程的线程函数， <em>arg</em> 表示传入线程的参数，通常是结构体指针。<br><strong>线程终止</strong> 进程中的任一个线程如果调用了 <code>exit _Exit _exit</code> 函数，那么整个进程就会退出，如果单个线程退出而不影响整个进程，有下面三种方式：  </p>
<ul>
<li>线程从启动例程返回，返回值为线程的退出码；</li>
<li>线程可以被同一进程中的其他线程取消；</li>
<li>线程调用 <code>pthread_exit</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="comment">//终止自己，并设置一个无类型指针表示终止码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div><div class="line"><span class="comment">//访问上述的指针一直阻塞等待，获得线程的终止状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-24/47171841.jpg" alt=""><br>当 <code>pthread_join</code> 返回时，指向的内存必须是全局的或者是动态分配的，否则在栈上会出现覆盖的情况。创建的线程才算终止，才会释放占用的资源。  </p>
<p><strong>进程原语和线程原语的比较</strong>  </p>
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>fork</strong></td>
<td>pthread_create</td>
<td>创建新的控制流</td>
</tr>
<tr>
<td><strong>exit</strong></td>
<td>pthread_exit</td>
<td>从现有的控制流中退出</td>
</tr>
<tr>
<td><strong>waitpid</strong></td>
<td>pthread_join</td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td><strong>atexit</strong></td>
<td>pthread_cleanup_push</td>
<td>注册在退出时调用的函数</td>
</tr>
<tr>
<td><strong>getpid</strong></td>
<td>pthread_self</td>
<td>获取控制流的ID</td>
</tr>
<tr>
<td><strong>abort</strong></td>
<td>pthread_cancel</td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody>
</table>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>同一进程中的多个线程共享进程的资源，会产生竞争，为了保证数据的一致性，需要线程同步。<br><strong>1.互斥量</strong><br>通过使用pthread的互斥接口保护数据，确保同一时间只有一个线程访问数据， <em>互斥量（mutex）</em> 相当于一把锁，在访问共享资源前对其加上一把锁，使用过后，释放。其他线程在访问时，如果加锁会阻塞，直到获取这个互斥锁。<br>互斥变量通常用 <em>pthread_mutex_t</em> 的数据类型表示，使用前必须进行初始化，可以静态也可以动态，动态的话使用后要销毁。对应的 API 如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,</div><div class="line">						const pthread_mutexattr_t *restrict attr);</div><div class="line">int pthread_mutex_destory(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</div></pre></td></tr></table></figure></p>
<p><strong>2.避免死锁</strong><br>通过加锁的顺序可以避免死锁，使用多个互斥量。<br><strong>3.读写锁</strong><br>读写锁允许更高的并行性。读写锁有三种状态：读模式下加锁状态、写模式下加锁状态、不加锁状态。可以多读，单独写的策略，被称为 <em>共享-独占锁</em> 非常适合读的次数大于写的次数的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,  </div><div class="line">                                <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">/* 读模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 非阻塞的读模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 写模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 非阻塞的写模式下加锁 */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 解锁 */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>4.条件变量</strong><br>条件变量可以与互斥量一起使用，等待特定条件的发生。条件本身用互斥量保护，获得了互斥量才可以改变条件或者获得条件的状态。<br>数据类型为 <code>pthread_cond_t</code> 用之前用 <code>PTHREAD_COND_INITIALIZER</code> 静态初始化，或者调用函数动态初始化，结束使用后记得销毁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,<span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;     </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,pthread_mutex *mutex,</div><div class="line">							<span class="keyword">const</span> timespec *abstime)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>; <span class="comment">//唤醒单个等待线程</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">//唤醒所有等待线程</span></div></pre></td></tr></table></figure></p>
<p>使用 <code>pthread_cond_wait</code> 等待条件为真，互斥量用于保护条件，调用函数时，会进行两个原子操作：  </p>
<ul>
<li>把调用线程放到等待条件的线程列表上；  </li>
<li>对互斥量解锁。<br><code>pthread_cond_timewait</code> 多了一个超时时间，当等待的时间内未满足条件，则会返回一个超时的错误。<br>等待时间的结构  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> timespec&#123;  </div><div class="line"><span class="keyword">time_t</span>  tv_sec    <span class="comment">//Seconds.  </span></div><div class="line"><span class="keyword">long</span>    tv_nsec   <span class="comment">//Nanoseconds.  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>函数要求传入的时间值是一个绝对值，不是相对值，例如，想要等待3分钟，必须先获得当前时间，然后加上3分钟。
要想获得当前系统时间的timespec值，没有直接可调用的函数，需要通过调用gettimeofday函数获取timeval结构，然后转换成timespec结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> timeval now;</div><div class="line"><span class="keyword">struct</span> timespec until;</div><div class="line">gettimeofday(&amp;now);<span class="comment">//获得系统当前时间</span></div><div class="line"></div><div class="line"><span class="comment">//把时间从timeval结构转换成timespec结构</span></div><div class="line">until.tv_sec = now.tv_sec;</div><div class="line">until.tv_nsec = now.tv_usec * <span class="number">1000</span>;</div><div class="line"></div><div class="line"><span class="comment">//增加min</span></div><div class="line">until.tv_sec += <span class="number">3</span> * <span class="number">60</span>;</div></pre></td></tr></table></figure></p>
<h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><p>线程的一些属性设置等。  </p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p><strong>守护进程daemonize</strong>是生存周期较长的一种没有控制终端、后台运行的进程，伴随着系统的启动和关闭。<br><strong>编程规则：</strong>  </p>
<ul>
<li>首先要做的是调用umask将文件模式创建屏蔽字设置为0。由继承得来的文件模式创建屏蔽字可能会拒绝设置某些权限。例如，若守护进程要创建一个组可读、写的文件，而继承的文件模式创建屏蔽字可能屏蔽了这两种权限，于是所要求的组可读、写就不能起作用。  </li>
<li>调用fork，然后使父进程退出（exit）。这样做实现了下面几点：第一，如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕（也就没有了控制终端）；第二，子进程继承了父进程的进程组ID，但具有一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这对于下面就要做的setsid调用是必要的前提条件。  </li>
<li>调用setsid以创建一个新会话。使调用进程：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端。  </li>
<li>将当前工作目录更改为根目录。从父进程出继承过来的当前工作目录可能在一个挂载的文件系统（a mounted file system）中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载的文件系统中，那么该文件系统就不能被卸载。这与挂载文件系统的原意不符。  </li>
<li>关闭不再需要的文件描述符。  </li>
<li>某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出和标准出错的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以不能在终端设备上显示其输出，也无处从交互式用户那里接受输入。即使守护进程是从交互式会话启动的，但因为守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。</li>
</ul>
<p><a href="http://www.cnblogs.com/mickole/p/3188321.html">参考外链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第 11、12 章线程和线程控制。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
</feed>
