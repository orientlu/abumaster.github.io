<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2017-06-07T02:37:54.501Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UNIX环境高级编程-网络IPC</title>
    <link href="http://abumaster.com/2017/06/05/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9CIPC/"/>
    <id>http://abumaster.com/2017/06/05/UNIX环境高级编程-网络IPC/</id>
    <published>2017-06-05T02:34:09.000Z</published>
    <updated>2017-06-07T02:37:54.501Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程， 第16章 网络IPC：套接字 读书笔记。不同计算机进行通信的机制。</p>
<a id="more"></a>
<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p><strong>套接字</strong> 是通信端点的对象，也有套接字描述符，类似于文件描述符，许多操作也可以直接应用到套接字描述符上。创建一个套接字：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line"><span class="comment">//成功返回套接字描述符，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p>参数说明：<br><em>domain</em> 确定通信的特性，通常有 <code>AF_INET</code> 最常用，表示IPv4因特网域。<br><em>type</em> 套接字类型，tcp和udp的通信协议分别对应 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code> ，面向连接的字节流和面向无连接的报文。<br><em>protocol</em> 通常为零，默认协议。  </p>
<p>关闭套接字：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</div></pre></td></tr></table></figure></p>
<p><em>how</em> 的类别决定关闭的方式：  </p>
<ul>
<li>SHUT_RD 关闭读端，无法从套接字读取数据；  </li>
<li>SHUT_WR 关闭写端，无法向套接字写数据；  </li>
<li>SHUT_RDWR 同时关闭读写，无法向套接字读写数据。  </li>
</ul>
<p>有 <code>close</code> 为何还要用 <code>shutdown</code> 这是因为：<code>close</code> 的调用是在最后一个活动关闭时才释放，而 <code>shutdown</code> 可以使套接字处于非活动状态，不用关心引用的多少；同时，也可以关闭一端。  </p>
<h4 id="关于地址"><a href="#关于地址" class="headerlink" title="关于地址"></a>关于地址</h4><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>字节序是处理器的架构特性，指示像整数这样的大数据类型的内部字节顺序。分为<em>大端字节序（big-endian）</em>和<em>小端模式（little-endian）</em>。<br>TCP/IP协议使用的是大端字节序，异构计算机可以直接进行通信，不会混淆。字节序的转换可以在本地计算机上完成，常用到的函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);<span class="comment">//返回以网络字节序表示的32位整数</span></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);<span class="comment">//返回以网络字节序表示的16位整数</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netint32);<span class="comment">//返回以主机字节序表示的32位整数</span></div><div class="line"><span class="keyword">uint32_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);<span class="comment">//返回以主机字节序表示的16位整数</span></div></pre></td></tr></table></figure></p>
<p>大端：低地址放着高位数据，高地址放着低位数据。<br>小端：低地址放着低位数据，高地址放着高位数据。  </p>
<h5 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h5><p>地址标识了特定通信域的套接字端点，不同格式的地址传入套接字函数，可以用一个统一的结构来保存这个地址，被转换为 <code>sockaddr</code> 结构。因特网地址则定义在：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="keyword">struct</span> in_addr &#123;</div><div class="line">	<span class="keyword">in_addr_t</span> s_addr; <span class="comment">//IPv4地址</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> sockaddr_in &#123;</div><div class="line">	<span class="keyword">sa_family_t</span> sin_family;</div><div class="line">	<span class="keyword">in_port_t</span> sin_port;</div><div class="line">	<span class="keyword">struct</span> in_addr sin_addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>in_port_t</code> 为 <code>uint16_t</code> 类型的，而 <code>in_addr_t</code> 是 <code>uint32_t</code> 类型的。不同的系统下可以自由实现和添加额外的字段。<br>有时，地址的格式不易于人去查看，因此要转换为表达式格式（p），点分十进制。计算机理解的是数值格式（n）。BSD网络软件提供了函数 <code>inet_addr</code> 和 <code>inet_ntoa</code> 用于两者之间的转换。只用于IPv4。下面的函数则可以适用不同协议。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str,\</div><div class="line">						<span class="keyword">socklen_t</span> size)</span></span>;<span class="comment">//成功返回地址字符串指针</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</div><div class="line"><span class="comment">//成功返回1，无效返回0，失败返回-1</span></div></pre></td></tr></table></figure></p>
<h5 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h5><p><strong>1.获得给定计算机的主机信息</strong><br>通过调用 <code>gethostent</code> 函数，返回一个 <code>hostent</code> 结构的数据结构。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> hostent *<span class="title">gethostent</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//成功返回指针，失败返回NULL</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sethostent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>; <span class="comment">//打开主机数据文件，</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endhostent</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//关闭</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> hostent &#123;</div><div class="line">	<span class="keyword">char</span> *h_name; <span class="comment">//host name</span></div><div class="line">	<span class="keyword">char</span> **h_aliases; <span class="comment">//pointer of alternate host name array</span></div><div class="line">	<span class="keyword">int</span> h_addrtype; <span class="comment">//address type</span></div><div class="line">	<span class="keyword">int</span> h_length;</div><div class="line">	<span class="keyword">char</span> **h_addr_list; <span class="comment">//pointer to array of network addresses</span></div><div class="line">	.</div><div class="line">	.</div><div class="line">	.</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>返回地址为网络字节序。<br><strong>2.获取网络名字和网络号</strong>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnetbyaddr</span><span class="params">(<span class="keyword">unint32_t</span> net, <span class="keyword">int</span> type)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnetbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnet</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnetent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endnetent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> netent &#123;</div><div class="line">	<span class="keyword">char</span> *n_name;</div><div class="line">	<span class="keyword">char</span> **n_aliasses;</div><div class="line">	<span class="keyword">int</span> n_addrtype;</div><div class="line">	<span class="keyword">uint32_t</span> n_net;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样，网络号按照网络字节序返回，地址类型为一个地址族常量（AF_INET）。<br><strong>3.服务和端口号</strong><br>服务是由地址的端口号部分表示的。每个服务由一个唯一的、熟知的端口号表示。如ssh的端口号是22，http的端口号80等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="comment">//由服务名字来获得信息</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</div><div class="line"><span class="comment">//由端口号来获得信息</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</div><div class="line"><span class="comment">//顺序扫描服务数据库</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservenmt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setservent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endservent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> servent &#123;</div><div class="line">	<span class="keyword">char</span> *s_name;</div><div class="line">	<span class="keyword">char</span> **s_aliases;</div><div class="line">	<span class="keyword">int</span> s_port;</div><div class="line">	<span class="keyword">char</span> *s_proto;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>4.两个函数</strong><br>函数 <code>getaddrinfo</code> 允许将一个主机名和服务名映射到一个地址。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">const</span> <span class="keyword">char</span> *service, \</div><div class="line">				<span class="keyword">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result )</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> addrinfo &#123;</div><div class="line">    <span class="keyword">int</span> ai_flags;        <span class="comment">//AI_PASSIVE,AI_CANONNAME,AI_NUMERICHOST</span></div><div class="line">    <span class="keyword">int</span> ai_family;        <span class="comment">//AF_INET,AF_INET6</span></div><div class="line">    <span class="keyword">int</span> ai_socktype;    <span class="comment">//SOCK_STREAM,SOCK_DGRAM</span></div><div class="line">    <span class="keyword">int</span> ai_protocol;    <span class="comment">//IPPROTO_IP, IPPROTO_IPV4, IPPROTO_IPV6 etc.</span></div><div class="line">    <span class="keyword">size_t</span> ai_addrlen;            <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">char</span>* ai_canonname;            <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">struct</span> sockaddr* ai_addr;    <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">struct</span> addrinfo* ai_next;    <span class="comment">//must be zero or a null pointer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>hostname</em>:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)<br><em>service</em>：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等<br><em>hints</em>：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。<br><em>result</em>：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。<br><em>返回值</em>：0成功，非0出错  </p>
<p>函数 <code>getnameinfo</code> 将地址转换成主机名或服务名。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="keyword">socklen_t</span> salen, <span class="keyword">char</span> *host, \</div><div class="line">				<span class="keyword">size_t</span> hostlen, <span class="keyword">char</span> *serv, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</div></pre></td></tr></table></figure></p>
<p>例子：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//using getnameinfo()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HO 128</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sockaddr_in sa_in;</div><div class="line">	<span class="keyword">char</span> host[MAX_HO], service[MAX_HO];</div><div class="line">	<span class="keyword">int</span> flags;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</div><div class="line">		err_sys(<span class="string">"Usage: a.out &lt;IP&gt; &lt;port&gt;"</span>);</div><div class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">	<span class="comment">//init addr</span></div><div class="line">	sa_in.sin_family = AF_INET;</div><div class="line">	sa_in.sin_port = htons(port);</div><div class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;sa_in.sin_addr.s_addr);</div><div class="line">	flags = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	err = getnameinfo((<span class="keyword">struct</span> sockaddr *)(&amp;sa_in), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr),\</div><div class="line">			host, <span class="keyword">sizeof</span>(host), service, <span class="keyword">sizeof</span>(service), flags);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		gai_strerror(err);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"host := %s ; service := %s\n"</span>, host, service);</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="套接字与地址"><a href="#套接字与地址" class="headerlink" title="套接字与地址"></a>套接字与地址</h5><p>套接字中没有包含太多信息，只是一个描述符，并不知道通信的端口和I地址，而建立客户和服务器之间的连接时，往往需要这些信息，所以，在编程过程中要将socket函数产生的套接字与地址相关联。地址结构类似：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IPv4  </span></div><div class="line"><span class="keyword">struct</span> sockaddr_in  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_len;      <span class="comment">//IPv4地址长度  </span></div><div class="line">    <span class="keyword">short</span> <span class="keyword">int</span>      sin_family;   <span class="comment">//指代协议簇，在TCP套接字编程只能是AF_INET  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;     <span class="comment">//存储端口号（使用网络字节顺序），数据类型是一个16为的无符号整形类型  </span></div><div class="line">    <span class="keyword">struct</span>         in_addr sin_addr;<span class="comment">//存储IP地址，IP地址是一个in_add结构体（结构在下面）  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];     <span class="comment">//为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节  </span></div><div class="line">&#125;; </div><div class="line"><span class="keyword">struct</span> in_addr  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;   <span class="comment">//按照网络字节顺序存储IP地址  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这时需要一个函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第二个参数就是套接字地址结构对象了，它将与第一个参数套接字描述符进行绑定，这里的套接字地址结构参数的类型是通用套接字地址结构类型，因此，在实际调用的时候需要强制转换了。  </p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>在处理面向连接的网络服务时，开始交换数据前，必须在请求服务的套接字（客户端）和提供服务的套接字（服务器）之间建立连接。 <code>connect</code> 函数可以建立这样一个连接。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div><div class="line"><span class="comment">//成功返回0，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p><em>addr</em> 表示是想与之通信的服务器地址。  </p>
<p><strong>服务器</strong>调用 <code>listen</code> 来宣告可以接受连接请求。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>;</div><div class="line"><span class="comment">//成功返回文件描述符，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p><em>backlog</em> 指定了可以连接的数量，超过这一个值则拒绝连接。<br>服务器能够接受到请求，那么会再调用 <code>accept</code> 来获得连接请求并建立连接。<br>它返回的是调用 <code>connect</code> 函数的客户端的套接字描述符。如果不关心客户端的地址信息，则可以忽略后两个参数，将它们设为NULL。当 <code>accept</code> 没有连接请求时，服务器会阻塞直到下一个请求的到来，另外可以使用 <code>pool</code> 和 <code>select</code> 来等待一个请求的到来。<br>基本流程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * 套接字类型，地址，长度，可以连接数量</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> alen, </div><div class="line">		<span class="keyword">int</span> qlen)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</div><div class="line">	<span class="comment">//1.创建套接字</span></div><div class="line">	<span class="keyword">if</span>((fd = socket(addr-&gt;sa_family, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">	<span class="comment">//2.绑定套接字和地址</span></div><div class="line">	<span class="keyword">if</span>(bind(fd, addr, alen) &lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		err = errno;</div><div class="line">		<span class="keyword">goto</span> errout;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//3.准备连接</span></div><div class="line">	<span class="keyword">if</span>(type == SOCK_STREAM || type == SOCK_SEQPACKET)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(listen(fd, qlen) &lt; <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			err = errno;</div><div class="line">			<span class="keyword">goto</span> errout;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">errout:</div><div class="line">	close(fd);</div><div class="line">	errno = err;</div><div class="line">	<span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><strong>send和recv函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></div><div class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);  </div><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</div></pre></td></tr></table></figure></p>
<p>它们的前三个参数类似于<code>read</code> 和 <code>write</code>函数，最后一个参数一般为0。<br>send函数的参数  </p>
<ul>
<li>sockfd：指定发送端套接字描述符。</li>
<li>buff：存放要发送数据的缓冲区</li>
<li>nbytes: 实际要发送的数据的字节数</li>
<li>flags： 一般设置为0  </li>
</ul>
<p>recv函数的参数  </p>
<ul>
<li>sockfd: 接收端套接字描述符</li>
<li>buff：用来存放recv函数接收到的数据的缓冲区</li>
<li>nbytes: 指明buff的长度</li>
<li>flags: 一般设置为0</li>
</ul>
<p><strong>sendto和recvfrom函数</strong><br>这是面向无连接的数据传输，sockfd中不包含地址信息，所以需要指定地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</div><div class="line">    		<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="keyword">int</span> destlen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</div><div class="line">			<span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程， 第16章 网络IPC：套接字 读书笔记。不同计算机进行通信的机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-进程间通信</title>
    <link href="http://abumaster.com/2017/05/30/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://abumaster.com/2017/05/30/UNIX环境高级编程-进程间通信/</id>
    <published>2017-05-30T07:12:26.000Z</published>
    <updated>2017-06-04T13:00:38.863Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第14章 进程间通信IPC读书笔记。</p>
<a id="more"></a>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/36378614.jpg" alt="">  </p>
<div class="note primary"><p><strong>进程间通信</strong>( <em>inteprocess communication</em> ) 的目的是：
进行数据传输，不同进程协作处理一些数据；资源共享，多个进程间共享数据；通知事件，一个进程向其他进程通知一个事件发生；<br>进程间的通信主要分为：pipe，fifo，消息队列，信号量，共享存储，uds，套接字。</p>
</div>  
<h4 id="pipe和fifo"><a href="#pipe和fifo" class="headerlink" title="pipe和fifo"></a>pipe和fifo</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>pipe又称管道，提供了一个半双工的父子进程之间通信的机制。创建管道很简单：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>
<p>fd[0]可以用来读数据，fd[1]可以用来写数据。它们中间会有一个缓冲区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmd,<span class="keyword">const</span> <span class="keyword">char</span>* type)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE* fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>打开的是一个可执行的命令，<code>type</code>只能是 <code>r</code> 和 <code>w</code> 可能会返回执行命令的结果。实现上我们值得思考一下，就是 <code>popen</code> 通常来说肯定是创建了一个进程，然后FILE里面记录的 <code>fd</code> 必然和这个进程号做了一个绑定。不然我们在 <code>pclose</code> 使用 <code>FILE*</code>必须能够找到，我们应该 <code>wait</code> 什么进程终止。 在 <code>pclose</code> 必须 <code>fclose</code> 掉句柄，不然如果作为一输入命令的话那么会一直等待输入完成。  </p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/1955979.jpg" alt=""><br><strong>实例</strong><br>通过 <code>popen</code> 对输入进行变换的程序。向标准输出一个提示，从标准输入读取一行，使用 <code>popen</code> 可以在标准输入和输出之间添加一个程序来对输入进行变换处理，（当然也可以写成一个函数的形式来解决），基本流程如图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/54057635.jpg" alt=""><br>从标准输入读入字符，将其转换成小写的程序。<br><figure class="highlight c"><figcaption><span>myuclc.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>((c = getchar()) != EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">isupper</span>(c))</div><div class="line">			c=<span class="built_in">tolower</span>(c);</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">putchar</span>(c) == EOF)</div><div class="line">			err_sys(<span class="string">"output error"</span>);</div><div class="line">		<span class="keyword">if</span>(c==<span class="string">'\n'</span>)</div><div class="line">			fflush(<span class="built_in">stdout</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>编译为可执行文件myuclc，然后通过程序调用它。<br><figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">char</span> line[MAXLINE];</div><div class="line">	FILE *fpin;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>((fpin=popen(<span class="string">"./myuclc"</span>,<span class="string">"r"</span>)) == <span class="literal">NULL</span>)</div><div class="line">		err_sys(<span class="string">"popen error"</span>);</div><div class="line">	<span class="keyword">for</span>( ; ;)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">fputs</span>(<span class="string">"prompt&gt; "</span>, <span class="built_in">stdout</span>);</div><div class="line">		fflush(<span class="built_in">stdout</span>);</div><div class="line">		<span class="keyword">if</span>(fgets(line, MAXLINE, fpin) == <span class="literal">NULL</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">fputs</span>(line, <span class="built_in">stdout</span>) == EOF)</div><div class="line">			err_sys(<span class="string">"fputs error to pipe"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(pclose(fpin) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"pclose error"</span>);</div><div class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>  </p>
<p><strong>协同进程</strong><br>当一个程序产生某个过滤程序的输入，并且又读取该过滤程序的输出时，该过滤程序被称为 <em>协同进程coprocess</em> ，<code>popen</code> 只提供连接到另一进程的单向管道，所以需要两个单向管道。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/12251209.jpg" alt="">  </p>
<h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><blockquote>
<p>FIFO通常被称为命名管道，它是一种文件类型.stat结构中的st_mode指明其类型，可以用宏S_ISFIFO 进行测试。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="comment">//成功返回0，失败返回-1</span></div></pre></td></tr></table></figure>
<p>类似于管道，若用<code>write</code>写一个没有进程为读而打开的FIFO，则会产生SIG_PIPE信号，若FIFO最后一个写进程关闭了该FIFO，那么会为读进程产生一个文件结束标志。 
FIFO用途：  </p>
<ul>
<li>将数据从一条管道线传送到另一条，无需创建临时文件；  </li>
<li>用于客户进程-服务器进程的程序中，客户服务器之间传送数据。  </li>
</ul>
<p><strong>实例</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/10176095.jpg" alt=""><br>通常打开FIFO的方式有四种：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY);<span class="comment">//读，阻塞</span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY | O_NONBLOCK);<span class="comment">//非阻塞  </span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY);<span class="comment">//写，阻塞，一直等待</span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY | O_NONBLOCK);<span class="comment">//写，非阻塞</span></div><div class="line"><span class="comment">//阻塞情况下，没有对应端打开也会一直等待不返回</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/70265253.jpg" alt="">  </p>
<div class="note primary"><p><strong>XPS IPC</strong> 即消息队列、信号量、共享存储。</p>
</div>  
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。<br>流程： <code>msgget</code> 创建或打开一个现存的队列， <code>msgsnd</code> 将消息添加到队列尾端， <code>msgrcv</code> 用于从队列中取消息。 
使用 <code>key_t ftok(const char *path, int id);</code>来创建键值， <em>path</em> 必须存在，使用 <em>id</em> 的8位，组合。
消息队列相关的 API 有四个，必须包含的头文件。 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>1.打开或者创建一个队列</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。<br>如果没有消息队列与健值key相对应，并且msgflg中包含了IPC_CREAT标志位或key参数为IPC_PRIVATE时创建新的队列。<br>参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果。<br>调用返回：成功返回消息队列描述字，否则返回-1。  </p>
<p><strong>2.读取消息</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中。msqid为消息队列描述字；消息返回后存储在msgp指向的地址，msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），msgtyp为请求读取的消息类型；读消息标志msgflg可以为以下几个常值的或：  </p>
<ul>
<li>IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG</li>
<li>IPC_EXCEPT 与msgtyp&gt;0配合使用，返回队列中第一个类型不为msgtyp的消息</li>
<li>IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失。</li>
</ul>
<p>调用返回：成功返回读出消息的实际字节数，否则返回-1。  </p>
<p><strong>3.向队列发送一个消息</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定。对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：</p>
<ul>
<li>当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量；</li>
<li>当前消息队列的消息数（单位”个”）不小于消息队列的总容量（单位”字节数”），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节。</li>
</ul>
<p>调用返回：成功返回0，否则返回-1。  </p>
<p><strong>4.垃圾桶函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID。  </p>
<ul>
<li>IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；</li>
<li>IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员。</li>
<li>IPC_RMID：删除msqid标识的消息队列；</li>
</ul>
<p><strong>消息队列编程模型：</strong><br>接受消息端：申明消息类型——&gt; msgget建立消息队列 ——&gt;循环接收消息msgrcv——&gt;结束判断strcmp——&gt;msgctl(IPC_RMID)删除消息<br>发送消息端：申明消息类型——&gt;msgget建立消息队列——&gt;循环输入数据到消息中——&gt;msgsend向队列发送消息——结束判断strcmp——&gt;msgctl删除消息  </p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p><em>信号量（semaphore）</em> 是一个计数器，用于多进程对共享数据的访问。<br><strong>工作原理</strong>，为了获得共享资源，进程需要：  </p>
<ul>
<li>测试控制资源的信号量；  </li>
<li>若此信号量值为正，则可以使用信号量，并将信号量减1，表示使用了一个资源单位；  </li>
<li>若此信号量值为0，进程休眠，直到信号量大于0，进程唤醒，重复上述。  </li>
</ul>
<p><strong>1.semget函数</strong><br>获取或者创建信号量集。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> flag)</span></span>;</div><div class="line"><span class="comment">//成功返回信号量ID，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p>第一个参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget函数并提供一个键，再由系统生成一个相应的信号标识符（semget函数的返回值），只有semget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。<br>第二个参数nsems指定需要的信号量数目，创建新集合的时候非零指定值，引用现有的集合则可以为0。<br>第三个参数flag，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。  </p>
<p><strong>2.semop函数</strong><br>自动执行信号量集合上的操作数组，原子操作，改变信号量的值。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>;</div></pre></td></tr></table></figure></p>
<p>sem_id是由semget返回的信号量标识符，sembuf结构的定义如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sembuf&#123;  </div><div class="line">    <span class="keyword">short</span> sem_num;<span class="comment">//除非使用一组信号量，否则它为0  </span></div><div class="line">    <span class="keyword">short</span> sem_op;<span class="comment">//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，  </span></div><div class="line">                    <span class="comment">//一个是+1，即V（发送信号）操作。  </span></div><div class="line">    <span class="keyword">short</span> sem_flg;<span class="comment">//通常为SEM_UNDO,使操作系统跟踪信号，  </span></div><div class="line">                    <span class="comment">//并在进程没有释放该信号量而终止时，操作系统释放信号量  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>一个例子</strong><br>设置一个信号量，使多进程之间共享。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> semun</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> val;</div><div class="line">	<span class="keyword">struct</span> semid_ds *buf;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//创建信号量</span></div><div class="line">sem_id = semget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span>|IPC_CREAT);</div><div class="line"></div><div class="line"><span class="comment">//初始化信号量，使用前必须这样做</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">union</span> semun sem_union;</div><div class="line"></div><div class="line">	sem_union.val = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union)==<span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">union</span> semun sem_union;</div><div class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"del semvalue error"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//p操作</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sembuf sem_b;</div><div class="line">	sem_b.sem_num = <span class="number">0</span>;</div><div class="line">	sem_b.sem_op = <span class="number">-1</span>;</div><div class="line">	sem_b.sem_flg = SEM_UNDO;</div><div class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//v操作</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sembuf sem_b;</div><div class="line">	sem_b.sem_num = <span class="number">0</span>;</div><div class="line">	sem_b.sem_op = <span class="number">1</span>;</div><div class="line">	sem_b.sem_flg = SEM_UNDO;</div><div class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.semctl函数</strong><br>控制信号量信息。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd,...<span class="comment">/* union semun arg */</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>如果有第四个参数，它通常是一个union semum结构，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> semun&#123;  </div><div class="line">    <span class="keyword">int</span> val;  </div><div class="line">    <span class="keyword">struct</span> semid_ds *buf;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>共享存储允许两个或更多的进程共享以给定的存储区。无需进程间的复制，是一种最快的IPC。多个进程对同一存储区的同步访问。<br><strong>1.shmget函数</strong><br>获取一个共享存储标识符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</div><div class="line"><span class="comment">//成功返回共享存储ID，出错返回-1</span></div></pre></td></tr></table></figure></p>
<p>第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。<br>不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget函数的返回值），只有shmget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。<br>第二个参数，size以字节为单位指定需要共享的内存容量。<br>第三个参数，flag是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。<br><strong>2.shmat函数</strong><br>第一次创建完共享内存时，它还不能被任何进程访问，shmat函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数，是semget返回的存储空间标识；<br>第二个参数，为0，则连接到第一个可用的地址上，推荐使用；非0并且没有指定SHM_RND，则连接到<em>addr</em>指定的地址；<br>第三个参数，是一组标志位，通常为0。<br><strong>3.shmdt函数</strong><br>用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>addr 参数是调用 <code>shmat</code> 的返回值。<br><strong>4.shmctl函数</strong><br>对共享存储段进行多种操作。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数，shmid是shmget函数返回的共享内存标识符。<br>第二个参数，cmd是要采取的操作，它可以取下面的三个值 ：  </p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。  </li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值。  </li>
<li>IPC_RMID：删除共享内存段。<br>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。
shmid_ds结构至少包括以下成员：  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> shmid_ds  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">uid_t</span> shm_perm.uid;  </div><div class="line">    <span class="keyword">uid_t</span> shm_perm.gid;  </div><div class="line">    <span class="keyword">mode_t</span> shm_perm.mode;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>例子</strong><br>设计流程，注意多进程同时读写的问题。<br>创建共享存储，获得共享存储标识符；将共享存储连接到进程空间，获得首地址指针；设置存储空间格式；读写存储区。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第14章 进程间通信IPC读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-高级IO</title>
    <link href="http://abumaster.com/2017/05/26/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/"/>
    <id>http://abumaster.com/2017/05/26/UNIX环境高级编程-高级IO/</id>
    <published>2017-05-26T07:01:48.000Z</published>
    <updated>2017-05-27T08:27:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程，第14章 高级I/O 读书笔记。高级 I/O 包括：非阻塞 I/O，记录锁、系统V流机制、I/O多路转换、存储映射 I/O 。  </p>
<a id="more"></a>
<h4 id="I-O多路转换"><a href="#I-O多路转换" class="headerlink" title="I/O多路转换"></a>I/O多路转换</h4><p><strong>应用场景：</strong> 在服务器编程模型中，客户请求到来时，服务器开启一个进程去服务，但是请求量很大时，服务器不可能一直开启的进程无法满足大量请求。这时，一个进程去服务多个客户，多个客户由于情况不同，不能在一个客户身上浪费太多的时间（阻塞），这时就引入了 I/O 多路复用的技术。<br><div class="note info"><p>其实，解决多用户请求可以用到的方法主要有：非阻塞IO，通过一种叫做 <em>轮询</em> 的方法进行遍历多个描述符，符合要求就去读，不符合下一个，这样在“路上”浪费一些时间，避免使用这种方法；还有一种 <em>异步IO</em> 的方法，核心思想是当一个描述符准备好后，用信号通知，这种方法有一定的系统限制；比较好的方法就是 <em>IO多路转换</em> 了，下面详细介绍。</p>
</div>  </p>
<h5 id="select和pselect函数"><a href="#select和pselect函数" class="headerlink" title="select和pselect函数"></a>select和pselect函数</h5><p>传向<code>select</code>的参数告诉内核：  </p>
<ul>
<li>关心的描述符；  </li>
<li>对于每个描述符关心的状态（读、写）；  </li>
<li>愿意等待的时间。<br>返回时，内核告诉我们：  </li>
<li>已准备好的描述符数量；  </li>
<li>对于读、写、异常的状态的每一个，哪些描述符已准备好。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds,</div><div class="line">			fd_set *<span class="keyword">restrict</span> writefds,</div><div class="line">			fd_set *<span class="keyword">restrict</span> exceptfds,</div><div class="line">			<span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</div><div class="line"><span class="comment">//返回值：准备就绪的描述符，超时返回0，失败返回-1</span></div><div class="line"><span class="keyword">struct</span> timeval &#123;</div><div class="line">	<span class="keyword">long</span> tv_sec; <span class="comment">//seconds</span></div><div class="line">	<span class="keyword">long</span> tv_usec; <span class="comment">//microseconds</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>关于返回值有三种情况：  </p>
<ul>
<li><code>tvpr==NULL</code> 永远等待，有描述符准备好或捕获到一个信号中断等待；  </li>
<li><code>tvpr-&gt;tv_sec==0 &amp;&amp; tvpr-&gt;tv_usec==0</code> 完全不等待；  </li>
<li>有一个不等于0，则是等待特定时间。<br>中间的三个参数指定描述符集的指针，可以通过以下API来设置。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//清空集合</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>; </div><div class="line"><span class="comment">//将一个给定的文件描述符加入集合之中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">//将一个给定的文件描述符从集合中删除   </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   </div><div class="line"><span class="comment">//检查集合中指定的文件描述符是否可以读写</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一个参数表示最大的描述符加1。为了限制在指定的范围内查找。<br><div class="note warning"><p><code>select</code> 有三个可能的返回值。<br>1.返回值 -1 表示出错。<br>2.返回值 0 表示没有描述符准备好，所有描述符集被清零。<br>3.正返回值，表示准备好的描述符数量，在描述符集中对应的位表示准备好的描述符。</p>
</div><br><code>pselect</code> 为 <code>select</code> 的变形，不同点在于，超时的结构，更精细的粒度来控制超时时间；可以设定信号屏蔽字。 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfd1, fd_set *readfds, </div><div class="line">			fd_set *writefds, fd_set exceptfds, </div><div class="line">			<span class="keyword">const</span> <span class="keyword">struct</span> timespec *tsptr, </div><div class="line">			<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>缺点：</strong>  </p>
<ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 </li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 </li>
<li>select支持的文件描述符数量太小了，默认是1024</li>
</ol>
<h5 id="pool函数"><a href="#pool函数" class="headerlink" title="pool函数"></a>pool函数</h5><p><code>pool</code>函数可用于任何类型的文件描述符，不是为每个状态构造一个描述符集，而是构造了一个 <code>poolfd</code> 结构数组，每个数组元素指定一个描述符编号以及对其关心的状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"><span class="keyword">struct</span> pollfd&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">short</span> events; <span class="comment">//常用的读POLLIN/写POLLOUT</span></div><div class="line">    <span class="keyword">short</span> revents; <span class="comment">//在fd上出现的event，可忽略设置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>poll</code> 第一个参数是一个fd数组集合, 每个fd关联一个pollfd结构, 该结构说明fd的关心状态是读还是写<br><code>poll</code> 第二个参数是第一个参数中fd的个数<br><code>poll</code> 第三个参数是等待时间, -1表示无限等待, 0表示不等待, 其它正值表示可等待的毫秒数<br><strong>流程：</strong>将结构数组中的元素<code>events</code>成员设置为标志（POOLIN POOLOUT等），通过设置这些来告诉内核我们对该描述符关心的是什么，返回时内核设置 <code>revents</code> 来对于该描述符上已经发生了什么事件。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> poolfd pfds[<span class="number">2</span>];<span class="comment">//定义poolfd结构数组</span></div><div class="line">pfds[<span class="number">0</span>].fd=STDIN_FILENO;<span class="comment">//关心的描述符</span></div><div class="line">pfds[<span class="number">0</span>].events=POOLIN;<span class="comment">//对于fd关心的events</span></div><div class="line">...</div><div class="line">pool(pfds, <span class="number">2</span>, <span class="number">-1</span>);<span class="comment">//设置pool，永远等待</span></div><div class="line"><span class="comment">//判断是否有满足的返回</span></div><div class="line"><span class="keyword">if</span>(pfds[<span class="number">0</span>].revents &amp; POOLIN) <span class="comment">//满足</span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h4><div class="note info"><p><em>存储映射I/O（Memory-mapped I/O）</em> 使一个磁盘文件和存储空间的一个缓冲区相映射，于是当从缓冲区中取数据，就相当于读文件中对应字节，向缓冲区写数据相当于自动写到文件中相应字节。可以在不使用 <code>read</code> 和 <code>write</code> 情况下执行IO。</p>
</div>  
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>首先，通知内核将一个文件映射到存储区中，调用 <code>mmap</code> 函数。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> filedes, <span class="keyword">off_t</span> off)</span></span>;</div><div class="line"><span class="comment">//返回值：若成功则返回映射区的起始地址，出错返回MAP_FAILED</span></div></pre></td></tr></table></figure></p>
<p> <em>addr</em> 参数用于指定映射存储区的起始地址，一般设置为0，表示由系统选择该映射区的起始地址，函数返回地址是映射区的起始地址。<br> <em>filedes</em> 指定要被映射文件的描述符，先要打开该文件。<br> <em>len</em> 表示映射的字节数。 <em>off</em> 映射文件在文件中的起始偏移量。<br> <em>prot</em> protect参数说明对映射存储区的保护要求。<br><code>PROT_READ, PROT_WRITE, PROT_EXEC, PROT_NONE</code> 可读可写可执行及不可访问。<br><img src="http://images.cnitblog.com/i/507263/201405/132119172653497.png" alt="">  </p>
<p>其他函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="comment">//更改一个现存映射存储区的权限</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</div><div class="line"><span class="comment">//将页冲洗到被映射的文件中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="comment">//解除映射</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">caddr_t</span> addr, <span class="keyword">size_t</span> len)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>应用：</strong> 参考<a href="http://blog.csdn.net/ctthuangcheng/article/details/9278107">ctthuangcheng 博客</a>的例子。  </p>
<ul>
<li>改变文件的内容，拷贝文件  </li>
<li>进程间共享文件  </li>
<li>父子进程通信  </li>
</ul>
<p>关于内存映射区的地址：<br>将文件或者其他东西映射到内存是以页面大小为单位进行分配的，往往被分配的映射区大小是页面大小的整数倍，如果不够一个页面则强制变为一个页面大小。文件大小到映射区大小之间的映射关系分为三种情况：</p>
<ul>
<li>文件大小等于映射区大小，此时映射区的大小分配</li>
<li>文件大小大于映射区大小</li>
<li>文件大小小于映射区大小</li>
</ul>
<p>如图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-27/49590422.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程，第14章 高级I/O 读书笔记。高级 I/O 包括：非阻塞 I/O，记录锁、系统V流机制、I/O多路转换、存储映射 I/O 。  &lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-线程</title>
    <link href="http://abumaster.com/2017/05/24/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/05/24/UNIX环境高级编程-线程/</id>
    <published>2017-05-24T02:52:22.000Z</published>
    <updated>2017-05-25T07:53:21.247Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第 11、12 章线程和线程控制。</p>
<a id="more"></a>
<div class="note primary"><p>单进程程序中需要处理多个任务时，通常用到多线程来分别处理各个任务，各个线程可以共享进程的资源。Linux中线程函数位于 <em>libpthread</em> 共享库中，因此在编译程序时要加上 <em>lpthread</em> 选项。 </p>
</div>  
<h4 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h4><p><strong>线程标识</strong> 如进程ID一样，线程也有一个为一个标识，只在进程环境中有效，用 _pthread_t_ 数据类型表示，不是一个整数，因此有专门的函数来比较两个线程的ID。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;<span class="comment">//相等返回非零</span></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);<span class="comment">//调用线程的线程ID</span></div></pre></td></tr></table></figure></p>
<p><strong>线程创建</strong> 可以直接调用 <code>pthread_create</code> 函数来创建一个新的线程，线程的执行顺序是不定的，无法保证哪个线程先运行，新的线程可以继承和调用线程的浮点环境和信号屏蔽字，多个线程可以共同访问进程的资源。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_create(pthread_t *restrict tidp,</div><div class="line">					const pthread_attr_t *restrict attr,</div><div class="line">					void *(*start_rtn)(void *),</div><div class="line">					void *restrict arg);</div></pre></td></tr></table></figure></p>
<p>成功返回0，失败返回错误编号。 <em>tidp</em> 表示新创建线程的ID， <em>attr</em> 定制各种不同的线程属性， _start_rtn_ 新创建线程的线程函数， <em>arg</em> 表示传入线程的参数，通常是结构体指针。<br><strong>线程终止</strong> 进程中的任一个线程如果调用了 <code>exit _Exit _exit</code> 函数，那么整个进程就会退出，如果单个线程退出而不影响整个进程，有下面三种方式：  </p>
<ul>
<li>线程从启动例程返回，返回值为线程的退出码；</li>
<li>线程可以被同一进程中的其他线程取消；</li>
<li>线程调用 <code>pthread_exit</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="comment">//终止自己，并设置一个无类型指针表示终止码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div><div class="line"><span class="comment">//访问上述的指针一直阻塞等待，获得线程的终止状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-24/47171841.jpg" alt=""><br>当 <code>pthread_join</code> 返回时，指向的内存必须是全局的或者是动态分配的，否则在栈上会出现覆盖的情况。创建的线程才算终止，才会释放占用的资源。  </p>
<p><strong>进程原语和线程原语的比较</strong>  </p>
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>fork</strong></td>
<td>pthread_create</td>
<td>创建新的控制流</td>
</tr>
<tr>
<td><strong>exit</strong></td>
<td>pthread_exit</td>
<td>从现有的控制流中退出</td>
</tr>
<tr>
<td><strong>waitpid</strong></td>
<td>pthread_join</td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td><strong>atexit</strong></td>
<td>pthread_cleanup_push</td>
<td>注册在退出时调用的函数</td>
</tr>
<tr>
<td><strong>getpid</strong></td>
<td>pthread_self</td>
<td>获取控制流的ID</td>
</tr>
<tr>
<td><strong>abort</strong></td>
<td>pthread_cancel</td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody>
</table>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>同一进程中的多个线程共享进程的资源，会产生竞争，为了保证数据的一致性，需要线程同步。<br><strong>1.互斥量</strong><br>通过使用pthread的互斥接口保护数据，确保同一时间只有一个线程访问数据， <em>互斥量（mutex）</em> 相当于一把锁，在访问共享资源前对其加上一把锁，使用过后，释放。其他线程在访问时，如果加锁会阻塞，直到获取这个互斥锁。<br>互斥变量通常用 <em>pthread_mutex_t</em> 的数据类型表示，使用前必须进行初始化，可以静态也可以动态，动态的话使用后要销毁。对应的 API 如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,</div><div class="line">						const pthread_mutexattr_t *restrict attr);</div><div class="line">int pthread_mutex_destory(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</div></pre></td></tr></table></figure></p>
<p><strong>2.避免死锁</strong><br>通过加锁的顺序可以避免死锁，使用多个互斥量。<br><strong>3.读写锁</strong><br>读写锁允许更高的并行性。读写锁有三种状态：读模式下加锁状态、写模式下加锁状态、不加锁状态。可以多读，单独写的策略，被称为 <em>共享-独占锁</em> 非常适合读的次数大于写的次数的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,  </div><div class="line">                                <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">/* 读模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 非阻塞的读模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 写模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 非阻塞的写模式下加锁 */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 解锁 */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>4.条件变量</strong><br>条件变量可以与互斥量一起使用，等待特定条件的发生。条件本身用互斥量保护，获得了互斥量才可以改变条件或者获得条件的状态。<br>数据类型为 <code>pthread_cond_t</code> 用之前用 <code>PTHREAD_COND_INITIALIZER</code> 静态初始化，或者调用函数动态初始化，结束使用后记得销毁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,<span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;     </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,pthread_mutex *mutex,</div><div class="line">							<span class="keyword">const</span> timespec *abstime)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>; <span class="comment">//唤醒单个等待线程</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">//唤醒所有等待线程</span></div></pre></td></tr></table></figure></p>
<p>使用 <code>pthread_cond_wait</code> 等待条件为真，互斥量用于保护条件，调用函数时，会进行两个原子操作：  </p>
<ul>
<li>把调用线程放到等待条件的线程列表上；  </li>
<li>对互斥量解锁。<br><code>pthread_cond_timewait</code> 多了一个超时时间，当等待的时间内未满足条件，则会返回一个超时的错误。<br>等待时间的结构  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> timespec&#123;  </div><div class="line"><span class="keyword">time_t</span>  tv_sec    <span class="comment">//Seconds.  </span></div><div class="line"><span class="keyword">long</span>    tv_nsec   <span class="comment">//Nanoseconds.  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>函数要求传入的时间值是一个绝对值，不是相对值，例如，想要等待3分钟，必须先获得当前时间，然后加上3分钟。
要想获得当前系统时间的timespec值，没有直接可调用的函数，需要通过调用gettimeofday函数获取timeval结构，然后转换成timespec结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> timeval now;</div><div class="line"><span class="keyword">struct</span> timespec until;</div><div class="line">gettimeofday(&amp;now);<span class="comment">//获得系统当前时间</span></div><div class="line"></div><div class="line"><span class="comment">//把时间从timeval结构转换成timespec结构</span></div><div class="line">until.tv_sec = now.tv_sec;</div><div class="line">until.tv_nsec = now.tv_usec * <span class="number">1000</span>;</div><div class="line"></div><div class="line"><span class="comment">//增加min</span></div><div class="line">until.tv_sec += <span class="number">3</span> * <span class="number">60</span>;</div></pre></td></tr></table></figure></p>
<h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><p>线程的一些属性设置等。  </p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p><strong>守护进程daemonize</strong>是生存周期较长的一种没有控制终端、后台运行的进程，伴随着系统的启动和关闭。<br><strong>编程规则：</strong>  </p>
<ul>
<li>首先要做的是调用umask将文件模式创建屏蔽字设置为0。由继承得来的文件模式创建屏蔽字可能会拒绝设置某些权限。例如，若守护进程要创建一个组可读、写的文件，而继承的文件模式创建屏蔽字可能屏蔽了这两种权限，于是所要求的组可读、写就不能起作用。  </li>
<li>调用fork，然后使父进程退出（exit）。这样做实现了下面几点：第一，如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕（也就没有了控制终端）；第二，子进程继承了父进程的进程组ID，但具有一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这对于下面就要做的setsid调用是必要的前提条件。  </li>
<li>调用setsid以创建一个新会话。使调用进程：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端。  </li>
<li>将当前工作目录更改为根目录。从父进程出继承过来的当前工作目录可能在一个挂载的文件系统（a mounted file system）中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载的文件系统中，那么该文件系统就不能被卸载。这与挂载文件系统的原意不符。  </li>
<li>关闭不再需要的文件描述符。  </li>
<li>某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出和标准出错的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以不能在终端设备上显示其输出，也无处从交互式用户那里接受输入。即使守护进程是从交互式会话启动的，但因为守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。</li>
</ul>
<p><a href="http://www.cnblogs.com/mickole/p/3188321.html">参考外链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第 11、12 章线程和线程控制。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-信号</title>
    <link href="http://abumaster.com/2017/05/22/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/"/>
    <id>http://abumaster.com/2017/05/22/UNIX环境高级编程-信号/</id>
    <published>2017-05-22T02:01:10.000Z</published>
    <updated>2017-05-24T02:50:22.042Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程，第10章 信号，读书笔记。信号是一种软件中断，用于处理异步事件。</p>
<a id="more"></a>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>信号</strong>都有一个名字，以 <em>SIG</em> 开头，在头文件 <code>&lt;signal.h&gt;</code> 中定义为正整数，信号的编号。信号的产生条件：  </p>
<ul>
<li>终端输入中断按键，如 <code>Ctrl+C</code> 产生了 <code>SIGINT</code> 中断信号；  </li>
<li>硬件异常产生的信号，无效内存引用，除0，等，硬件检测到，通知内核；  </li>
<li>进程调用 <code>kill(2)</code> 函数可将信号发送给同一用户的另一个进程或进程组；  </li>
<li>用户调用 <code>kill(1)</code> 将信号发送给其他进程；  </li>
<li>软件中断。  </li>
</ul>
<p>对于信号的处理，有三种方式：忽略此信号、捕捉信号、执行默认动作。<br><strong>系统信号</strong>  </p>
<table>
<thead>
<tr>
<th>POSIX 信号</th>
<th>说明</th>
<th>默认动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>挂起</td>
<td>终止</td>
</tr>
<tr>
<td>SIGINT</td>
<td>终端中断符</td>
<td>终止</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>退出</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGTRAP</td>
<td>断点或陷阱指令</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGABRT/SIGIOT</td>
<td>abort发送的信号</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>非法内存访问</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>浮点异常</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>kill信号</td>
<td>终止(+)</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>用户信号1</td>
<td>终止</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>无效内存访问</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>用户信号2</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>管道错误</td>
<td>终止</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>alrm发送信号</td>
<td>终止</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>终止信号</td>
<td>终止</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>子进程退出</td>
<td>忽略</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>进程继续</td>
<td>忽略(*)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>进程停止</td>
<td>stop(*)(+)</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>终端停止</td>
<td>stop(*)</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>后台读控制tty</td>
<td>stop(*)</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>后台写tty</td>
<td>stop(*)</td>
</tr>
<tr>
<td>SIGURG</td>
<td>紧急情况</td>
<td>忽略</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>超过CPU限制</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>超过文件长度限制</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>虚拟时钟超时</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>梗概时间超时</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPOLL/SIGIO</td>
<td>轮询事件pool</td>
<td>终止</td>
</tr>
<tr>
<td>SIGSYS/SIGUNUSED</td>
<td>无效系统调用</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>协处理器栈故障</td>
<td>终止</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>终端窗口大小改变</td>
<td>忽略</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>电源失效或重启</td>
<td>终止</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>硬件故障</td>
<td>内核中断</td>
</tr>
</tbody>
</table>
<h4 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h4><p>Unix 系统的信号机制最简单的接口就是 <em>signal</em> 函数，当程序收到指定信号时，调用指定的函数。函数原型为
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span>(*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</div><div class="line"><span class="comment">//成功返回信号以前的配置，出错返回 SIG_ERR</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_ERR (void (*) ())-1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL (void (*)())0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN (void (*)())1</span></div></pre></td></tr></table></figure></p>
<p><strong>说明：</strong> <em>signal</em> 函数有两个参数，返回一个函数指针，这个函数指针有一个参数，并且返回空。 <em>signo</em> 表示上表的函数名称或者编号，第二个参数是一个函数指针，整型参数，返回空。<br>通过宏可以更清晰表示函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function">Sigfunc *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>, Sigfunc)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>简单示例：</strong><br>捕获信号 <code>SGIUSR1</code> 和 <code>SGIUSR2</code> 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//signal proc function</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR1, sig_usr) == SIG_ERR)</div><div class="line">		err_sys(<span class="string">"can't catch SIGUSR1"</span>);</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR2, sig_usr) == SIG_ERR)</div><div class="line">		err_sys(<span class="string">"can not catch SIGUSR2"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(;;)</div><div class="line">		pause();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signo == SIGUSR1)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR1\n"</span>);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGUSR2)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR2\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		err_dump(<span class="string">"received signal:%d\n"</span>, signo);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当在终端后台运行程序后，输入 <code>kill USR1 (进程ID)</code> 会捕获相应的信号，输出对应的信息。  </p>
<h4 id="sigaction-函数"><a href="#sigaction-函数" class="headerlink" title="sigaction 函数"></a>sigaction 函数</h4><div class="note info"><p><em>sigaction</em> 函数的功能是用来检查或者修改与指定信号相关联的处理动作，可以用来取代早期的 <em>signal</em> 函数。 </p>
</div>  
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function">ing <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> act, <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> oact)</span></span>;</div></pre></td></tr></table></figure>
<p>其中， <em>signo</em> 是要检查的信号编号， <em>act</em> 指针非空，则是要修改动作，如果 <em>oact</em> 非空则会经由该指针返回该信号的上一个动作。<br>使用数据结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sigaction</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (*sa_handler) (<span class="keyword">int</span>);<span class="comment">//信号捕获函数的地址</span></div><div class="line">    <span class="keyword">sigset_t</span> sa_mask;<span class="comment">//信号集，调用捕获函数之前，加到信号屏蔽字中</span></div><div class="line">    <span class="keyword">int</span> sa_flags;<span class="comment">//信号处理的选项</span></div><div class="line">    <span class="keyword">void</span> (*sa_restorer) (<span class="keyword">void</span>);<span class="comment">//没有使用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h4><p><strong>信号屏蔽字</strong>规定了当前阻塞而不能递送给该进程的信号集，调用 <em>sigprocmask</em> 函数可以检测和更改其信号屏蔽字，或同时执行两个动作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;</div></pre></td></tr></table></figure></p>
<p> <em>oset</em> 为非空指针，那么进程的当前信号屏蔽字通过 <em>oset</em> 返回。 <em>set</em> 为空，不改变进程的屏蔽字， <em>set</em> 非空，由 <em>how</em> 指定如何修改。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程，第10章 信号，读书笔记。信号是一种软件中断，用于处理异步事件。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>googletest使用</title>
    <link href="http://abumaster.com/2017/05/21/googletest%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2017/05/21/googletest使用/</id>
    <published>2017-05-21T03:02:25.000Z</published>
    <updated>2017-05-21T09:15:48.244Z</updated>
    
    <content type="html"><![CDATA[<p>googletest是Google的一个C++单元测试框架，<a href="https://github.com/google/googletest">Github地址</a>。其中包括了googletest和googlemock。使测试具有良好的独立性和重用性，并可以跨平台使用。<br><a id="more"></a></p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>从<a href="https://github.com/google/googletest">github</a>下载源码，本地解压。在 Windows 平台下用vs打开<code>msvc</code>目录中的<code>gtest.sln</code>，全部生成，根据平台的不同会在同目录下的debug和release中生成<code>gtestd.lib</code>和<code>gtest_maind.lib</code>，用时拷贝include和lib文件，并在工程项目中添加依赖。Linux平台下用cmake生成，在源文件目录下创建一个新文件目录如<code>build</code>，进入<code>build</code>打开终端输入<code>cmake ..</code>，生成<code>makefile</code>文件，输入<code>make</code>，生成<code>libgtest.a</code>文件，使用时将include文件包含入项目，动态链接<code>-lgtest</code>由于用到线程也需要链接<code>-lpthread</code>。更多详细信息可以在源码的<a href="https://github.com/google/googletest/blob/master/googletest/README.md">README.MD</a>。  </p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><blockquote>
<p>Google Test 中使用了类似宏的断言来定义测试内容。一般分为两个版本：<code>ASSERT_*</code>，错误抛出异常并终止运行；<code>EXPECT_*</code>生成不致命的错误，不会终止功能的运行。</p>
</blockquote>
<h4 id="基本断言"><a href="#基本断言" class="headerlink" title="基本断言"></a>基本断言</h4><p>用于判断true/false的断言。  </p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>致命断言</strong></th>
<th style="text-align:left"><strong>非致命</strong></th>
<th style="text-align:left"><strong>验证</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ASSERT_TRUE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><code>EXPECT_TRUE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><em>condition</em> is true</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_FALSE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><code>EXPECT_FALSE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><em>condition</em> is false</td>
</tr>
</tbody>
</table>
<h4 id="二元比较"><a href="#二元比较" class="headerlink" title="二元比较"></a>二元比较</h4><p>测试比较两个值。  </p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>致命断言</strong></th>
<th style="text-align:left"><strong>非致命断言</strong></th>
<th style="text-align:left"><strong>验证</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ASSERT_EQ(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_EQ(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>==</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>!=</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&lt;</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&lt;=</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&gt;</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&gt;=</code> <em>val2</em></td>
</tr>
</tbody>
</table>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>测试两个字符串string。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>致命断言</strong></th>
<th style="text-align:left"><strong>非致命断言</strong></th>
<th style="text-align:left"><strong>验证</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ASSERT_STREQ(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STREQ(</code><em>str1</em><code>,</code>_str_2<code>);</code></td>
<td style="text-align:left">两个c字符串有相同的内容</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_STRNE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STRNE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left">两个c字符串不同</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_STRCASEEQ(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STRCASEEQ(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left">两字符串相同，忽略案例</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_STRCASENE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STRCASENE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left">两字符串不同，忽略用例</td>
</tr>
</tbody>
</table>
<h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><h4 id="创建简单测试"><a href="#创建简单测试" class="headerlink" title="创建简单测试"></a>创建简单测试</h4><p>创建简单测试的过程：</p>
<ol>
<li>使用<code>TEST()</code>宏定义和命名一个测试函数，不需要返回值，像普通的c++函数一样；  </li>
<li>在其中可以使用任何合法的C++语句，并包含Googletest的测试宏，用来检查值；  </li>
<li>由其中定义的宏决定返回值，成功或者失败。  </li>
</ol>
<p>如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TEST(test_case_name, test_name) &#123;</div><div class="line"> <span class="comment">//具体测试宏和普通语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数为测试用例的名字，第二个参数为测试的名字，名字符合C++命名规范。  </p>
<p><strong>例子：</strong>  </p>
<blockquote>
<p>测试一个函数 <code>int Factorial(int n); // 返回n的阶乘</code></p>
</blockquote>
<p>则测试用例可以写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Tests factorial of 0.</span></div><div class="line">TEST(FactorialTest, HandlesZeroInput) &#123;</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tests factorial of positive numbers.</span></div><div class="line">TEST(FactorialTest, HandlesPositiveInput) &#123;</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">1</span>));</div><div class="line">  EXPECT_EQ(<span class="number">2</span>, Factorial(<span class="number">2</span>));</div><div class="line">  EXPECT_EQ(<span class="number">6</span>, Factorial(<span class="number">3</span>));</div><div class="line">  EXPECT_EQ(<span class="number">40320</span>, Factorial(<span class="number">8</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述一个测试用例，包含了两个不同输入的测试。  </p>
<h4 id="Test-Fixture-为不同测试配置相同的数据"><a href="#Test-Fixture-为不同测试配置相同的数据" class="headerlink" title="Test Fixture 为不同测试配置相同的数据"></a>Test Fixture 为不同测试配置相同的数据</h4><p>写了多组测试，需要用到相似的数据，这时就需要 <em>test fexture</em> ，可以在不同测试中使用相同的对象配置。创建一个 <em>fixture</em> 的过程如下：  </p>
<ol>
<li>先从 <code>::testing::Test</code> 类中继承一个类，成员函数定义为 <code>public:</code> 或者 <code>protected:</code>，可以使子类访问；  </li>
<li>在类中定义你想用到的对象；  </li>
<li>如果有必要可以写一个默认构造函数或者 <code>SetUp()</code> 函数，来准备测试所需的对象；  </li>
<li>如果有必要写一个析构函数或者 <code>TearDown()</code> 函数，来释放申请的资源信息，与上一步配对使用；  </li>
<li>为测试写子程序。  </li>
</ol>
<p>同样，<code>TEST_F()</code> 取代了上面的 <code>TEST()</code> 宏，允许访问 <em>test fixture</em> 中的子程序和对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TEST_F(test_case_name, test_name) &#123;</div><div class="line"> <span class="comment">//测试</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <em>第一个参数</em> 为测试用例的名称，必须为 <em>test fixture</em> 类的名称（_F 代表了 fixture）。如何使用。<br> <strong>例子：</strong><br>需要测试的一个类 <code>Queue</code> 定义如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="comment">// E is the element type.</span></div><div class="line"><span class="keyword">class</span> Queue &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Queue();</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(<span class="keyword">const</span> E&amp; element)</span></span>;</div><div class="line">  <span class="function">E* <span class="title">Dequeue</span><span class="params">()</span></span>; <span class="comment">// Returns NULL if the queue is empty.</span></div><div class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义 fixture 类，命名规范如果待测试的类为 <code>Foo</code> 则 fixture 类命名为 <code>FooTest</code> 。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> QueueTest : <span class="keyword">public</span> ::testing::Test &#123;</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</div><div class="line">    q1_.Enqueue(<span class="number">1</span>);</div><div class="line">    q2_.Enqueue(<span class="number">2</span>);</div><div class="line">    q2_.Enqueue(<span class="number">3</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// virtual void TearDown() &#123;&#125;</span></div><div class="line"></div><div class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</div><div class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</div><div class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用 <code>TES_F()</code> 和 <code>fixture class</code> 创建测试
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">TEST_F(QueueTest, IsEmptyInitially) &#123;</div><div class="line">  EXPECT_EQ(<span class="number">0</span>, q0_.size());</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_F(QueueTest, DequeueWorks) &#123;</div><div class="line">  <span class="keyword">int</span>* n = q0_.Dequeue();</div><div class="line">  EXPECT_EQ(<span class="literal">NULL</span>, n);</div><div class="line"></div><div class="line">  n = q1_.Dequeue();</div><div class="line">  ASSERT_TRUE(n != <span class="literal">NULL</span>);</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, *n);</div><div class="line">  EXPECT_EQ(<span class="number">0</span>, q1_.size());</div><div class="line">  <span class="keyword">delete</span> n;</div><div class="line"></div><div class="line">  n = q2_.Dequeue();</div><div class="line">  ASSERT_TRUE(n != <span class="literal">NULL</span>);</div><div class="line">  EXPECT_EQ(<span class="number">2</span>, *n);</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, q2_.size());</div><div class="line">  <span class="keyword">delete</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进行如上工作时，如何运作的呢？  </p>
<ol>
<li>构造一个 <code>QueueTest</code> 对象，如<code>t1</code>；  </li>
<li>调用 <code>t1.SetUp()</code> 来初始化 <code>t1</code> ；  </li>
<li>在 <code>t1</code> 上运行第一个测试 <code>IsEmptyInitially</code> ；</li>
<li>测试完成后，调用<code>t1.TearDown()</code> ；  </li>
<li>析构 <code>t1</code> ；  </li>
<li>重复上述测试。</li>
</ol>
<h3 id="调用测试"><a href="#调用测试" class="headerlink" title="调用测试"></a>调用测试</h3><p>初始化，运行所有测试，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line"></span>&#123;</div><div class="line">	testing::InitGoogleTest(&amp;argc, argv);</div><div class="line">	<span class="keyword">return</span> RUN_ALL_TESTS();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;googletest是Google的一个C++单元测试框架，&lt;a href=&quot;https://github.com/google/googletest&quot;&gt;Github地址&lt;/a&gt;。其中包括了googletest和googlemock。使测试具有良好的独立性和重用性，并可以跨平台使用。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="测试" scheme="http://abumaster.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-进程</title>
    <link href="http://abumaster.com/2017/05/19/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/05/19/UNIX环境高级编程-进程/</id>
    <published>2017-05-19T02:22:59.000Z</published>
    <updated>2017-05-20T10:10:09.644Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程，第7、8、9章有关进程的读书笔记。<br><a id="more"></a></p>
<h3 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h3><p>进程的启动和终止。一般c程序从入口函数<code>main</code>开始，调用一系列用户函数等；进程终止有正常终止和异常终止两种，其中，正常终止是程序从main函数返回(return)，或者正常调用退出函数<code>exit _exit _Exit</code>，或者线程的返回或退出，异常终止通常会调用<code>abort</code>或者信号中断。<br><strong>命令行参数和环境表</strong><br>它们都是有外界给程序的参数，就像标注的 ISO C 规定的主函数书写格式
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[]</span></span></div></pre></td></tr></table></figure></p>
<p>将命令行参数保存，而环境变量表则被取消了，仍可以通过函数访问环境表。 
查看和设置环境变量，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* envname)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;<span class="comment">//不会分配空间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;<span class="comment">//分配空间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>C 程序的存储空间分布</strong><br>如图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-19/39758826-file_1495161867318_14f4a.png" alt="">   </p>
<ul>
<li>正文段，存放程序运行所需的机器指令部分，具有只读属性；  </li>
<li>初始化数据段，明确初始化的变量；</li>
<li>未初始化的数据；  </li>
<li>栈，存放自动变量或者临时变量；  </li>
<li>堆，动态分配的空间。  </li>
</ul>
<p><strong>非局部goto</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;<span class="comment">//设置返回的位置</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;<span class="comment">//开始返回</span></div></pre></td></tr></table></figure></p>
<p>回滚一些变量的值，如果不想回滚到之前的值，可以将变量定义为：volatile，全局或静态变量的值也会保持不变。  </p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>进程标识符</strong><br>非负整型来表示唯一进程ID，但是可以重用，通常ID=0表示交换进程或者调度进程，ID=1表示init进程，ID=2表示页守护进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getpid();<span class="comment">//进程ID</span></div><div class="line"><span class="keyword">pid_t</span> getppid();<span class="comment">//父进程ID</span></div></pre></td></tr></table></figure></p>
<p><strong>fork函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure></p>
<p>两个返回，子进程返回0，通过getppid获得父进程id，ID为0，是交换进程使用，父进程返回子进程的ID，因为，这是父进程获得子进程ID的唯一方式。<br><strong>exec函数</strong><br>fork创建新进程，exec可以执行新程序，exit处理终止，wait等待终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *argv0, ..., <span class="comment">/*char *const envp[]*/</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv0, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</div></pre></td></tr></table></figure>
区别前四个函数取路径名，后两个取文件名作为参数。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-20/96247138-file_1495261874685_e1b6.png" alt="exec函数区别"><br><strong>system函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</div></pre></td></tr></table></figure></p>
<p>用于执行一个命令字符串，调用了<code>fork</code>函数，<code>exec</code>函数，<code>waitpid</code>函数。  </p>
<h3 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h3><p>终端登录和网络登录的进程关系图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-20/25743922-file_1495274895570_15325.png" alt="">
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-20/24107374-file_1495274948060_6d4e.png" alt="">  </p>
<p><strong>进程组</strong><br>进程组是一个或多个进程的集合，通常与一个作业关联。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);<span class="comment">//调用进程的进程组ID</span></div><div class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);<span class="comment">//pid的进程组ID</span></div><div class="line"><span class="comment">//getpgrp()等价于getpgid(0);</span></div></pre></td></tr></table></figure></p>
<p><strong>会话</strong><br>会话是一个或多个进程组的集合。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程，第7、8、9章有关进程的读书笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-标准IO库</title>
    <link href="http://abumaster.com/2017/05/18/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
    <id>http://abumaster.com/2017/05/18/UNIX环境高级编程-标准IO库/</id>
    <published>2017-05-18T00:39:42.000Z</published>
    <updated>2017-05-18T02:11:33.522Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第5章 标准I/O库。引入流的概念，并引入缓冲，减少read和write的调用次数。<br><a id="more"></a></p>
<p><strong>1.文件I/O和标准I/O区别</strong><br>标准I/O使用了缓冲机制，文件I/O不使用，而是直接调用内核中的一个系统调用完成。操作的对象不同，文件io操作的是文件描述符，标准io操作的是流，流与磁盘等外围设备关联。他们的函数对比。  </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>标准I/O</th>
<th>文件I/O</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开</td>
<td>fopen, froen, fdopen</td>
<td>open</td>
</tr>
<tr>
<td>关闭</td>
<td>fclose</td>
<td>close</td>
</tr>
<tr>
<td>读</td>
<td>getc, fgetc, getchar,<br>fgets, gets,<br>fread</td>
<td>read</td>
</tr>
<tr>
<td>写</td>
<td>putc, fputc, putchar,<br>fputs, puts,<br>fwrite</td>
<td>write</td>
</tr>
</tbody>
</table>
<p><strong>2.缓冲</strong>  </p>
<blockquote>
<p>标准I/O提供的几种缓冲及其区别。  </p>
</blockquote>
<ul>
<li>全缓冲，填满缓冲区后再进行实际的I/O操作，磁盘文件通常使用全缓冲。填满缓冲区后，调用fflush来刷新缓冲区，flush(冲洗)用来将缓冲区的内容写到磁盘上；flush(刷清)丢弃已经存储在缓冲区中的数据，用在终端驱动程序方面。  </li>
<li>行缓冲，用在终端的输入输出，遇到换行符的时候，或者缓冲区满。  </li>
<li>无缓冲，标准出错流，stderr，错误信息及时显示出来。  </li>
</ul>
<p>对于一个打开的流，设置更改缓冲区。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="comment">/* 	mode 参数：</div><div class="line">	_IOFBF 全缓冲；_IOLBF 行缓冲；_IONBF 不带缓冲</div><div class="line"> */</span></div><div class="line"><span class="comment">//强制冲洗流</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>3.操作</strong><br><strong>打开关闭流</strong><br>打开关闭标准I/O流，如上表的函数所示。<br><strong>读写流</strong><br>打开了流，有三种类型的方式进行读写操作：  </p>
<ul>
<li>每次一个字符的I/O;  </li>
<li>每次一行的I/O;  </li>
<li>直接I/O。  </li>
</ul>
<p>每个流在FILE对象上维持了两个标志：出错标志，文件结束标志。<br><code>gets</code> 和<code>fgets</code>，不推荐使用前者，因为不能指定缓冲区大小，容易造成缓冲区溢出，另外，<code>gets</code>不保留换行符。<br><strong>4.临时文件</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;<span class="comment">//指向唯一路径的指针</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回文件指针</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第5章 标准I/O库。引入流的概念，并引入缓冲，减少read和write的调用次数。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="c" scheme="http://abumaster.com/tags/c/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-文件和目录</title>
    <link href="http://abumaster.com/2017/05/16/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>http://abumaster.com/2017/05/16/UNIX环境高级编程-文件和目录/</id>
    <published>2017-05-16T11:39:00.000Z</published>
    <updated>2017-05-17T06:52:07.469Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX环境高级编程读书笔记，第4章 文件和目录。<br><a id="more"></a></p>
<blockquote>
<p>I/O操作描述的是普通文件的读写等操作，本章介绍文件系统的其他特征和文件的性质。  </p>
</blockquote>
<p><strong>1.三个stat函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>返回与此文件相关联的信息结构stat，关于stat的结构说明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stat &#123;</div><div class="line">	<span class="keyword">mode_t</span> st_mode;<span class="comment">//文件类型</span></div><div class="line">	<span class="keyword">ino_t</span> st_ino;<span class="comment">//i节点</span></div><div class="line">	<span class="keyword">dev_t</span> st_dev;<span class="comment">//设备号 文件系统</span></div><div class="line">	<span class="keyword">dev_t</span> st_rdev;</div><div class="line">	<span class="keyword">nlink_t</span> st_nlink;</div><div class="line">	<span class="keyword">uid_t</span> st_uid;</div><div class="line">	<span class="keyword">gid_t</span> st_gid;</div><div class="line">	<span class="keyword">off_t</span> st_size;<span class="comment">//大小</span></div><div class="line">	<span class="keyword">time_t</span> st_atime;<span class="comment">//访问时间</span></div><div class="line">	<span class="keyword">time_t</span> st_mtime;<span class="comment">//修改时间</span></div><div class="line">	<span class="keyword">time_t</span> st_ctime;<span class="comment">//改变时间</span></div><div class="line">	<span class="keyword">blksize_t</span> st_blksize;<span class="comment">//块大小</span></div><div class="line">	<span class="keyword">blkcnt_t</span> st_blocks;<span class="comment">//分配的磁盘块</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2.文件类型</strong>  </p>
<ul>
<li>普通文件；  </li>
<li>目录文件；  </li>
<li>块特殊文件；  </li>
<li>字符特殊文件；  </li>
<li>FIFO，进程间通信，命名管道；</li>
<li>套接字，网络间通信；  </li>
<li>符号链接<br>在<code>&lt;sys/stat.h&gt;</code>中定义了获取文件类型的宏，参数为<code>st_mode</code>成员。  </li>
</ul>
<table>
<thead>
<tr>
<th>宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_ISREG()</td>
<td>普通文件</td>
</tr>
<tr>
<td>S_ISDIR()</td>
<td>目录文件</td>
</tr>
<tr>
<td>S_ISCHR()</td>
<td>字符特殊文件</td>
</tr>
<tr>
<td>S_ISBLK()</td>
<td>块特殊文件</td>
</tr>
<tr>
<td>S_ISFIFO()</td>
<td>管道或FIFO</td>
</tr>
<tr>
<td>S_ISLNK()</td>
<td>符号链接</td>
</tr>
<tr>
<td>S_ISSOCK()</td>
<td>套接字</td>
</tr>
</tbody>
</table>
<p><strong>3.文件的访问权限</strong><br>分为三类：用户、组、其他，而每类对应的权限为：读、写、执行。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-16/90333911-file_1494936405039_f79a.png" alt=""><br><strong>4.文件系统</strong><br>i节点：固定长度的记录项，保存着文件的大部分信息。<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">理解inode</a>。内核中，以inode编号来标识文件，而不是以文件名标识文件。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX环境高级编程读书笔记，第4章 文件和目录。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-文件IO</title>
    <link href="http://abumaster.com/2017/05/15/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/"/>
    <id>http://abumaster.com/2017/05/15/UNIX环境高级编程-文件IO/</id>
    <published>2017-05-15T12:29:43.000Z</published>
    <updated>2017-05-16T12:46:55.147Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX环境高级编程读书笔记，第3章 文件 I/O。
<a id="more"></a></p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>Linux一切皆文件，无论是设备还是文档都是一个文件，这种抽象显示了Linux系统的灵活和通用性。文件描述符一般是一个非负整数，当打开或者创建一个文件时，内核向进程返回一个文件描述符，此描述符用于其他操作的参数。<br>通常在<code>unistd.h</code>中定义了常量：<code>STDIN_FILENO STDOUT_FILENO STDERR_FILENO</code>分别代表数字0,1,2是标准输入输出错误输出三种基本的文件描述符。<br><strong>open函数</strong><br>描述：打开或者创建文件，返回文件描述符或者-1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">oepn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags,...<span class="comment">/*mode_t mode*/</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>creat函数</strong><br>描述：创建一个文件，只能只写的方式打开，成功返回文件描述符，失败-1<br><strong>close函数</strong><br>描述：关闭文件描述符<br><strong>lseek函数</strong><br>描述：为一个打开的文件描述符设置偏移量，成功返回新的文件偏移量，失败-1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div></pre></td></tr></table></figure></p>
<p>偏移量的方式取决于第三个参数。<code>SEEK_SET</code> 开始处设置偏移量，绝对偏移量；<code>SEEK_CUR</code> 当前位置设置偏移量，相对偏移量；<code>SEEK_END</code> 结束开始设置偏移量，相对于文件末端偏移量。<br><strong>read函数</strong><br>打开的文件中读取数据，返回读取的字节数，如果剩余文件不够要读的字节数。<br><strong>write函数</strong><br>向打开的文件中写数据，返回实际写入的数据字节数。  </p>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>不同进程之间共享打开的文件，内核使用三种数据结构表示打开的文件。<br><strong>1.进程表项</strong><br>描述一个打开的文件描述表，每个文件描述符表包含了两项：  </p>
<ul>
<li>文件描述符标志   </li>
<li>指向文件表项的指针<br><strong>2.文件表</strong><br>每个文件表包含如下信息：  </li>
<li>文件状态标志（读写…)  </li>
<li>当前文件偏移量  </li>
<li>指向文件v节点表项的指针<br><strong>3.v节点表</strong><br>v节点表表示文件类型，以及对文件进行各种操作的指针，也包含了i节点及文件长度等信息。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-15/62478241-file_1494854203087_11715.png" alt=""><br>不同进程打开同一个文件的各项状态。  </li>
</ul>
<p><strong>dup和dup2函数</strong><br>用来复制一个现存的文件描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> filedes2)</span></span>;</div></pre></td></tr></table></figure></p>
<p>dup返回的文件描述符是当前可用文件描述符的最小值；dup2可以用filedes来指定新的描述符，如果filedes2已经打开，则先将其关闭，如果相等，则返回filedes2，不必关闭。<br>执行dup后，文件表项和v节点表项不变。<br>作用：一般用于重定向和共享文件，如父进程处理了一些文件，现在需要子进程处理，可以dup一份；同样dup2的使用，可以看为<code>dup2(源, 目标)</code>，目标将会被源替换掉。具体<a href="http://blog.csdn.net/zhouhong1026/article/details/8151235">使用</a>。<br><strong>fcntl函数</strong><br>可以读取和改变打开文件的性质。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> cmd, ...<span class="comment">/*int arg*/</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>fnctl的功能：  </p>
<p><1>    复制一个现有的描述符，cmd=F_DUPFD</1>  </p>
<p><2>    获取/设置文件描述符标记(cmd=F_GETFD / F_SETFD)</2>  </p>
<p><3>    获得和设置文件状态标志<code>cmd=F_GETFL F_SETFL</code></3>  </p>
<p><4>    获取和设置异步I/O所有权<code>cmd=F_GETOWN F_SETOWN</code></4>  </p>
<p><5>    获得和设置记录锁<code>cmd = F_GETLK F_SETLK</code></5><br>同样，复制文件描述符函数：<code>dup(filedes)</code>等价于<code>fcntl(filedes, F_DUPFD, 0)</code>。调用<code>dup2(filedes1,filedes2)</code>相当于调用：<code>close(filedes2); fcntl(filedes1, F_DUPFD, filedes2)</code>。不同之处在于dup2函数是原子操作，而用fcntl是两个函数调用。<br>dup2的功能:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dup2(fd, <span class="number">0</span>);</div><div class="line">dup2(fd, <span class="number">1</span>);</div><div class="line">dup2(fd, <span class="number">2</span>);</div><div class="line"><span class="keyword">if</span>(fd &gt; <span class="number">2</span>)</div><div class="line">	close(fd);</div></pre></td></tr></table></figure></p>
<p>假设fd=1，则执行后的结果图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-16/22619423-file_1494918444995_14a6d.png" alt=""><br>fd=3时，结果同，把3的文件复制到前3个上，删除以后的。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX环境高级编程读书笔记，第3章 文件 I/O。
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>High-performance Semantic Segmentation using VDFC</title>
    <link href="http://abumaster.com/2017/05/10/High-performance-Semantic-Segmentation-using-VDFC/"/>
    <id>http://abumaster.com/2017/05/10/High-performance-Semantic-Segmentation-using-VDFC/</id>
    <published>2017-05-10T07:37:56.000Z</published>
    <updated>2017-05-10T13:22:27.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>High-performance Semantic Segmentation Using Very Deep Fully Convolution [1] ，论文阅读笔记。</p>
</blockquote>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default">
</script>

<a id="more"></a>
<p>本文做的贡献：</p>
<ul>
<li>探索不同的<strong>全卷积残差网络</strong>找到更好的配置，诸如，网络的层数、特征图的分辨率、感受野的大小等，由于内存的限制等因素，提出了用低分辨率网络来模拟高分辨网络进行训练和测试；  </li>
<li>提出了<strong>在线引导（online booststrapping）</strong>的方法进行训练，已经论证可以达到更好的正确率；  </li>
<li>将传统的dropout应用到残差块中；  </li>
<li>达到了很好的结果。</li>
</ul>
<h4 id="1-低分辨率近似高分辨率的模型"><a href="#1-低分辨率近似高分辨率的模型" class="headerlink" title="1.低分辨率近似高分辨率的模型"></a>1.低分辨率近似高分辨率的模型</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-10/90074102-file_1494405779021_148f4.png" alt=""><br>由于内存的限制，网络不允许输入过大分辨率的图像，但是分辨率大的图像往往可以保存更多的细节信息，可以达到更好的分割效果，所以，提出了这个低分辨率来近似高分辨率的模型。基本的做法是：如果输入一个图像，经过了中间的若干层，图像的分辨率会下降，假设缩小为原始的1/8，（1）产生了一个1/8的特征图，这时，（2）可以在上一层池化层提取出剩下1/8的图像，（3）分别获得两个1/8的得分图，（4）组合，得到1/4的得分图或者是标签。</p>
<h4 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h4><p>$$ e = -\frac{1}{\sum_i^N \sum_j^K{1\{y_i=j\ and\ p_{ij}&lt;t\}}}(\sum_i^N\sum_j^K1\{y_i=j \ and\ p_{ij}&lt;t\}logp_{ij})$$   </p>
<p>[1] Wu Z, Shen C, Hengel A. High-performance semantic segmentation using very deep fully convolutional networks[J]. arXiv preprint arXiv:1604.04339, 2016.</p>
<p>K表示语义标签，N表示像素的个数，$p_{ij}$表示像素$a_i$分到标签$c_j$的概率，$y_i$表示$a_i$的正确标签。符号$1{.}$表示满足括号里的条件为1，不满足为0。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;High-performance Semantic Segmentation Using Very Deep Fully Convolution [1] ，论文阅读笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;
&lt;/script&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>宏定义</title>
    <link href="http://abumaster.com/2017/05/09/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://abumaster.com/2017/05/09/宏定义/</id>
    <published>2017-05-09T12:36:26.000Z</published>
    <updated>2017-05-09T13:35:49.257Z</updated>
    
    <content type="html"><![CDATA[<p>宏定义进入编译器之前展开替换。<br><a id="more"></a>
<strong>宏常量</strong><br><code>#define MAX 100</code>用100替换符号MAX，c++中一般不推荐使用，通常用常量const定义；<br><strong>用于条件编译的宏</strong><br>如避免包含重复头文件的宏：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifdefine XXX </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> XXX </span></div><div class="line"><span class="comment">//some include file</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">`</div></pre></td></tr></table></figure></p>
<p><strong>宏函数</strong><br>避免函数调用，提高执行效率，以空间换取时间。<br>对于一些重复的函数可以声明为宏函数，就像内联函数一样…<br>例子：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Onefunction)</span><span class="params">()</span></span>;<span class="comment">//定义函数指针</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, Onefunction&gt; OneMap;<span class="comment">//名称，函数指针相关联的map</span></div><div class="line">OneMap g_one_map;<span class="comment">//全局变量保存</span></div><div class="line"></div><div class="line"><span class="comment">//注册函数的宏，其中展开为一个按名定义的类，</span></div><div class="line"><span class="comment">//构造函数,将函数地址和函数名称放入全局的map中</span></div><div class="line"><span class="comment">//最后一个简单的类对象声明，可以保证构造函数的执行，</span></div><div class="line"><span class="comment">//作用域可以保证在执行完后对象的销毁，用过即销毁。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RegisterOneFunction(func) \</div><div class="line">&#123; \</div><div class="line">class __Register_##func &#123; \</div><div class="line">public: \</div><div class="line">__Register_##func() &#123; \</div><div class="line">g_one_map[#func] = &amp;func; \</div><div class="line">&#125; \</div><div class="line">&#125;; \</div><div class="line">__Register_##func g_register_##func; \</div><div class="line">&#125;</span></div><div class="line"><span class="comment">//自定义的函数，无参，返回int</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func1 out...\n"</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func2 out...222\n"</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用宏，注册函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">WrapperRegisterFunction</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	RegisterOneFunction(func1);</div><div class="line">	RegisterOneFunction(func2);</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据函数名称获得函数的指针</span></div><div class="line"><span class="function">Onefunction <span class="title">GetOneFunction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; fname)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">if</span>(g_one_map.count(fname))</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> g_one_map[fname];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">for</span>(OneMap::iterator it=g_one_map.begin();</div><div class="line">			it!=g_one_map.end(); it++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span> &lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="built_in">string</span> funNmae;</div><div class="line"></div><div class="line">	WrapperRegisterFunction();</div><div class="line"></div><div class="line">	<span class="built_in">cin</span> &gt;&gt; funNmae;</div><div class="line">	<span class="comment">//以名称来使用函数</span></div><div class="line">	GetOneFunction(funNmae)();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>  </p>
<p>1.普通宏定义  </p>
<ul>
<li>宏名一般用大写  </li>
<li>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改  </li>
<li>预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查  </li>
<li>宏定义末尾不加分号  </li>
<li>宏定义写在函数的花括号外边，作用域为其后的程序，通常在文件的最开头  </li>
<li>可以用#undef命令终止宏定义的作用域  </li>
<li>宏定义可以嵌套   </li>
<li>字符串””中永远不包含宏  </li>
<li>宏定义不分配内存，变量定义分配内存<br>2.带参宏定义  </li>
<li>实参如果是表达式容易出问题  </li>
<li>宏名和参数的括号间不能有空格  </li>
<li>宏替换只作替换，不做计算，不做表达式求解  </li>
<li>函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存  </li>
<li>宏的哑实结合不存在类型，也没有类型转换  </li>
<li>函数只有一个返回值，利用宏则可以设法得到多个值  </li>
<li>宏展开使源程序变长，函数调用不会  </li>
<li>宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;宏定义进入编译器之前展开替换。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>caffe学习-分类</title>
    <link href="http://abumaster.com/2017/05/07/caffe%E5%AD%A6%E4%B9%A0-%E5%88%86%E7%B1%BB/"/>
    <id>http://abumaster.com/2017/05/07/caffe学习-分类/</id>
    <published>2017-05-07T11:29:00.000Z</published>
    <updated>2017-05-08T12:39:47.386Z</updated>
    
    <content type="html"><![CDATA[<p>在用caffe的c++接口时，遇到了许多问题，学习源码中解决问题，熟悉一些细节。<br><a id="more"></a>
<strong>1.预测分类的流程图</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-8/16381803-file_1494210884331_288e.png" alt="预测流程图">  </p>
<p><strong>2.代码注释</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div></pre></td><td class="code"><pre><div class="line">//classification.cpp</div><div class="line">/*一些头文件*/</div><div class="line">#ifdef USE_OPENCV</div><div class="line">/* Pair (label, confidence) </div><div class="line"> * 代表一个预测结果，标签和概率的组合</div><div class="line"> */</div><div class="line">typedef std::pair&lt;string, float&gt; Prediction;</div><div class="line">//定义一个分类的类</div><div class="line">class Classifier &#123;</div><div class="line"> public:</div><div class="line">  Classifier(const string&amp; model_file,</div><div class="line">             const string&amp; trained_file,</div><div class="line">             const string&amp; mean_file,</div><div class="line">             const string&amp; label_file);</div><div class="line">//提供给外部的接口，返回一个预测。参数：需要预测的图像和概率最大的N个结果</div><div class="line">  std::vector&lt;Prediction&gt; Classify(const cv::Mat&amp; img, int N = 5);</div><div class="line"></div><div class="line"> private:</div><div class="line">  void SetMean(const string&amp; mean_file);//设置中值</div><div class="line">  std::vector&lt;float&gt; Predict(const cv::Mat&amp; img);</div><div class="line">  void WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels);</div><div class="line">  void Preprocess(const cv::Mat&amp; img,</div><div class="line">                  std::vector&lt;cv::Mat&gt;* input_channels);</div><div class="line"></div><div class="line"> private:</div><div class="line">  shared_ptr&lt;Net&lt;float&gt; &gt; net_;</div><div class="line">  cv::Size input_geometry_;</div><div class="line">  int num_channels_;</div><div class="line">  cv::Mat mean_;</div><div class="line">  std::vector&lt;string&gt; labels_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Classifier::Classifier(const string&amp; model_file,</div><div class="line">                       const string&amp; trained_file,</div><div class="line">                       const string&amp; mean_file,</div><div class="line">                       const string&amp; label_file) &#123;</div><div class="line">#ifdef CPU_ONLY</div><div class="line">  Caffe::set_mode(Caffe::CPU);</div><div class="line">#else</div><div class="line">  Caffe::set_mode(Caffe::GPU);</div><div class="line">#endif</div><div class="line">  //加载网络配置并初始化</div><div class="line">  net_.reset(new Net&lt;float&gt;(model_file, TEST));</div><div class="line">  net_-&gt;CopyTrainedLayersFrom(trained_file);</div><div class="line">  CHECK_EQ(net_-&gt;num_inputs(), 1) &lt;&lt; "Network should have exactly one input.";</div><div class="line">  CHECK_EQ(net_-&gt;num_outputs(), 1) &lt;&lt; "Network should have exactly one output.";</div><div class="line">  //取出输入层的blob结构，可以提取出通道和输入图像的高宽</div><div class="line">  Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];</div><div class="line">  num_channels_ = input_layer-&gt;channels();</div><div class="line">  CHECK(num_channels_ == 3 || num_channels_ == 1)</div><div class="line">    &lt;&lt; "Input layer should have 1 or 3 channels.";</div><div class="line">  input_geometry_ = cv::Size(input_layer-&gt;width(), input_layer-&gt;height());</div><div class="line"></div><div class="line">  //加载中值文件</div><div class="line">  SetMean(mean_file);</div><div class="line"></div><div class="line">  //加载标签文件</div><div class="line">  std::ifstream labels(label_file.c_str());</div><div class="line">  CHECK(labels) &lt;&lt; "Unable to open labels file " &lt;&lt; label_file;</div><div class="line">  string line;</div><div class="line">  while (std::getline(labels, line))</div><div class="line">    labels_.push_back(string(line));</div><div class="line">  //检查标签数目和输出维度是否匹配</div><div class="line">  Blob&lt;float&gt;* output_layer = net_-&gt;output_blobs()[0];</div><div class="line">  CHECK_EQ(labels_.size(), output_layer-&gt;channels())</div><div class="line">    &lt;&lt; "Number of labels is different from the output layer dimension.";</div><div class="line">&#125;</div><div class="line">//自定义比较函数，用于排序预测结果</div><div class="line">static bool PairCompare(const std::pair&lt;float, int&gt;&amp; lhs,</div><div class="line">                        const std::pair&lt;float, int&gt;&amp; rhs) &#123;</div><div class="line">  return lhs.first &gt; rhs.first;</div><div class="line">&#125;</div><div class="line">//返回v中元素最大的N个数的下标索引</div><div class="line">static std::vector&lt;int&gt; Argmax(const std::vector&lt;float&gt;&amp; v, int N) &#123;</div><div class="line">  std::vector&lt;std::pair&lt;float, int&gt; &gt; pairs;</div><div class="line">  for (size_t i = 0; i &lt; v.size(); ++i)</div><div class="line">    pairs.push_back(std::make_pair(v[i], static_cast&lt;int&gt;(i)));</div><div class="line">  std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; result;</div><div class="line">  for (int i = 0; i &lt; N; ++i)</div><div class="line">    result.push_back(pairs[i].second);</div><div class="line">  return result;</div><div class="line">&#125;</div><div class="line">//输入图像，返回前N个概率最大的预测(标签，概率)</div><div class="line">std::vector&lt;Prediction&gt; Classifier::Classify(const cv::Mat&amp; img, int N) &#123;</div><div class="line">  std::vector&lt;float&gt; output = Predict(img);</div><div class="line"></div><div class="line">  N = std::min&lt;int&gt;(labels_.size(), N);</div><div class="line">  std::vector&lt;int&gt; maxN = Argmax(output, N);</div><div class="line">  std::vector&lt;Prediction&gt; predictions;</div><div class="line">  for (int i = 0; i &lt; N; ++i) &#123;</div><div class="line">    int idx = maxN[i];</div><div class="line">    predictions.push_back(std::make_pair(labels_[idx], output[idx]));</div><div class="line">  &#125;</div><div class="line">  return predictions;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Load the mean file in binaryproto format. */</div><div class="line">void Classifier::SetMean(const string&amp; mean_file) &#123;</div><div class="line">  BlobProto blob_proto;</div><div class="line">  ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &amp;blob_proto);</div><div class="line"></div><div class="line">  /* Convert from BlobProto to Blob&lt;float&gt; */</div><div class="line">  Blob&lt;float&gt; mean_blob;</div><div class="line">  mean_blob.FromProto(blob_proto);</div><div class="line">  CHECK_EQ(mean_blob.channels(), num_channels_)</div><div class="line">    &lt;&lt; "Number of channels of mean file doesn't match input layer.";</div><div class="line"></div><div class="line">  /* The format of the mean file is planar 32-bit float BGR or grayscale. */</div><div class="line">  std::vector&lt;cv::Mat&gt; channels;</div><div class="line">  float* data = mean_blob.mutable_cpu_data();</div><div class="line">  for (int i = 0; i &lt; num_channels_; ++i) &#123;</div><div class="line">    /* Extract an individual channel. */</div><div class="line">    cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);</div><div class="line">    channels.push_back(channel);</div><div class="line">    data += mean_blob.height() * mean_blob.width();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /* Merge the separate channels into a single image. */</div><div class="line">  cv::Mat mean;</div><div class="line">  cv::merge(channels, mean);</div><div class="line"></div><div class="line">  /* Compute the global mean pixel value and create a mean image</div><div class="line">   * filled with this value. */</div><div class="line">  cv::Scalar channel_mean = cv::mean(mean);</div><div class="line">  mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);</div><div class="line">&#125;</div><div class="line">//预测函数，返回输出的概率</div><div class="line">std::vector&lt;float&gt; Classifier::Predict(const cv::Mat&amp; img) &#123;</div><div class="line">  Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];</div><div class="line">  input_layer-&gt;Reshape(1, num_channels_,</div><div class="line">                       input_geometry_.height, input_geometry_.width);</div><div class="line">  /* Forward dimension change to all layers. */</div><div class="line">  net_-&gt;Reshape();</div><div class="line"></div><div class="line">  std::vector&lt;cv::Mat&gt; input_channels;</div><div class="line">  WrapInputLayer(&amp;input_channels);</div><div class="line"></div><div class="line">  Preprocess(img, &amp;input_channels);</div><div class="line"></div><div class="line">  net_-&gt;Forward();</div><div class="line"></div><div class="line">  /* Copy the output layer to a std::vector */</div><div class="line">  Blob&lt;float&gt;* output_layer = net_-&gt;output_blobs()[0];</div><div class="line">  const float* begin = output_layer-&gt;cpu_data();</div><div class="line">  const float* end = begin + output_layer-&gt;channels();</div><div class="line">  return std::vector&lt;float&gt;(begin, end);</div><div class="line">&#125;</div><div class="line"> /* 包装网络的输入层，将每个通道保存为Mat对象，</div><div class="line">  * 最后直接将分割的通道写入到输入层中 */</div><div class="line">void Classifier::WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels) &#123;</div><div class="line">  Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];</div><div class="line"></div><div class="line">  int width = input_layer-&gt;width();</div><div class="line">  int height = input_layer-&gt;height();</div><div class="line">  //获取可更改的输入层数据指针</div><div class="line">  float* input_data = input_layer-&gt;mutable_cpu_data();</div><div class="line">  for (int i = 0; i &lt; input_layer-&gt;channels(); ++i) &#123;</div><div class="line">    cv::Mat channel(height, width, CV_32FC1, input_data);</div><div class="line">    input_channels-&gt;push_back(channel);</div><div class="line">    input_data += width * height;</div><div class="line">  &#125;//将各个通道变为Mat，依次放入vector中</div><div class="line">&#125;</div><div class="line">//图像拷贝入输入层中</div><div class="line">void Classifier::Preprocess(const cv::Mat&amp; img,</div><div class="line">                            std::vector&lt;cv::Mat&gt;* input_channels) &#123;</div><div class="line">  /* 将输入图像转换为网络要求的输入格式 */</div><div class="line">  //通道数</div><div class="line">  cv::Mat sample;</div><div class="line">  if (img.channels() == 3 &amp;&amp; num_channels_ == 1)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);</div><div class="line">  else if (img.channels() == 4 &amp;&amp; num_channels_ == 1)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);</div><div class="line">  else if (img.channels() == 4 &amp;&amp; num_channels_ == 3)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);</div><div class="line">  else if (img.channels() == 1 &amp;&amp; num_channels_ == 3)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);</div><div class="line">  else</div><div class="line">    sample = img;</div><div class="line">  //大小</div><div class="line">  cv::Mat sample_resized;</div><div class="line">  if (sample.size() != input_geometry_)</div><div class="line">    cv::resize(sample, sample_resized, input_geometry_);</div><div class="line">  else</div><div class="line">    sample_resized = sample;</div><div class="line">  //浮点数</div><div class="line">  cv::Mat sample_float;</div><div class="line">  if (num_channels_ == 3)</div><div class="line">    sample_resized.convertTo(sample_float, CV_32FC3);</div><div class="line">  else</div><div class="line">    sample_resized.convertTo(sample_float, CV_32FC1);</div><div class="line">  //归一化处理：减去中值</div><div class="line">  cv::Mat sample_normalized;</div><div class="line">  cv::subtract(sample_float, mean_, sample_normalized);</div><div class="line">  //直接将mat拷贝到输入层，已经处理过输入层为Mat对象了</div><div class="line">  cv::split(sample_normalized, *input_channels);</div><div class="line">  CHECK(reinterpret_cast&lt;float*&gt;(input_channels-&gt;at(0).data)</div><div class="line">        == net_-&gt;input_blobs()[0]-&gt;cpu_data())</div><div class="line">    &lt;&lt; "Input channels are not wrapping the input layer of the network.";</div><div class="line">&#125;</div><div class="line">//主函数命令行调用</div><div class="line">int main(int argc, char** argv) &#123;</div><div class="line">  if (argc != 6) &#123;</div><div class="line">    std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0]</div><div class="line">              &lt;&lt; " deploy.prototxt network.caffemodel"</div><div class="line">              &lt;&lt; " mean.binaryproto labels.txt img.jpg" &lt;&lt; std::endl;</div><div class="line">    return 1;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ::google::InitGoogleLogging(argv[0]);</div><div class="line"></div><div class="line">  string model_file   = argv[1];</div><div class="line">  string trained_file = argv[2];</div><div class="line">  string mean_file    = argv[3];</div><div class="line">  string label_file   = argv[4];</div><div class="line">  Classifier classifier(model_file, trained_file, mean_file, label_file);</div><div class="line"></div><div class="line">  string file = argv[5];</div><div class="line"></div><div class="line">  std::cout &lt;&lt; "---------- Prediction for "</div><div class="line">            &lt;&lt; file &lt;&lt; " ----------" &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  cv::Mat img = cv::imread(file, -1);</div><div class="line">  CHECK(!img.empty()) &lt;&lt; "Unable to decode image " &lt;&lt; file;</div><div class="line">  std::vector&lt;Prediction&gt; predictions = classifier.Classify(img);</div><div class="line"></div><div class="line">  /* Print the top N predictions. */</div><div class="line">  for (size_t i = 0; i &lt; predictions.size(); ++i) &#123;</div><div class="line">    Prediction p = predictions[i];</div><div class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; p.second &lt;&lt; " - \""</div><div class="line">              &lt;&lt; p.first &lt;&lt; "\"" &lt;&lt; std::endl;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">#else</div><div class="line">int main(int argc, char** argv) &#123;</div><div class="line">  LOG(FATAL) &lt;&lt; "This example requires OpenCV; compile with USE_OPENCV.";</div><div class="line">&#125;</div><div class="line">#endif  // USE_OPENCV</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用caffe的c++接口时，遇到了许多问题，学习源码中解决问题，熟悉一些细节。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
  </entry>
  
  <entry>
    <title>Caffe笔记</title>
    <link href="http://abumaster.com/2017/05/01/Caffe%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2017/05/01/Caffe笔记/</id>
    <published>2017-05-01T06:41:52.000Z</published>
    <updated>2017-05-01T12:02:51.565Z</updated>
    
    <content type="html"><![CDATA[<p>Caffe学习中的遇到的一些问题拾遗。<br><a id="more"></a>
<strong>1..solverstate的使用</strong><br>在网络训练过程中当保存一个快照时，会保存两个文件：<code>**.caffemodel</code> 和 <code>**.solverstate</code> 第一个文件是训练过程中，迭代了N次，保存的模型，第二个文件是训练过程意外暂停，如<code>ctrl+C</code> 或者电脑死机，保存的网络状态，下一次网络可以接着训练，参考<a href="https://github.com/BVLC/caffe/wiki/Training-and-Resuming">Caffe Wiki - Training and Resuming</a>。<br>使用：  </p>
<ul>
<li>命令行<br>训练：<code>caffe train -solver solver.prototxt</code><br>状态中恢复训练：<code>caffe train -solver solver.prototxt -snapshot train_190000.solverstate</code>  </li>
<li>Python 接口<br>从模型中copy参数：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">weights = <span class="string">'../ilsvrc-nets/vgg16-fcn.caffemodel'</span></div><div class="line"><span class="comment"># init</span></div><div class="line">solver = caffe.SGDSolver(<span class="string">'solver.prototxt'</span>)</div><div class="line">solver.net.copy_from(weights)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从状态中恢复训练：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">solver = caffe.SGDSolver(<span class="string">'solver.prototxt'</span>)</div><div class="line">solver.restore(<span class="string">'snapshot/train_iter_2000.solverstate'</span>)</div></pre></td></tr></table></figure></p>
<p>这时不需要copy参数了。  </p>
<p><strong>2.编写网络配置文件</strong><br>通常创建一个创建一个 solver 来表示网络的参数信息，包括：迭代次数，训练策略以及保存快照等。其中包含了一个训练网络模型定义和一个测试网络模型定义文件，也可以写在一个配置文件中，当写在一个文件中的时候，要在网络的不同之处加上：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">include &#123;</div><div class="line">    phase: TEST (TRAIN)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.网络运行过程</strong>  </p>
<ul>
<li>加载 solver 有两种方式（Python 接口）：<br><code>solver = caffe.get_solver(&#39;models/bvlc_reference_caffenet/solver.prototxt&#39;)</code> 和<br><code>solver = caffe.SGDSolver(&#39;models/bvlc_reference_caffenet/solver.prototxt&#39;)</code>  </li>
<li>开始训练：  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">solver.net.forward()  <span class="comment"># train net</span></div><div class="line">solver.test_nets[<span class="number">0</span>].forward()  <span class="comment"># test net (there can be more than one)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这是一次从输入层到损失层的计算过程，最后计算出loss，反向传播时，可以写为：<code>solver.net.backward()</code>，这是计算从损失层到输入层的梯度，并更新网络中各层的参数信息。前向传播和反向传播可以合并写，表示一次完整的计算：<code>solver.step(1)</code>。如果要按照配置文件中的最大迭代次数运行网络，则写为：<code>solver.solve()</code>。  </p>
<p><strong>4.验证模型正确率</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">accuracy = <span class="number">0</span></div><div class="line">batch_size = solver.test_nets[<span class="number">0</span>].blobs[<span class="string">'data'</span>].num <span class="comment">#训练批次</span></div><div class="line">test_iters = int(len(Xt) / batch_size) <span class="comment">#迭代次数</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_iters):</div><div class="line">    solver.test_nets[<span class="number">0</span>].forward() <span class="comment">#测试网络</span></div><div class="line">    accuracy += solver.test_nets[<span class="number">0</span>].blobs[<span class="string">'accuracy'</span>].data <span class="comment">#相加每次迭代的正确率</span></div><div class="line">accuracy /= test_iters <span class="comment">#平均正确率</span></div><div class="line">print(<span class="string">"Accuracy: &#123;:.3f&#125;"</span>.format(accuracy))</div></pre></td></tr></table></figure></p>
<p><strong>5.定义自己的Python层</strong><br>Python层通常用来对输入数据进行预处理，如在图像语义分割中，输入为Python层，用于读取训练图像和分割图像。<br>自定义Python层是，需在prototxt文件中指明层的类型为python并且指明需要的函数，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">layer &#123;</div><div class="line">  name: <span class="string">'MyPythonLayer'</span></div><div class="line">  type: <span class="string">'Python'</span></div><div class="line">  top: <span class="string">'output'</span></div><div class="line">  bottom: <span class="string">'conv'</span></div><div class="line">  python_param &#123;</div><div class="line">    module: <span class="string">'mypythonlayer'</span></div><div class="line">    layer: <span class="string">'MyLayer'</span></div><div class="line">    param_str: <span class="string">"'num': 21"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，需要按以下格式定义自己的Python文件，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> caffe</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> yaml</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLayer</span><span class="params">(caffe.Layer)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, bottom, top)</span>:</span></div><div class="line">        self.num = yaml.load(self.param_str)[<span class="string">"num"</span>]</div><div class="line">        <span class="keyword">print</span> <span class="string">"Parameter num : "</span>, self.num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reshape</span><span class="params">(self, bottom, top)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, bottom, top)</span>:</span> <span class="comment">#前传</span></div><div class="line">        top[<span class="number">0</span>].reshape(*bottom[<span class="number">0</span>].shape)</div><div class="line">        top[<span class="number">0</span>].data[...] = bottom[<span class="number">0</span>].data + self.num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, top, propagate_down, bottom)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>使用时还与普通网络调用一样进行，只是会直接用python定义的层完成输入数据的重新组织，再进行传递。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Caffe学习中的遇到的一些问题拾遗。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>尺度感知模型</title>
    <link href="http://abumaster.com/2017/04/25/%E5%B0%BA%E5%BA%A6%E6%84%9F%E7%9F%A5%E6%A8%A1%E5%9E%8B/"/>
    <id>http://abumaster.com/2017/04/25/尺度感知模型/</id>
    <published>2017-04-25T07:02:25.000Z</published>
    <updated>2017-04-25T11:44:08.513Z</updated>
    
    <content type="html"><![CDATA[<p>来自 2016 年 ICCV 论文：Attention to Scale: Scale-aware Semantic Image Segmentation，注意尺度：尺度敏感图像语义分割。在全卷积网络中合并多尺度特征已经是提高图像语义分割效果的一个关键因素。通过不同图像尺寸的输入，提取出不同尺度的信息，通过一个注意力模型获得权重融合特征图，最终得到分割图像。<br><a id="more"></a>
<strong>1.注意力模型 Attention model</strong><br>Attention model(AM)最先在计算机视觉中被应用于图片识别的问题，之后在自然语言处理(NLP)和计算机视觉(CV)中经常结合递归神经网络结构RNN、GRU、LSTM等深度学习算法，被称之为Recurrent Attention Model(RAM)，其核心就是一个Encoder-Decoder的过程。图像识别中，经常把图像缩放成固定大小，引起信息的丢失，结合人看物体时，目光会沿着感兴趣的方向移动，甚至聚焦感兴趣的区域，Attention（注意力）就是在网络中加入关注区域的移动、缩放机制、连续部分信息序列化输入。<a href="https://www.zhihu.com/question/36591394">知乎问题回答</a>。可以分为两种模型：  </p>
<ul>
<li>hard：Attention 每次移动固定大小区域；  </li>
<li>soft：Attention 每次是所有区域的一个加权和。<br><strong>注意力</strong>，人看一副图像不是按像素点去看的，往往是一个区域一个区域看的，关注感兴趣区域（Region of Interest），Attention 可以自动寻找感兴趣的区域？强化学习。<br><strong>2.如何利用多尺度信息</strong><br>在 FCNs 场景下，有两种方式利用多尺度信息，如图所示：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-25/98403353-file_1493107872063_3e36.png" alt="">  </li>
<li>利用网络中间层信息，由于随着网络层数的增加，图像不断缩小，图像的特征也会不断地丢失，在经典的FCN-8s网络中提出了融合中间层的特征图，优化最后的分割结果；  </li>
<li>多尺度图像输入，网络共享权重，不同尺度会产生不同大小的特征图，每个尺度的特征图关注点也不同，通过在最后对不同尺度特征图的融合，产生最终的分割结果。<br><strong>3.模型介绍</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-25/24866344-file_1493107637433_24f2.png" alt="model"><br>模型如何运作？<br>不同尺度图像输入 FCNs 中会生成不同的热力图（得分图），然后，如何融合不同的得分图，论文中提出了一个<em>注意力模型</em>，对于每个尺度特征图输出一个权重图，权重是如何生成的呢，通过学习，对于大物体在褚略的特征图上置为较大的权重。有了权重图，结合特征图，很容易加权融合多个尺度特征图，得到最后的输出。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-25/73523202-file_1493108587550_a9.png" alt=""><br>每个尺度，对应着一个score map，这里乘以由尺度获得的权重图，得到最终的输出图。权重是由注意力模型产生的score map的所占比重决定的，表示摸个尺度的重要性。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自 2016 年 ICCV 论文：Attention to Scale: Scale-aware Semantic Image Segmentation，注意尺度：尺度敏感图像语义分割。在全卷积网络中合并多尺度特征已经是提高图像语义分割效果的一个关键因素。通过不同图像尺寸的输入，提取出不同尺度的信息，通过一个注意力模型获得权重融合特征图，最终得到分割图像。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="论文" scheme="http://abumaster.com/tags/lunwen/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>零散</title>
    <link href="http://abumaster.com/2017/04/19/%E9%9B%B6%E6%95%A3/"/>
    <id>http://abumaster.com/2017/04/19/零散/</id>
    <published>2017-04-19T06:25:45.000Z</published>
    <updated>2017-05-19T14:03:42.963Z</updated>
    
    <content type="html"><![CDATA[<h4 id="VMware虚拟机在Windows下错误"><a href="#VMware虚拟机在Windows下错误" class="headerlink" title="VMware虚拟机在Windows下错误"></a>VMware虚拟机在Windows下错误</h4><blockquote>
<p>出现如下错误：VMware Workstation and Device/Credential Guard are not compatible</p>
</blockquote>
<a id="more"></a>
<p>Windows的虚拟化技术Hyper-v和VMware的虚拟化技术不兼容的问题！<br><strong>解决方案：</strong><br>1.关闭hyper-v服务<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-13/57980487-file_1494663243567_46cf.png" alt=""><br>如图，关闭红色框内的功能。<br>2.增加开机启动选项<br><a href="http://stackoverflow.com/questions/39858200/vmware-workstation-and-device-credential-guard-are-not-compatible/41968105#41968105">stackoverflow 问题回答</a>在CMD管理员身份运行，注意不能用PowerShell。编辑bcd。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\&gt;bcdedit /copy &#123;current&#125; /d &quot;No Hyper-V&quot; </div><div class="line">The entry was successfully copied to &#123;ff-23-113-824e-5c5144ea&#125;. </div><div class="line"></div><div class="line">C:\&gt;bcdedit /set &#123;ff-23-113-824e-5c5144ea&#125; hypervisorlaunchtype off </div><div class="line">The operation completed successfully.</div></pre></td></tr></table></figure></p>
<p>重启经过一段时间配置，开机启动项出现了两个选项：</p>
<ul>
<li>Windows 10  </li>
<li>No Hyper-V  </li>
</ul>
<p><em>删除开启启动项：</em><br>在CMD中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C:\&gt;bcdedit /v</div><div class="line">列出了开机启动项，删除对应的选项即可。</div><div class="line">C:\&gt;bcdedit /delete &#123;ff-23-113-824e-5c5144ea&#125;</div></pre></td></tr></table></figure></p>
<p>另一种，在系统配置中直接配置引导项。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-13/2502438-file_1494663696605_e059.png" alt="">  </p>
<p>图像分类：
Krizhevsky A, Sutskever I, Hinton G E. Imagenet classification with deep convolutional neural networks[C]//Advances in neural information processing systems. 2012: 1097-1105.<br>Simonyan K, Zisserman A. Very deep convolutional networks for large-scale image recognition[J]. arXiv preprint arXiv:1409.1556, 2014.<br>Papandreou G, Kokkinos I, Savalle P A. Modeling local and global deformations in deep learning: Epitomic convolution, multiple instance learning, and sliding window detection[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2015: 390-399.  </p>
<p>物体检测：
Girshick R, Donahue J, Darrell T, et al. Rich feature hierarchies for accurate object detection and semantic segmentation[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2014: 580-587.<br>Erhan D, Szegedy C, Toshev A, et al. Scalable object detection using deep neural networks[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2014: 2147-2154.<br>Ren S, He K, Girshick R, et al. Faster r-cnn: Towards real-time object detection with region proposal networks[C]//Advances in neural information processing systems. 2015: 91-99.<br>He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016: 770-778.  </p>
<p><strong>CNN用于图像分割</strong><br>Schulz H, Behnke S. Learning Object-Class Segmentation with Convolutional Neural Networks[C]//ESANN. 2012.<br>Farabet C, Couprie C, Najman L, et al. Scene parsing with multiscale feature learning, purity trees, and optimal covers[J]. arXiv preprint arXiv:1202.2160, 2012.<br>Farabet C, Couprie C, Najman L, et al. Learning hierarchical features for scene labeling[J]. IEEE transactions on pattern analysis and machine intelligence, 2013, 35(8): 1915-1929.<br>Dai J, He K, Sun J. Convolutional feature masking for joint object and stuff segmentation[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2015: 3992-4000.</p>
<p>Long J, Shelhamer E, Darrell T. Fully convolutional networks for semantic segmentation[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2015: 3431-3440.  </p>
<p>刘丹,刘学军,王美珍. 一种多尺度CNN的图像语义分割算法[J]. 遥感信息,2017,(01):57-64.<br>蒋应锋,张桦,薛彦兵,周冕,徐光平,高赞. 一种新的多尺度深度学习图像语义理解方法研究[J]. 光电子·激光,2016,(02):224-230.  </p>
<p>Mostajabi M, Yadollahpour P, Shakhnarovich G. Feedforward semantic segmentation with zoom-out features[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2015: 3376-3385.<br>Lin G, Shen C, van den Hengel A, et al. Efficient piecewise training of deep structured models for semantic segmentation[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016: 3194-3203.  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;VMware虚拟机在Windows下错误&quot;&gt;&lt;a href=&quot;#VMware虚拟机在Windows下错误&quot; class=&quot;headerlink&quot; title=&quot;VMware虚拟机在Windows下错误&quot;&gt;&lt;/a&gt;VMware虚拟机在Windows下错误&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;出现如下错误：VMware Workstation and Device/Credential Guard are not compatible&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>Caffe的C++接口调用</title>
    <link href="http://abumaster.com/2017/04/18/Caffe%E7%9A%84C-%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    <id>http://abumaster.com/2017/04/18/Caffe的C-接口调用/</id>
    <published>2017-04-18T12:25:06.000Z</published>
    <updated>2017-04-18T13:20:27.571Z</updated>
    
    <content type="html"><![CDATA[<p>Caffe的原生接口是C++，但是使用起来相对于Python和MATLAB也是最麻烦的，一个是需要配置各种第三方库，二是Windows下用VS新建C++工程出现各种编译问题。<br><a id="more"></a></p>
<h2 id="1-配置第三方库"><a href="#1-配置第三方库" class="headerlink" title="1.配置第三方库"></a>1.配置第三方库</h2><p>Windows上运行的是官方的 Caffe-Windows 项目，第三方库是从别人打包好的下载，主要分为几大类：boost、gflags、glog、hdf5、LevelDB、lmdb、OpenBLAS、OpenCV、protobuf。配置内容包括（调试器最好配置Release版本的x64平台）：<br><strong>头文件</strong><br>新建一个工程，打开项目-&gt;工程属性页，C/C++ -&gt; 常规 -&gt; 附加包含目录，添加caffe相关的头文件,caffe及第三方依赖库，我的如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\caffeDev\caffe-master\include;D:\caffeDev\NugetPackages\boost.1.59.0.0\lib\native\include;D:\caffeDev\NugetPackages\OpenCV.2.4.10\build\native\include;D:\caffeDev\NugetPackages\gflags.2.1.2.1\build\native\include;D:\caffeDev\NugetPackages\glog.0.3.3.0\build\native\include;D:\caffeDev\NugetPackages\hdf5-v120-complete.1.8.15.2\lib\native\include;D:\caffeDev\NugetPackages\lmdb-v120-clean.0.9.14.0\lib\native\include;D:\caffeDev\NugetPackages\protobuf-v120.2.6.1\build\native\include;D:\caffeDev\NugetPackages\OpenBLAS.0.2.14.1\lib\native\include;</div></pre></td></tr></table></figure></p>
<p><strong>附加库目录</strong><br>链接器 -&gt; 常规 -&gt; 附加库目录 ，添加内容为lib库所在的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;AdditionalLibraryDirectories&gt;D:\caffeDev\NugetPackages\glog.0.3.3.0\build\native\lib\x64\v120\Release\dynamic;D:\caffeDev\caffe-master\Build\x64\Release;D:\caffeDev\NugetPackages\OpenCV.2.4.10\build\native\lib\x64\v120\Release;D:\caffeDev\NugetPackages\boost_date_time-vc120.1.59.0.0\lib\native\address-model-64\lib;D:\caffeDev\NugetPackages\boost_filesystem-vc120.1.59.0.0\lib\native\address-model-64\lib;D:\caffeDev\NugetPackages\boost_system-vc120.1.59.0.0\lib\native\address-model-64\lib;D:\caffeDev\NugetPackages\protobuf-v120.2.6.1\build\native\lib\x64\v120\Release;D:\caffeDev\NugetPackages\boost_thread-vc120.1.59.0.0\lib\native\address-model-64\lib;D:\caffeDev\NugetPackages\boost_chrono-vc120.1.59.0.0\lib\native\address-model-64\lib;D:\caffeDev\NugetPackages\hdf5-v120-complete.1.8.15.2\lib\native\lib\x64;D:\caffeDev\NugetPackages\gflags.2.1.2.1\build\native\x64\v120\dynamic\Lib;D:\caffeDev\NugetPackages\OpenBLAS.0.2.14.1\lib\native\lib\x64;%(AdditionalLibraryDirectories)&lt;/AdditionalLibraryDirectories&gt;</div></pre></td></tr></table></figure></p>
<p><strong>依赖项</strong><br>输入 -&gt; 附加依赖项，中填写需要的链接库，为上述目录中的链接库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;AdditionalDependencies&gt;</div><div class="line">opencv_calib3d2410.lib;</div><div class="line">opencv_contrib2410.lib;</div><div class="line">opencv_core2410.lib;</div><div class="line">opencv_features2d2410.lib;</div><div class="line">opencv_flann2410.lib;</div><div class="line">opencv_gpu2410.lib;</div><div class="line">opencv_highgui2410.lib;</div><div class="line">opencv_imgproc2410.lib;</div><div class="line">opencv_legacy2410.lib;</div><div class="line">opencv_ml2410.lib;</div><div class="line">opencv_nonfree2410.lib;</div><div class="line">opencv_objdetect2410.lib;</div><div class="line">opencv_ocl2410.lib;</div><div class="line">opencv_photo2410.lib;</div><div class="line">opencv_stitching2410.lib;</div><div class="line">opencv_superres2410.lib;</div><div class="line">opencv_ts2410.lib;</div><div class="line">opencv_video2410.lib;</div><div class="line">opencv_videostab2410.lib;</div><div class="line">libglog.lib;</div><div class="line">caffe.lib;</div><div class="line">libprotobuf.lib;</div><div class="line">libcaffe.lib;</div><div class="line">gflags.lib;</div><div class="line">gflags_nothreads.lib;</div><div class="line">hdf5.lib;</div><div class="line">hdf5_cpp.lib;</div><div class="line">hdf5_f90cstub.lib;</div><div class="line">hdf5_fortran.lib;</div><div class="line">hdf5_hl.lib;</div><div class="line">hdf5_hl_cpp.lib;</div><div class="line">hdf5_hl_f90cstub.lib;</div><div class="line">hdf5_hl_fortran.lib;</div><div class="line">hdf5_tools.lib;</div><div class="line">szip.lib;</div><div class="line">zlib.lib;</div><div class="line">libopenblas.dll.a;</div><div class="line">%(AdditionalDependencies)</div><div class="line">&lt;/AdditionalDependencies&gt;</div></pre></td></tr></table></figure></p>
<h2 id="2-运行时问题"><a href="#2-运行时问题" class="headerlink" title="2.运行时问题"></a>2.运行时问题</h2><p>实际新建一个项目（从caffe工程中拷的源码，配置好一切环境），可以编译成功，但是运行时出现问题：<br><strong>F0519 14:54:12.494139 14504 layer_factory.hpp:77] Check failed: registry.count(type) == 1 (0 vs. 1) Unknown layer type: Input (known types: Input )</strong><br>一者说，只有在caffe解决方案中新建项目，才可以正常运行<a href="https://github.com/Microsoft/caffe/issues/45">问题</a>。还有利用别人改进的caffe来减少外部的依赖关系，<a href="https://github.com/dtmoodie/caffe">dtmoodie</a>。<br>另外一种，<a href="http://blog.csdn.net/fangjin_kl/article/details/50936952#0-tsina-1-63793-397232819ff9a47a7b7e80a40613cfe1">解决方法</a>主要解决方案是将caffe中的各层都放进一个头文件中包含进工程中，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"caffe/common.hpp"</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"caffe/layers/input_layer.hpp"</span></span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="title">INSTANTIATE_CLASS</span><span class="params">(InputLayer)</span></span>;<span class="comment">//添加层信息</span></div><div class="line">REGISTER_LAYER_CLASS(Input);<span class="comment">//注册层信息</span></div></pre></td></tr></table></figure></p>
<p>可以完美运行了。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Caffe的原生接口是C++，但是使用起来相对于Python和MATLAB也是最麻烦的，一个是需要配置各种第三方库，二是Windows下用VS新建C++工程出现各种编译问题。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
  </entry>
  
  <entry>
    <title>高效分片训练结构化模型用于图像语义分割</title>
    <link href="http://abumaster.com/2017/04/17/%E9%AB%98%E6%95%88%E5%88%86%E7%89%87%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%84%E5%8C%96%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    <id>http://abumaster.com/2017/04/17/高效分片训练结构化模型用于图像语义分割/</id>
    <published>2017-04-17T08:58:15.000Z</published>
    <updated>2017-04-18T02:13:45.979Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>cvpr 论文：Efficient Piecewise Training of Deep Structured Models for Semantic
Segmentation 利用上下文信息提高分割图的精度。从两个方面入手：物体与物体之间、物体与背景之间。前者使用CNN结合CRF，来构造临近像素之间的关系；后者通过多尺度图像输入和滑动的金字塔池化。  </p>
</blockquote>
<a id="more"></a>
<p><strong>特点：</strong>  </p>
<ol>
<li>制定了基于CNN的在CRFs上总体分段潜在函数模型用于衡量语义图像片之间的关系；  </li>
<li>分段训练CRFs，避免重复推导，提高速度；  </li>
<li>多尺度图像输入，用于探索图像背景和前景上下文信息；  </li>
</ol>
<hr>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-17/28980161-file_1492432013053_14485.png" alt=""><br>Featmap-Net是一个卷积网络，用于输出特征图，低分辨率的特征图；
创建CRF图，首先对于卷积网络生成的特征图，创建一些边界框，在边界框内被认为空间近似，顶点才会全连接，不同空间会创建不同的边界框。  </p>
<p><strong>上下文深度CRFs</strong><br>分为一元组的图的顶点和二元组的图的边，分别对应一个能量函数，通过一元和二元网络对应生成了类别的预测。<br><strong>利用背景上下文</strong><br>产生特征图的网络：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-18/67947492-file_1492479486028_4096.png" alt=""></p>
<p>首先将输入图像缩放为三个不同的大小，放入网络，共享权重。图像缩放大小为1.2,0.8,0.4，再经过一层独立的卷积产生多尺度特征图，然后经过滑动金字塔池化产生了组合的特征图，金字塔池化如下图所示：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-18/81267394-file_1492479935056_11ffe.png" alt=""><br>使用双线性上采样和简单的边界优化对粗糙的预测结果进行后期处理，可能又更复杂的优化方式，比如：训练反卷积网络，训练复杂的从粗糙到精细的网络，利用中间特征图到高分辨率的预测。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;cvpr 论文：Efficient Piecewise Training of Deep Structured Models for Semantic
Segmentation 利用上下文信息提高分割图的精度。从两个方面入手：物体与物体之间、物体与背景之间。前者使用CNN结合CRF，来构造临近像素之间的关系；后者通过多尺度图像输入和滑动的金字塔池化。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="论文" scheme="http://abumaster.com/tags/lunwen/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>拉普拉斯重建和细化用于图像语义分割</title>
    <link href="http://abumaster.com/2017/04/16/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%8D%E5%BB%BA%E5%92%8C%E7%BB%86%E5%8C%96%E7%94%A8%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    <id>http://abumaster.com/2017/04/16/拉普拉斯重建和细化用于图像语义分割/</id>
    <published>2017-04-16T08:05:56.000Z</published>
    <updated>2017-04-17T07:21:41.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>来自论文：Laplacian Reconstruction and Refinement for Semantic Segmentation，论文有两个贡献：1）证明了卷积特征图的空间低分辨率，但是在高维特征表示中包含重要的子像素定位信息；2）提出了一种类似拉普拉斯金字塔的多分辨率重建结构，对高分辨率特征图的跳跃连接可以从低分辨率特征图重建并成功细化分割图像的边界。  </p>
</blockquote>
<a id="more"></a>
<p><em>空间语义不确定性原则</em>，探索在CNN特征层次结构中的空间和语义正确性。网络的顶层图像语义预测准确，但是带来的缺陷是在低分辨率下的图像空间上的定位，边界清晰但是标签有噪声。提出了一种重建模型在给定层次上提高空间定位的准确性，和一种细化技术用来融合多层的信息来优化图像的语义分割结果。<br>与传统FCN的区别：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-16/29818085-file_1492332368566_59f2.png" alt=""><br>不同之处在于，上采样和重建。<br><strong>CNN 特征图固有的缺少空间细节信息</strong>用一些不同的方法可以解决，如条件随机场、超像素、边界检测。还有一些成对的特征映射，可以进行反向传播进行训练。此论文的方法是<strong>直接提高输出激活图空间分辨率</strong>。<br><strong>双线性上采样是从低分辨率特征图中计算出高分辨率分割图的一种标准方法</strong>，首先卷积网络从特征图中计算出低分辨率的得分图，然后使用线性过滤器上采样为高分辨率的得分图。这种方法<em>可能会从多通道低分辨率特征图中丢失定位信息</em>。为了保留更多的空间信息，论文避免了将高维特征图折叠成低分辨率的类别预测。取而代之的是利用高分辨率基函数的线性组合对高分辨率的分类得分图的空间模式进行编码，这些函数的权重被高维特征图预测得到。实现：将高分辨率的特征图分成不重叠的图像块，大小取决于网络中池化层的个数次幂，通过一个卷积网络预测从高纬度低分辨率到特征图像块的映射。这些特征图像块和类别系数与一个基本函数集合相乘，再与一个基本的去卷积层相加，得到期望的全分辨率类别图。<br><strong>连接样条插值</strong><br>更高阶的样条插值替代上采样。<br><strong>学习基本函数</strong><br><strong>基本结构</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-17/25758666-file_1492397377051_a8d3.png" alt=""><br>首先，网络从上到下，分辨率越来越小。在每一次缩小时，特征图重建，再进行组合，产生对应倍数特征图的分割得分图，上图的水平方向，通过组合不同倍数的得分图。<br>一种从高分辨率中减去低频成分的方法，边界masking，孤立出边界成分。<br>金字塔的应用：<br>下层分割图得分上采样作为上一层采样的参考，用于得分图和像素对的产生。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-4-17/99567344-file_1492411678446_ecd2.png" alt=""><br><strong>Conclusion</strong>  </p>
<ul>
<li>以特定类重建为基础作为上采样；  </li>
<li>合成低分辨率的语义丰富的特征图和拥有更多空间特性的高分辨率特征图，多层拉普拉斯金字塔重建结构。  </li>
<li>最后可以加上CRF进行后期处理，优化结果。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;来自论文：Laplacian Reconstruction and Refinement for Semantic Segmentation，论文有两个贡献：1）证明了卷积特征图的空间低分辨率，但是在高维特征表示中包含重要的子像素定位信息；2）提出了一种类似拉普拉斯金字塔的多分辨率重建结构，对高分辨率特征图的跳跃连接可以从低分辨率特征图重建并成功细化分割图像的边界。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="论文" scheme="http://abumaster.com/tags/lunwen/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>网易2017春招笔试编程题</title>
    <link href="http://abumaster.com/2017/04/14/%E7%BD%91%E6%98%932017%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://abumaster.com/2017/04/14/网易2017春招笔试编程题/</id>
    <published>2017-04-14T06:14:18.000Z</published>
    <updated>2017-04-14T06:45:55.647Z</updated>
    
    <content type="html"><![CDATA[<p><strong>感悟</strong>：读的算法书，练习的算法题目都学到狗身上去了？不能活学活用，也就不能灵光乍现，难以进步。看似简单的题目，往往没有经过深思熟虑，导致复杂度高，无法通过。欠缺思考。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;感悟&lt;/strong&gt;：读的算法书，练习的算法题目都学到狗身上去了？不能活学活用，也就不能灵光乍现，难以进步。看似简单的题目，往往没有经过深思熟虑，导致复杂度高，无法通过。欠缺思考。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
