<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2018-04-15T09:25:23.666Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vcpkg：vc++ 的包管理器</title>
    <link href="http://abumaster.com/2018/04/15/vcpkg%EF%BC%9Avc-%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://abumaster.com/2018/04/15/vcpkg：vc-的包管理器/</id>
    <published>2018-04-15T07:22:32.000Z</published>
    <updated>2018-04-15T09:25:23.666Z</updated>
    
    <content type="html"><![CDATA[<p><a href=""><strong>vcpkg</strong></a> 是一个Windows下vc++的第三方库管理工具，提供了第三方库的快速安装和配置，为Windows下C++开发提供了一种有效的工具。  </p>
<a id="more"></a>
<p><strong>vcpkg</strong> 可以在Windows上安装C、C++第三方的库。通常Windows下使用第三方库时，没有在Linux下使用方便，需要自己下源码编译，并在项目中加入库和头文件的目录，十分麻烦，并且vc++的版本不同也可能出现库的不兼容问题，而vcpkg可以很好的解决这个问题。可以使用简单的几条命令安装第三方库，使用时只需要包含头文件，不再需要配置头文件目录和链接库的目录。  </p>
<hr>
<p><strong>安装需求：</strong>  </p>
<ul>
<li>Windows 10,8 或 7；  </li>
<li>vs2017或vs2015 update3；  </li>
<li>Git 2.10.x 以上；  </li>
<li>Cmake 3.10 以上。  </li>
</ul>
<hr>
<p><strong>简单使用：</strong><br><strong>1.安装</strong><br>从Microsoft的Github仓库找到vcpkg的仓库，clone到本地<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/Microsoft/vcpkg.git</div></pre></td></tr></table></figure></p>
<p>进入根目录下运行一下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.\bootstrap-vcpkg.bat       #生成vcpkg.exe</div><div class="line">.\vcpkg integrate install   #连接到用户集成中</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-15/8337753.jpg" alt=""><br>然后，安装的库直接可以在自己的项目中使用，只需要包含头文件。  </p>
<p><strong>2.安装第三方库</strong><br>常用的几个命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vcpkg list                  <span class="comment"># 列出安装的第三方库</span></div><div class="line">vcpkg search xxxlib         <span class="comment"># 查找可以安装的库</span></div><div class="line">vcpkg install xxxlib        <span class="comment"># 安装xxxlib库</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-15/11870040.jpg" alt=""><br>安装完第三方库后，可以加入头文件，直接编译使用，不再需要繁琐的目录配置。  </p>
<p><strong>3.高级应用</strong><br><a href="https://github.com/Microsoft/vcpkg/blob/master/docs/examples/packaging-zlib.md">打包第三方库</a>，当无法搜到需要的库的时候，可以自己通过源码打包，配置，然后安装到本地。暂时没用到，用到时详细参考文档。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;&quot;&gt;&lt;strong&gt;vcpkg&lt;/strong&gt;&lt;/a&gt; 是一个Windows下vc++的第三方库管理工具，提供了第三方库的快速安装和配置，为Windows下C++开发提供了一种有效的工具。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="包管理" scheme="http://abumaster.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的使用</title>
    <link href="http://abumaster.com/2018/04/13/mongoDB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2018/04/13/mongoDB的使用/</id>
    <published>2018-04-13T06:25:47.000Z</published>
    <updated>2018-04-13T08:06:26.853Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是一种非关系数据库，是一种 NoSQL 型数据库，用于应对大数据和分布式系统的数据库，具有高扩展性和分布式，没有复杂的关系模型。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<a id="more"></a>
<h3 id="MongoDB-简介和安装"><a href="#MongoDB-简介和安装" class="headerlink" title="MongoDB 简介和安装"></a>MongoDB 简介和安装</h3><p>MongoDB 是一种<a href="http://www.runoob.com/mongodb/nosql.html">NoSQL</a>型数据库，使用C++编写，基于分布式文件存储的开源数据库系统。<br><a href="https://www.mongodb.com/download-center#community">官方下载地址</a>。<br>在 Windows 系统环境下，可以下载安装包或者压缩包，解压后在 <code>bin</code> 目录下找到可执行的文件，其中 <code>mongod.exe</code> 是数据库服务，使用时需要打开，<code>mongo.exe</code> 是MongoDB数据库的控制台，命令终端。另外，该目录下还提供了数据库的状态查看和管理小程序。  </p>
<h4 id="MongoDB-服务器的运行"><a href="#MongoDB-服务器的运行" class="headerlink" title="MongoDB 服务器的运行"></a>MongoDB 服务器的运行</h4><p><strong>有两种方式运行：<em>命令行</em> 和 <em>配置服务</em> </strong><br>第一种方法是从终端运行 MongoDB 服务器，需要指定数据库的存储路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod.exe --dbpath mydbpath\db</div></pre></td></tr></table></figure></p>
<p>第二种方法是编写Windows下的服务程序，使MongoDB服务器以服务的形式存在，创建一个 <code>mongodd.cfg</code> 文件，在其中指定日志路径和数据库路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">systemLog:</div><div class="line">    destination: file</div><div class="line">    path: D:\Program Files (x86)\mongodb-win32-x86_64\bin\log\mongod.log</div><div class="line">storage:</div><div class="line">    dbPath: D:\Program Files (x86)\mongodb-win32-x86_64\bin\db</div></pre></td></tr></table></figure></p>
<p>然后以管理员的身份运行：<code>mongod.exe --config &quot;path\mongod.cfg&quot; --install</code> 安装服务，这时可以在Windows服务中看到一个名为MongoDB的服务，可以手动启动或者使用命令启动和关闭：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">net start MongoDB   <span class="comment"># 启动服务</span></div><div class="line">net stop MongoDB    <span class="comment"># 关闭服务</span></div><div class="line">mongod.exe --remove <span class="comment"># 移除服务</span></div></pre></td></tr></table></figure></p>
<h4 id="连接-MongoDB-服务器"><a href="#连接-MongoDB-服务器" class="headerlink" title="连接 MongoDB 服务器"></a>连接 MongoDB 服务器</h4><p>使用 <code>mongo</code> 命令进入 MongoDB 后台管理的shell，默认连接到其中的test数据库，可以使用一些简单的JavaScript语句。  </p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="创建和删除数据库"><a href="#创建和删除数据库" class="headerlink" title="创建和删除数据库"></a>创建和删除数据库</h4><p>查看所有包含数据的数据库： <code>show dbs</code><br>查看当前使用的数据库： <code>db</code><br>切换和创建数据库 <code>use DB_NAME</code> 不存在会创建
需要删除某一个数据库，可以先切换到某一个数据库下，然后执行 <code>db.dropDatabase()</code> </p>
<h4 id="创建和删除集合"><a href="#创建和删除集合" class="headerlink" title="创建和删除集合"></a>创建和删除集合</h4><p>创建的基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createCollection(name, options)</div></pre></td></tr></table></figure></p>
<p>name 为名称，options为选项用来指定集合的大小和文档的最大数量。<br>删除集合 <code>db.collection.drop()</code> ，删除前使用 <code>show collections</code> 或者 <code>show tables</code> 查看集合，然后调用具体的集合删除。  </p>
<h4 id="文档的操作"><a href="#文档的操作" class="headerlink" title="文档的操作"></a>文档的操作</h4><p><strong>插入文档的基本操作</strong>，文档相当于一个json数据结构的文件。插入的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.COLLECTION_NAME.insert(document)</div></pre></td></tr></table></figure></p>
<p>其中要指定插入到的集合，document是一个json格式如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">"title"</span> : <span class="string">"MongoDB 教程"</span>,</div><div class="line">        <span class="attr">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</div><div class="line">        <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>,</div><div class="line">        <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</div><div class="line">        <span class="attr">"tags"</span> : [</div><div class="line">                <span class="string">"mongodb"</span>,</div><div class="line">                <span class="string">"database"</span>,</div><div class="line">                <span class="string">"NoSQL"</span></div><div class="line">        ],</div><div class="line">        <span class="attr">"likes"</span> : <span class="number">100</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 <code>db.col.find()</code> 可以查找插入的文档。  </p>
<p><strong>更新文档</strong> 通过 <code>update</code> 语句，基本语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.collection.update(</div><div class="line">   &lt;query&gt;,     # 类似SQL中where后面的 找到要更改的记录</div><div class="line">   &lt;update&gt;,    # set后面的内容 更改的内容</div><div class="line">   &#123;</div><div class="line">     upsert: &lt;boolean&gt;, #没有修改记录是否插入新的</div><div class="line">     multi: &lt;boolean&gt;, # 插入多条记录</div><div class="line">     writeConcern: &lt;document&gt; #抛出异常级别</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>通过 <code>save()</code> 方法，可以通过传入一个文档替换现有的文档。</p>
<p><strong>删除文档</strong> 通过 <code>remove</code> 来删除，基本语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.collection.remove(</div><div class="line">   &lt;query&gt;,</div><div class="line">   &#123;</div><div class="line">     justOne: &lt;boolean&gt;,</div><div class="line">     writeConcern: &lt;document&gt;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>使用更新的方法 <code>deleteOne()</code> 和 <code>deleteMany()</code> 方法删除文档：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.deleteMany(&#123;&#125;)  <span class="comment"># 删除所有的文档</span></div><div class="line">db.collection.deleteMany(&#123;status:<span class="string">"A"</span>&#125;) <span class="comment"># 删除所有status为A的文档</span></div><div class="line">db.collection.deleteOne(&#123;status:<span class="string">"A"</span>&#125;)  <span class="comment"># 删除一条</span></div></pre></td></tr></table></figure></p>
<p><strong>查询文档</strong> 简单的查询方式一种非结构化和一种结构化的输出方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.collection.find(query, projection)</div><div class="line">db.collection.find(query, projection).pretty()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 是一种非关系数据库，是一种 NoSQL 型数据库，用于应对大数据和分布式系统的数据库，具有高扩展性和分布式，没有复杂的关系模型。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://abumaster.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="NoSql" scheme="http://abumaster.com/tags/NoSql/"/>
    
      <category term="MongoDB" scheme="http://abumaster.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-4</title>
    <link href="http://abumaster.com/2018/04/08/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-4/"/>
    <id>http://abumaster.com/2018/04/08/高效使用STL-4/</id>
    <published>2018-04-08T07:07:38.000Z</published>
    <updated>2018-04-12T13:20:41.172Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，使用STL编程。</p>
</div>
<a id="more"></a>
<h4 id="条款43：尽量用算法取代循环"><a href="#条款43：尽量用算法取代循环" class="headerlink" title="条款43：尽量用算法取代循环"></a>条款43：尽量用算法取代循环</h4><p>每个算法至少接收一组迭代器来表示容器的区间，如查找最大最小值，查找满足某一条件的元素，这时用内置的一些算法可以解决，不需要手写一些循环，效率更高，即使在算法的内部遍历也是由循环来搞定的。优点包括：  </p>
<ul>
<li><strong>效率</strong>：通常算法比循环更高效；  </li>
<li><strong>正确性</strong>：写循环更容易出错，且代码较算法来的复杂；  </li>
<li><strong>可维护性</strong>：算法代码简洁，便于维护。  </li>
</ul>
<h4 id="条款44：尽量使用成员函数替代同名算法"><a href="#条款44：尽量使用成员函数替代同名算法" class="headerlink" title="条款44：尽量使用成员函数替代同名算法"></a>条款44：尽量使用成员函数替代同名算法</h4><p>出于效率考虑，可以使用容器的成员函数替代同名的算法，成员函数的速度相对较快。  </p>
<h4 id="条款45：注意-count、find、binary-search、lower-bound、upper-bound和equal-range-的区别"><a href="#条款45：注意-count、find、binary-search、lower-bound、upper-bound和equal-range-的区别" class="headerlink" title="条款45：注意 count、find、binary_search、lower_bound、upper_bound和equal_range 的区别"></a>条款45：注意 <code>count、find、binary_search、lower_bound、upper_bound和equal_range</code> 的区别</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-12/37444869.jpg" alt="">  </p>
<h4 id="条款46：考虑使用函数对象代替函数作算法的参数"><a href="#条款46：考虑使用函数对象代替函数作算法的参数" class="headerlink" title="条款46：考虑使用函数对象代替函数作算法的参数"></a>条款46：考虑使用函数对象代替函数作算法的参数</h4><p>将函数对象传递给STL算法的效率比传递真的函数高。如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对容器中数据进行降序排序</span></div><div class="line"><span class="comment">//1.使用函数对象greater</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</div><div class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">double</span>&gt;());</div><div class="line"><span class="comment">//2.使用函数</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">doubleGreater</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">return</span> dl &gt; d2;</div><div class="line">&#125;</div><div class="line">sort(v.begin(), v.end(), doubleGreater);</div></pre></td></tr></table></figure></p>
<p>函数作为参数实际上是传递的函数指针，在每一次调用的时候编译器产生一个间接函数调用，通过指针调用。  </p>
<h4 id="条款47：避免产生只写代码"><a href="#条款47：避免产生只写代码" class="headerlink" title="条款47：避免产生只写代码"></a>条款47：避免产生只写代码</h4><p>灵感的乍现，让写代码变得容易，但是后期很难从代码中领会其真正所要表达的意思，称之为只写代码。<br>原书中说道：  </p>
<blockquote>
<p>代码的读比写更经常，这是软件工程的真理。也就是说软件的维护比开发花费多得多的时间。不能读和理解的软件不能被维护，不能维护的软件几乎没有不值得拥有。你用STL越多，你会感到它越来越舒适，而且你会越来越多的使用嵌套函数调用和即时（on the fly）建立函数对象。这没有什么错的，但永远记住你今天写的代码会被某个人——也可能是你——在未来的某一天读到。为那天做准备吧。</p>
</blockquote>
<h4 id="条款48：总是-include适当的头文件"><a href="#条款48：总是-include适当的头文件" class="headerlink" title="条款48：总是#include适当的头文件"></a>条款48：总是<code>#include</code>适当的头文件</h4><p>包含正确的头文件，谨记以下几条：  </p>
<ul>
<li>几乎所有的容器都在其同名的头文件中；  </li>
<li>算法常在 <code>algorithm</code> 头文件中，除了 <code>accumulate inner_product、adjacent_difference和partial_sum</code> 在 <code>numeric</code>；  </li>
<li>特殊的迭代器在 <code>iterator</code> 中，流迭代器和缓冲迭代器；  </li>
<li>标准仿函数和仿函数适配器在 <code>functional</code> 头文件中。  </li>
</ul>
<h4 id="条款49：学习破解有关STL的编译器诊断信息"><a href="#条款49：学习破解有关STL的编译器诊断信息" class="headerlink" title="条款49：学习破解有关STL的编译器诊断信息"></a>条款49：学习破解有关STL的编译器诊断信息</h4><h4 id="条款50：不断学习"><a href="#条款50：不断学习" class="headerlink" title="条款50：不断学习"></a>条款50：不断学习</h4><p>善于利用网络资源：  </p>
<ul>
<li>SGI STL网站: <a href="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>   </li>
<li>STLport网站， <a href="http://www.stlport.org/">http://www.stlport.org/</a>   </li>
<li>Boost网站， <a href="http://www.boost.org/">http://www.boost.org/</a>  或者 <a href="http://boost.sourceforge.net/">http://boost.sourceforge.net/</a> </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，使用STL编程。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-3</title>
    <link href="http://abumaster.com/2018/04/08/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-3/"/>
    <id>http://abumaster.com/2018/04/08/高效使用STL-3/</id>
    <published>2018-04-08T07:07:12.000Z</published>
    <updated>2018-04-11T12:15:48.656Z</updated>
    
    <content type="html"><![CDATA[<div class="note success"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第五章算法和第六章仿函数的介绍。</p>
</div>
<a id="more"></a>
<h4 id="条款30：确保目标空间足够大"><a href="#条款30：确保目标空间足够大" class="headerlink" title="条款30：确保目标空间足够大"></a>条款30：确保目标空间足够大</h4><p>使用算法插入时插入的是不存在的空即迭代器的尾部，编译出错。  </p>
<h4 id="条款31：排序选择"><a href="#条款31：排序选择" class="headerlink" title="条款31：排序选择"></a>条款31：排序选择</h4><p>根据实际的需求选择合适的排序算法：  </p>
<ul>
<li>如果你需要在vector、string、deque或数组上进行完全排序，你可以使用 <code>sort</code> 或 <code>stable_sort</code>。  </li>
<li>如果你有一个vector、string、deque或数组，你只需要排序前n个元素，应该用 <code>partial_sort</code>。  </li>
<li>如果你有一个vector、string、deque或数组，你需要鉴别出第n个元素或你需要鉴别出最前的n个元素，而不用知道它们的顺序，<code>nth_element</code>是你应该注意和调用的。  </li>
<li>如果你需要把标准序列容器的元素或数组分隔为满足和不满足某个标准，你大概就要找 <code>partition</code> 或 <code>stable_partition</code>。  </li>
<li>如果你的数据是在list中，你可以直接使用 <code>partition</code> 和 <code>stable_partition</code>，你可以使用list的 <code>sort</code>来代替 <code>sort</code> 和<code>stable_sort</code>。   </li>
<li>如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务，但正如我
在上面勾画的，会有很多选择。  </li>
</ul>
<h4 id="条款32：如果真要删除东西，在remove-后加上-erase"><a href="#条款32：如果真要删除东西，在remove-后加上-erase" class="headerlink" title="条款32：如果真要删除东西，在remove 后加上 erase"></a>条款32：如果真要删除东西，在<code>remove</code> 后加上 <code>erase</code></h4><p>STL 算法 <code>remove</code> 不是真正意义上的删除元素，而是遇见一个满足条件的元素，然后将其后的元素向前移动，元素的个数是不变的。而想真正删除，需要使用 <code>erase</code> 函数，将指定迭代器的元素删除。  </p>
<h4 id="条款33：避免在指针容器上使用-remove"><a href="#条款33：避免在指针容器上使用-remove" class="headerlink" title="条款33：避免在指针容器上使用 remove"></a>条款33：避免在指针容器上使用 <code>remove</code></h4><p>如上条款一样，这个算法不是真正意义上的删除，而是将元素向前移动，在指针容器上使用，可能会导致内存的泄漏。  </p>
<h4 id="条款34：注意哪个算法需要使用有序空间"><a href="#条款34：注意哪个算法需要使用有序空间" class="headerlink" title="条款34：注意哪个算法需要使用有序空间"></a>条款34：注意哪个算法需要使用有序空间</h4><h4 id="条款35：使用-mismatch-和-lexicographical-compare-实现简单的忽略大小写字符串比较"><a href="#条款35：使用-mismatch-和-lexicographical-compare-实现简单的忽略大小写字符串比较" class="headerlink" title="条款35：使用 mismatch 和 lexicographical_compare 实现简单的忽略大小写字符串比较"></a>条款35：使用 <code>mismatch</code> 和 <code>lexicographical_compare</code> 实现简单的忽略大小写字符串比较</h4><h4 id="条款36：了解-copy-if-的正确实现"><a href="#条款36：了解-copy-if-的正确实现" class="headerlink" title="条款36：了解 copy_if 的正确实现"></a>条款36：了解 <code>copy_if</code> 的正确实现</h4><h4 id="条款37：统计区间"><a href="#条款37：统计区间" class="headerlink" title="条款37：统计区间"></a>条款37：统计区间</h4><p>STL中提供了一些用于统计的算法，如 <code>count</code> 用来统计具有某一值的元素的个数，<code>count_if</code> 用于统计满足某一判别式的元素个数，区间中的最大最小值可以使用 <code>max_element</code> 和 <code>min_element</code> 得到。如果需要对某一区间中的元素定制更加复杂的操作，比如容器中元素求和，乘积和平均，可以使用 <code>accumulate</code> 和 <code>for_each</code> 定制仿函数，对容器进行操作。  </p>
<h4 id="条款38：把仿函数设计为用于值传递"><a href="#条款38：把仿函数设计为用于值传递" class="headerlink" title="条款38：把仿函数设计为用于值传递"></a>条款38：把仿函数设计为用于值传递</h4><p>在C和CPP中不允许将函数作为参数传递给函数，需要传递一个函数指针作为参数。如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">///最后一个参数是一个函数指针</div><div class="line">void qsort(void *base, size_t nmemb, size_t size,</div><div class="line">            int (*cmpfcn)(const void*, const void*));</div></pre></td></tr></table></figure></p>
<h4 id="条款39：用纯函数做判断式"><a href="#条款39：用纯函数做判断式" class="headerlink" title="条款39：用纯函数做判断式"></a>条款39：用纯函数做判断式</h4><h4 id="条款40：使仿函数类可以适配"><a href="#条款40：使仿函数类可以适配" class="headerlink" title="条款40：使仿函数类可以适配"></a>条款40：使仿函数类可以适配</h4><h4 id="条款41：了解使用-ptr-fun-、mem-fun-的原因"><a href="#条款41：了解使用-ptr-fun-、mem-fun-的原因" class="headerlink" title="条款41：了解使用 ptr_fun 、mem_fun 的原因"></a>条款41：了解使用 <code>ptr_fun</code> 、<code>mem_fun</code> 的原因</h4><h4 id="条款42：确定-less-lt-T-gt-表示-operator-lt"><a href="#条款42：确定-less-lt-T-gt-表示-operator-lt" class="headerlink" title="条款42：确定 less&lt;T&gt; 表示 operator&lt;"></a>条款42：确定 <code>less&lt;T&gt;</code> 表示 <code>operator&lt;</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note success&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第五章算法和第六章仿函数的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-2</title>
    <link href="http://abumaster.com/2018/04/07/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-2/"/>
    <id>http://abumaster.com/2018/04/07/高效使用STL-2/</id>
    <published>2018-04-07T10:55:12.000Z</published>
    <updated>2018-04-10T06:40:02.434Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第二章 <code>vector</code> 和 <code>string</code> 和第三章的关联容器的介绍。</p>
</div>
<a id="more"></a>
<h4 id="条款13：使用-vector-和-string-替代动态分配的数组"><a href="#条款13：使用-vector-和-string-替代动态分配的数组" class="headerlink" title="条款13：使用 vector 和 string 替代动态分配的数组"></a>条款13：使用 <code>vector</code> 和 <code>string</code> 替代动态分配的数组</h4><p><strong>动态申请空间的弊端：</strong>  </p>
<ul>
<li>保证 <code>new</code> 和 <code>delete</code> 的成对出现，否则容易造成内存泄漏；  </li>
<li>保证 <code>delete</code> 的正确使用对象使用 <code>delete</code> ，而数组则要使用 <code>delete []</code> 形式；</li>
<li>保证 <code>delete</code> 只使用一次，以免发生错误。  </li>
</ul>
<p>因此，如果需要使用 <strong>动态分配数组</strong> 形式的数据结构可以考虑使用 <code>vector</code> 或者 <code>string</code> 容器，其有安全的内存管理机制，可以保证不会发生内存泄漏的问题。</p>
<h4 id="条款14：使用-reserve-来避免不必要的重新分配"><a href="#条款14：使用-reserve-来避免不必要的重新分配" class="headerlink" title="条款14：使用 reserve 来避免不必要的重新分配"></a>条款14：使用 <code>reserve</code> 来避免不必要的重新分配</h4><p>像 <code>vector</code> 这样的容器，其可以最大容纳元素的数量 <code>capacity()</code> 往往要大于当前大小 <code>size()</code> 这保证其不需要插入一个元素就要申请空间，更加高效。然而当我们频繁插入元素的时候，往往是大于所能够容纳的最大元素，这时需要重新分配空间，其步骤如下：  </p>
<ul>
<li>分配新的内存空间，一般是当前容量的倍数；   </li>
<li>将旧空间的元素拷贝到新的空间中；  </li>
<li>销毁旧空间上的对象；  </li>
<li>回收旧空间。<br>开销非常大，并且会让迭代器、指针和引用失效。这时为了避免这种不需要的代价，可以预估所需空间一次分配足够大的空间。<br>通常有两个成员函数可以使用：  </li>
<li><code>resize(size_type n)</code> 通常返回设置的新大小 <code>n</code> ，需要注意的是，这个函数将会在容器中构造新的元素，当 <code>n</code> 大于当前容器大小时，如果小于，则会将尾部的元素销毁，大于最大容量时，会发生重新分配；  </li>
<li><code>reserve(size_type n)</code> 函数通常设置容器的最大空间和大小为 <code>n</code> ，当 <code>n</code> 大于当前最大容量时才会发生内存的重新配置。<br>因此可以使用 <code>reserve</code> 函数来通过预估使用空间的大小申请足够大的空间，来避免频繁申请配置空间。  </li>
</ul>
<h4 id="条款15：小心-string-实现的多样性"><a href="#条款15：小心-string-实现的多样性" class="headerlink" title="条款15：小心 string 实现的多样性"></a>条款15：小心 <code>string</code> 实现的多样性</h4><p><code>string</code> 类型在各个平台下的实现是不同的，如果使用 <code>sizeof(string)</code> 来获得其大小会发现，它的大小为 1 或者 7 倍 <code>char *</code> 。</p>
<h4 id="条款16：如何将-vector-和-string-的数据传递遗留的-API"><a href="#条款16：如何将-vector-和-string-的数据传递遗留的-API" class="headerlink" title="条款16：如何将 vector 和 string 的数据传递遗留的 API"></a>条款16：如何将 <code>vector</code> 和 <code>string</code> 的数据传递遗留的 API</h4><p>对一些旧的API传递的参数是数组或者指针，当使用 <code>vector</code> 或者 <code>string</code> 作为参数传递时，要发生一定的转变。<br>通常，由于如 <code>vector</code> 容器那样，内存分布是连续的与普通的数组没有两样，可以用首元素的地址当做是数组名称，当然需对容器非空进行判断。一个技巧是，当使用 <code>C</code> 风格的API时，参数是数组的情况下，需要将数据传递给其他容器，可以使用 <code>vector</code> 作为中介，然后用它去初始化其他容器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从 C API 中获得数据 传递到其他容器中</span></div><div class="line"><span class="keyword">size_t</span> fillArray(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize); <span class="comment">// C API</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd(maxNumDoubles);</div><div class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.size()));</div><div class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到deque</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; l(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到list</span></div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; s(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到set</span></div><div class="line"></div><div class="line"><span class="comment">// 将其他容器中的数据传递到 C API 中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pints, <span class="keyword">size_t</span> numInts)</span></span>; <span class="comment">// C API (同上)</span></div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet; <span class="comment">// 保存要传递给API数据的set</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(intSet.begin(), intSet.end()); <span class="comment">// 拷贝set数据到vector</span></div><div class="line"><span class="keyword">if</span> (!v.empty()) doSomething(&amp;v[<span class="number">0</span>], v.size()); <span class="comment">// 传递数据到API</span></div></pre></td></tr></table></figure></p>
<h4 id="条款17：使用交换来修整过剩容量"><a href="#条款17：使用交换来修整过剩容量" class="headerlink" title="条款17：使用交换来修整过剩容量"></a>条款17：使用交换来修整过剩容量</h4><p>当使用容器时，插入数据可以使最大容量增加，但是当删除一部分元素时，多余的空间并不会自己归还给系统，需要手动收缩到合适的范围，一个做法是使用 <code>swap</code> 函数，构造一个与原始容器大小相同的临时容器，通过交换将元素填充到原始容器，互换而不会持有多余的空间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;Contestant&gt;(contestants).swap(contestants);</div></pre></td></tr></table></figure></p>
<p>在 <code>C++11</code> 后提供了一个函数来调整过剩的空间大小，<code>shrink_to_fit()</code> 将多余的空间归还给系统。  </p>
<h4 id="条款18：避免使用-vector-lt-bool-gt"><a href="#条款18：避免使用-vector-lt-bool-gt" class="headerlink" title="条款18：避免使用 vector&lt;bool&gt;"></a>条款18：避免使用 <code>vector&lt;bool&gt;</code></h4><p>它不是一个 STL 容器，不保存 bool 类型。<code>vector&lt;bool&gt;</code> 不满足STL容器的必要条件，你最好不要使用它；而<code>deque&lt;bool&gt;</code> 和 <code>bitset</code> 是基本能满足你对 <code>vector&lt;bool&gt;</code> 提供的性能的需要的替代数据结构。  </p>
<h4 id="条款19：了解相等和等价的区别"><a href="#条款19：了解相等和等价的区别" class="headerlink" title="条款19：了解相等和等价的区别"></a>条款19：了解相等和等价的区别</h4><p>在标准的关联容器中，如<code>set</code>当插入新的元素时，是用等价判断的，而不是相等，通过自定义的比较函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!c.key_comp()(x, y) &amp;&amp; !c.key_comp()(y, x) <span class="comment">// 在c的排序顺序中</span></div><div class="line"><span class="comment">// 如果x在y之前它非真，</span></div><div class="line"><span class="comment">// 同时在c的排序顺序中</span></div><div class="line"><span class="comment">// 如果y在x之前它非真</span></div></pre></td></tr></table></figure></p>
<p>使用等价作为比较的标准，可以避免使用排序和相等两个比较函数造成的问题。  </p>
<h4 id="条款20：为指针的关联容器指定比较类型"><a href="#条款20：为指针的关联容器指定比较类型" class="headerlink" title="条款20：为指针的关联容器指定比较类型"></a>条款20：为指针的关联容器指定比较类型</h4><p>使用一个 <code>string*</code> 类型的 <code>set</code> 容器的时候，其比较类型默认为比较容器中指针的大小，如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp; <span class="comment">// ssp = “set of string ptrs”</span></div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Anteater"</span>));</div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Wombat"</span>));</div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Lemur"</span>));</div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Penguin"</span>));</div><div class="line"></div><div class="line"><span class="comment">//可以使用以下自定义函数来按字符串的值比较大小，而不是只比较指针的大小</span></div><div class="line"><span class="keyword">struct</span> StringPtrLess: </div><div class="line"><span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> *ps1 &lt; *ps2;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="条款21：永远让比较函数对相等的值返回-false"><a href="#条款21：永远让比较函数对相等的值返回-false" class="headerlink" title="条款21：永远让比较函数对相等的值返回 false"></a>条款21：永远让比较函数对相等的值返回 false</h4><h4 id="条款22：避免原地修改-set-的键值"><a href="#条款22：避免原地修改-set-的键值" class="headerlink" title="条款22：避免原地修改 set 的键值"></a>条款22：避免原地修改 set 的键值</h4><p>set 容器需要保证元素的有序性，任何对于键值的修改都会改变这种有序性，简单来说不要改变容器中影响排序的键值。  </p>
<h4 id="条款23：考虑有序的-vector-替代关联容器"><a href="#条款23：考虑有序的-vector-替代关联容器" class="headerlink" title="条款23：考虑有序的 vector 替代关联容器"></a>条款23：考虑有序的 vector 替代关联容器</h4><h4 id="条款24：关乎效率的考虑"><a href="#条款24：关乎效率的考虑" class="headerlink" title="条款24：关乎效率的考虑"></a>条款24：关乎效率的考虑</h4><h4 id="条款25：熟悉非标准散列容器"><a href="#条款25：熟悉非标准散列容器" class="headerlink" title="条款25：熟悉非标准散列容器"></a>条款25：熟悉非标准散列容器</h4><h4 id="条款26：使用迭代器"><a href="#条款26：使用迭代器" class="headerlink" title="条款26：使用迭代器"></a>条款26：使用迭代器</h4><p>迭代器和常量迭代器之间的转换关系<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-10/12775061.jpg" alt=""><br>由图可以看出，迭代器可以隐式转换成常量迭代器，而常量迭代器却不可以转换成非常亮迭代器，一些容器的成员函数接收的是非常量迭代器，只能尽量使用非常量的迭代器。  </p>
<h4 id="条款27：常量迭代器转换成非常量迭代器"><a href="#条款27：常量迭代器转换成非常量迭代器" class="headerlink" title="条款27：常量迭代器转换成非常量迭代器"></a>条款27：常量迭代器转换成非常量迭代器</h4><p>使用 <code>distance</code> 和 <code>advance</code> 把 <code>const_iterator</code> 转换成 <code>iterator</code> 。为了在容器当前常量迭代器上插入一个元素，需要使其非常量化。通常的做法是，使用一个非常量的迭代器使其移动到常量迭代器的位置。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef deque&lt;int&gt; IntDeque; // 和以前一样</div><div class="line">typedef IntDeque::iterator Iter;        // 非常量迭代器</div><div class="line">typedef IntDeque::const_iterator ConstIter; // 常量迭代器</div><div class="line">IntDeque d;</div><div class="line">ConstIter ci;</div><div class="line">... // 让ci指向d</div><div class="line">Iter i(d.begin()); // 初始化i为d.begin()</div><div class="line">advance(i, distance(i, ci)); // 把i移到指向ci位置</div><div class="line">// （但请留意下面关于为什么</div><div class="line">// 在它编译前要调整的原因）</div></pre></td></tr></table></figure></p>
<h4 id="条款28：-base-迭代器之间的转换"><a href="#条款28：-base-迭代器之间的转换" class="headerlink" title="条款28： base 迭代器之间的转换"></a>条款28： <code>base</code> 迭代器之间的转换</h4><p><code>base</code> 可以将 <code>reverse_iterator</code> 转换成 <code>iterator</code>，其是如何实现这种转换的呢？  </p>
<h4 id="条款29：需要一个一个字符输入时考虑使用-istreambuf-iterator"><a href="#条款29：需要一个一个字符输入时考虑使用-istreambuf-iterator" class="headerlink" title="条款29：需要一个一个字符输入时考虑使用 istreambuf_iterator"></a>条款29：需要一个一个字符输入时考虑使用 <code>istreambuf_iterator</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第二章 &lt;code&gt;vector&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 和第三章的关联容器的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-1</title>
    <link href="http://abumaster.com/2018/04/06/%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8STL-1/"/>
    <id>http://abumaster.com/2018/04/06/高效实用STL-1/</id>
    <published>2018-04-06T07:53:39.000Z</published>
    <updated>2018-04-07T11:00:27.125Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第一章容器的介绍。</p>
</div>
<a id="more"></a>
<h4 id="条款1：小心选择容器"><a href="#条款1：小心选择容器" class="headerlink" title="条款1：小心选择容器"></a>条款1：小心选择容器</h4><p><strong>容器的分类：</strong>  </p>
<ul>
<li>标准STL序列容器：<code>vector</code>、<code>string</code>、<code>deque</code>和<code>list</code>。  </li>
<li>标准STL关联容器：<code>map</code>、<code>set</code>和<code>multiset</code>、<code>multimap</code>。  </li>
<li>非标准序列容器：<code>slist</code>和<code>rope</code>，单向链表和重型字符串。  </li>
<li>非标准关联容器：包括基于散列表的容器<code>hash_**</code>。  </li>
<li>标准非STL容器：数组、<code>bitset</code>、<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。  </li>
</ul>
<p>容器的选择可以考虑使用场景需要的算法的复杂度高低，如需要在容器的中间频繁插入删除元素，这时需要的容器可能是<code>list</code>，当需要在头尾插入删除元素，那么<code>deque</code>则是一个好的选择。<br>同时，也应该考虑到迭代器的能力，内存布局的兼容能力容器操作复杂度等等。  </p>
<h4 id="条款2：容器无关代码？"><a href="#条款2：容器无关代码？" class="headerlink" title="条款2：容器无关代码？"></a>条款2：容器无关代码？</h4><p>容器的使用真的与代码无关吗？考虑以下场景，<code>vector</code>和<code>list</code>在使用过程中，迭代器和内存布局是不一样的，因此，两个容器在使用过程中完全是不兼容的，许多方法是特有的，不能同时使用。当代码中的一个容器替换成另一个容器的时候，要考虑旧的代码对新的容器的适用性，保证不出现错误的使用，而导致编译错误。<br>一个比较方便的做法是使用 <code>typedef</code> 自定义迭代器类型。如代码不应这样写：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123;...&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</div><div class="line">Widget bestWidget;</div><div class="line"><span class="comment">// 给bestWidget一个值</span></div><div class="line"><span class="built_in">vector</span>&lt;Widget&gt;::iterator i = <span class="comment">// 寻找和bestWidget相等的Widget</span></div><div class="line">    find(vw.begin(), vw.end(), bestWidget);</div></pre></td></tr></table></figure></p>
<p>其中如果更换迭代器的话，需要查找所有的 <code>vector&lt;Widget&gt;</code> 然后改成新的容器，高效的写法是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123; ... &#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Widget&gt; WidgetContainer;         <span class="comment">//Widget类型的容器类型</span></div><div class="line"><span class="keyword">typedef</span> WidgetContainer::iterator WCIterator;   <span class="comment">//迭代器</span></div><div class="line">WidgetContainer cw;</div><div class="line">Widget bestWidget;</div><div class="line"><span class="comment">//</span></div><div class="line">WCIterator i = find(cw.begin(), cw.end(), bestWidget);</div></pre></td></tr></table></figure></p>
<p>这种做法，直接改 <code>typedef</code> 那两行就行。<br>如果不想用 <code>typedef</code> 将使用的容器暴露给用户，那么可以使用 <code>class</code> 将内部使用的容器私有化，只对用户提供统一的调用接口，当根据需求需要改变容器时，对用户代码不必进行过多的更改。  </p>
<h4 id="条款3：容器内对象的拷贝"><a href="#条款3：容器内对象的拷贝" class="headerlink" title="条款3：容器内对象的拷贝"></a>条款3：容器内对象的拷贝</h4><div class="note info"><p>主旨：使容器内对象拷贝操作的轻量而正确。</p>
</div>  
<p>一个好的做法是，将对象数组（容器）改为指针的数组（容器），毕竟指针的拷贝比对象的拷贝要快。</p>
<h4 id="条款4：用-empty-替换-size-0"><a href="#条款4：用-empty-替换-size-0" class="headerlink" title="条款4：用 empty 替换 size()==0"></a>条款4：用 <code>empty</code> 替换 <code>size()==0</code></h4><p>当判断一个容器中元素是否为空时，通常使用 <code>empty()</code> 它是常数时间的，而用 <code>size()==0</code> 来判断则是线性时间。  </p>
<h4 id="条款5：使用空间成员函数"><a href="#条款5：使用空间成员函数" class="headerlink" title="条款5：使用空间成员函数"></a>条款5：使用空间成员函数</h4><p>空间成员函数可以操作一个区间内的元素，而不是使用循环来对单个元素进行操作，具体的应用场景为，将容器内的元素用另一个容器中的元素替代，成段拷贝，区间赋值等等如。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( size_type count, <span class="keyword">const</span> T&amp; value )</span></span>;</div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( InputIt first, InputIt last )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; ilist )</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="条款6：C-的解析"><a href="#条款6：C-的解析" class="headerlink" title="条款6：C++的解析"></a>条款6：C++的解析</h4><blockquote>
<p>C++里面的一条通用规则，几乎任何东西都能被分析为函数声明  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123;...&#125;; <span class="comment">// 假设Widget有默认构造函数</span></div><div class="line"><span class="function">Widget <span class="title">w</span><span class="params">()</span></span>; <span class="comment">// 函数名w，返回一个Widget类型</span></div></pre></td></tr></table></figure>
<p>造成这种歧义出现的主要原因是，编译器无法知道你是调用构造还是函数声明，当有一个含有<code>int</code>类型的文件，需要从中读出放入<code>list</code>中，有如下代码：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.不正确的写法</span></div><div class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</div><div class="line"><span class="comment">//想用迭代器构造这个list，但实际上却是在声明一个函数</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile), istream_iterator&lt;<span class="keyword">int</span>&gt;());</div><div class="line"></div><div class="line"><span class="comment">//2.正确的写法</span></div><div class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</div><div class="line"><span class="comment">//定义两个迭代器</span></div><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; dataBegin(dataFile);</div><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; dataEnd;</div><div class="line"><span class="comment">//用迭代器初始化list</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(dataBegin, dataEnd);</div></pre></td></tr></table></figure></p>
<h4 id="条款7：销毁容器前记得释放动态申请的空间"><a href="#条款7：销毁容器前记得释放动态申请的空间" class="headerlink" title="条款7：销毁容器前记得释放动态申请的空间"></a>条款7：销毁容器前记得释放动态申请的空间</h4><p>当容器中保存着的是 <code>new</code> 申请到的动态对象时，当作用域失效后，容器自己的空间会由系统回收，但是动态申请的空间不会回收，这时需要手动回收空间。需要注意的是：手动释放以及异常处理。比较好的一种做法是使用智能指针，来智能管理内存空间。  </p>
<h4 id="条款8：永不建立-auto-ptr-的容器"><a href="#条款8：永不建立-auto-ptr-的容器" class="headerlink" title="条款8：永不建立 auto_ptr 的容器"></a>条款8：永不建立 <code>auto_ptr</code> 的容器</h4><p><code>auto_ptr</code> 的容器（COAPs）是被 <strong>禁止</strong> 的。  </p>
<h4 id="条款9：删除选项中仔细选择"><a href="#条款9：删除选项中仔细选择" class="headerlink" title="条款9：删除选项中仔细选择"></a>条款9：删除选项中仔细选择</h4><ul>
<li>去除一个容器中有特定值的所有对象：<br>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove</code>惯用法。
如果容器是<code>list</code>，使用<code>list::remove</code>。
如果容器是标准关联容器，使用它的<code>erase</code>成员函数。</li>
<li>去除一个容器中满足一个特定判定式的所有对象：<br>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove_if</code>惯用法。
如果容器是<code>list</code>，使用<code>list::remove_if</code>。
如果容器是标准关联容器，使用<code>remove_copy_if</code>和<code>swap</code>，或写一个循环来遍历容器元素，当你把迭代器传给<code>erase</code>时记得后置递增它。</li>
<li>在循环内做某些事情（除了删除对象之外）：<br>如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用<code>erase</code>时记得都用它的返回值更新你
的迭代器。
如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给<code>erase</code>时记得后置递增它。</li>
</ul>
<h4 id="条款10：注意分配器的协定和约束"><a href="#条款10：注意分配器的协定和约束" class="headerlink" title="条款10：注意分配器的协定和约束"></a>条款10：注意分配器的协定和约束</h4><h4 id="条款11：理解自定义分配器的正确用法"><a href="#条款11：理解自定义分配器的正确用法" class="headerlink" title="条款11：理解自定义分配器的正确用法"></a>条款11：理解自定义分配器的正确用法</h4><h4 id="条款12：STL容器线程安全性考虑"><a href="#条款12：STL容器线程安全性考虑" class="headerlink" title="条款12：STL容器线程安全性考虑"></a>条款12：STL容器线程安全性考虑</h4><p>多线程环境下对容器的操作如果没有特殊的处理是不安全的，不安全的处理应该包括以下方面：  </p>
<ul>
<li>保证多个线程读取容器内容时正确并且不能有写线程</li>
<li>多线程写时的互斥操作</li>
</ul>
<p>为了保证线程安全需要做的是通过 <strong>信号量</strong>、<strong>互斥锁</strong> 等线程同步原语，对容器的操作进行封装，常见的做法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//定义一个锁类，构造时加锁，析构时自动释放</div><div class="line">class Lock &#123; // 的类的模板核心；</div><div class="line">public: // 忽略了很多细节</div><div class="line">    Lock(const Containers container): c(container)</div><div class="line">    &#123;</div><div class="line">        getMutexFor(c); //在构造函数获取互斥量</div><div class="line">    &#125;</div><div class="line">    ~Lock()</div><div class="line">    &#123;</div><div class="line">        releaseMutexFor(c); //在析构函数里释放它</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    const Container&amp; c;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//使用</div><div class="line">vector&lt;int&gt; v;</div><div class="line">&#123; //建立新代码块；</div><div class="line">    Lock&lt;vector&lt;int&gt; &gt; lock(v); //获取互斥量</div><div class="line">    vector&lt;int&gt;::iterator first5(find(v.begin(), v.end(), 5));</div><div class="line">    if (first5 != v.end()) &#123;</div><div class="line">        *first5 = 0;</div><div class="line">    &#125;</div><div class="line">&#125; //离开作用域，自动释放锁</div></pre></td></tr></table></figure></p>
<p>这种做法的优势是可以保证加锁和释放锁是成对出现的，同时也可以保证异常出现时可以正确释放锁。因为是局部变量，当作用域消失时就会自动释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第一章容器的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>日志库easyloggingpp使用</title>
    <link href="http://abumaster.com/2018/03/28/%E6%97%A5%E5%BF%97%E5%BA%93easyloggingpp%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2018/03/28/日志库easyloggingpp使用/</id>
    <published>2018-03-28T12:59:03.000Z</published>
    <updated>2018-03-29T08:29:07.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://github.com/muflihun/easyloggingpp">easyloggingpp</a> 是一个只需引用一个头文件的 <code>C++</code> 日志库，它具有轻量高效、可扩展、线程安全、可嵌入到自己开发模块等等特性。  </p>
</blockquote>
<a id="more"></a>
<pre>
<a href="#下载使用">下载使用</a>
<a href="#自定义配置">自定义配置</a>
    <a href="#日志级别">日志级别</a>
    <a href="使用配置文件">使用配置文件</a>
<a href="记录日志">记录日志</a>
    <a href="基本操作">基本操作</a>
</pre>

<h3 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h3><p>从<a href="https://github.com/muflihun/easyloggingpp">easyloggingpp</a>下载最新的代码，通过 <code>CMake</code> 编译成独立的链接库，或者直接将 <code>easylogging++.h</code> 和 <code>easylogging++.cc</code> 源文件拷贝到自己的项目中，一起编译。官方示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"easylogging++.h"</span>              <span class="comment">//包含头文件</span></span></div><div class="line"></div><div class="line">INITIALIZE_EASYLOGGINGPP                <span class="comment">//用宏来表示初始化日志文件</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </div><div class="line"></span>&#123;</div><div class="line">   LOG(INFO) &lt;&lt; <span class="string">"My first info log using default logger"</span>;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后使用以下命令编译生成可执行文件，日志在控制台中显示，并且在项目目录下有日志文件生成。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ main.cc easylogging++.cc -o prog -std=c++11</div></pre></td></tr></table></figure></p>
<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>它最大的特性就是日志的高度可配置性，通过配置宏参数可以设置日志的级别和格式。以下列出了日志级别分类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Level</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Global</td>
<td style="text-align:left">通用日志级别，全局设置时使用</td>
</tr>
<tr>
<td style="text-align:left">Trace</td>
<td style="text-align:left">回溯某个特定事件的信息，比调试日志更有用</td>
</tr>
</tbody>
</table>
<p>Debug  | 开发过程中调试应用程序，调试开关要打开
Fatal  | 可能导致应用程序中断的非常严重的错误事件
Error   |  程序运行过程中的错误信息，程序继续运行
Warning |  程序运行过程中的错误信息
Info    |   应用程序当前的运行信息
Verbose |   处理冗长的日志信息
Unknown |   适用分层日志记录，完全关闭日志记录</p>
<h4 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##  log_conf.conf 配置文件</span></div><div class="line">* GLOBAL:</div><div class="line">    ENABLED                     = <span class="literal">true</span></div><div class="line">    TO_FILE                     = <span class="literal">true</span></div><div class="line">    TO_STANDARD_OUTPUT          = <span class="literal">true</span></div><div class="line">    FORMAT                      = <span class="string">"[%level | %datetime] | %msg"</span></div><div class="line">    FILENAME                    = <span class="string">"log\\log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line">    SUBSECOND_PRECISION         =  6</div><div class="line">    PERFORMANCE_TRACKING        =  <span class="literal">true</span></div><div class="line">    MAX_LOG_FILE_SIZE           =  2097152 <span class="comment">## 2MB - Comment starts with two hashe</span></div><div class="line">    LOG_FLUSH_THRESHOLD         =  100 <span class="comment">## Flush after every 100 logs</span></div><div class="line"></div><div class="line">* TRACE:</div><div class="line">    FILENAME                    =   <span class="string">"log\\trace_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* DEBUG:</div><div class="line">    FORMAT                      = <span class="string">"%datetime&#123;%d/%M&#125; %func %msg"</span></div><div class="line">    FILENAME                    = <span class="string">"log\\debug_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* FATAL:</div><div class="line">    ENABLED                     = <span class="literal">false</span></div><div class="line"></div><div class="line">* ERROR:</div><div class="line">    FILENAME                    = <span class="string">"log\\error_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* WARNING:</div><div class="line">    FILENAME                    = <span class="string">"log\\warning_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* INFO:</div><div class="line">    FILENAME                    = <span class="string">"log\\info_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line">    FORMAT                      = <span class="string">"[%host : %user] | %msg"</span></div><div class="line"></div><div class="line">* VERBOSE:</div><div class="line">    ENABLED                     = <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>通过构造日志记录器来加载配置文件完成对日志的自定义，使用：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"easylogging++.h"</span></span></div><div class="line"></div><div class="line"><span class="function">INITIALIZE_EASYLOGGINGPP</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">    <span class="comment">// 加载配置文件，构造一个配置器对象</span></div><div class="line">    el::<span class="function">Configurations <span class="title">conf</span><span class="params">(<span class="string">"/path/to/my-conf.conf"</span>)</span></span>;</div><div class="line">    <span class="comment">// 重新配置一个单一日志记录器</span></div><div class="line">    el::Loggers::reconfigureLogger(<span class="string">"default"</span>, conf);</div><div class="line">    <span class="comment">// 用配置文件配置所有的日志记录器</span></div><div class="line">    el::Loggers::reconfigureAllLoggers(conf);</div><div class="line">    <span class="comment">// 所有的日志记录器都是从文件中配置完成的，可以使用</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="日志格式说明符"><a href="#日志格式说明符" class="headerlink" title="日志格式说明符"></a>日志格式说明符</h4><p>日志的输出格式可以自定义，库中提供了一些说明符来表示不同的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>%logger</code></td>
<td style="text-align:left">loggger ID  </td>
</tr>
<tr>
<td style="text-align:left"><code>%thread</code></td>
<td style="text-align:left">thread ID</td>
</tr>
<tr>
<td style="text-align:left"><code>%thread_name</code></td>
<td style="text-align:left">用来获取线程的名称，是使用 <code>el::Helpers::setThreadName(&quot;name1&quot;)</code> 来设置的线程标识名</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%level</code></strong></td>
<td style="text-align:left">日志的级别，诸如 <code>DEBUG</code>、<code>INFO</code>、<code>WARNING</code>等</td>
</tr>
<tr>
<td style="text-align:left"><code>%levshort</code></td>
<td style="text-align:left">日志级别的缩写</td>
</tr>
<tr>
<td style="text-align:left"><code>%vlevel</code></td>
<td style="text-align:left">使用详细记录，冗长记录级别</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%datetime</code></strong></td>
<td style="text-align:left">当前的时间，可以自定义时间的格式</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%user</code></strong></td>
<td style="text-align:left">当前运行程序的用户名</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%host</code></strong></td>
<td style="text-align:left">运行程序的机器名称</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%file</code></strong></td>
<td style="text-align:left">源程序的名称，包含完整的路径信息</td>
</tr>
<tr>
<td style="text-align:left"><code>%fbase</code></td>
<td style="text-align:left">只有文件的名称</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%line</code></strong></td>
<td style="text-align:left">运行到此处的代码行</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%func</code></strong></td>
<td style="text-align:left">函数的名称</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%loc</code></strong></td>
<td style="text-align:left">函数的名称以及行号</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%msg</code></strong></td>
<td style="text-align:left">日志信息</td>
</tr>
<tr>
<td style="text-align:left"><em><code>%</code></em></td>
<td style="text-align:left">转义字符</td>
</tr>
</tbody>
</table>
<p><strong>日期的格式</strong><br>通过上述的符号 <code>%datetime</code> 获取了时间，可以通过自定义的方式来格式化时间，常用的格式符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>%d</code></td>
<td style="text-align:left">一月中的几号</td>
</tr>
<tr>
<td style="text-align:left"><code>%a</code></td>
<td style="text-align:left">简写的星期几</td>
</tr>
<tr>
<td style="text-align:left"><code>%A</code></td>
<td style="text-align:left">全称星期几</td>
</tr>
<tr>
<td style="text-align:left"><code>%Y %M %d %H %m %s</code></td>
<td style="text-align:left">年月日时分秒</td>
</tr>
</tbody>
</table>
<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>有两种方式来记录日志
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOG(LEVEL) &lt;&lt; <span class="string">"info"</span>;               <span class="comment">//第一种：使用默认的日志记录器</span></div><div class="line">CLOG(LEVEL, logger ID) &lt;&lt; <span class="string">"info"</span>;   <span class="comment">//第二种：指定特定的日志记录器，可以自己注册</span></div></pre></td></tr></table></figure></p>
<p>库中注册的有三种：</p>
<ul>
<li>默认的日志记录器 ID: <code>dfault</code> ；</li>
<li>性能日志记录器 ID: <code>performance</code> ；</li>
<li>系统日志记录器 ID: <code>syslog</code>
可以使用以下方式注册自己的日志记录器：<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册一个ID为business的日志记录器，没有会自动创建</span></div><div class="line">el::Logger* businessLogger = el::Loggers::getLogger(<span class="string">"business"</span>);</div><div class="line"><span class="comment">//businessLogger -&gt;</span></div><div class="line"><span class="comment">//info(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//warn(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//error(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//debug(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//fatal(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//trace(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//verbose(int vlevel, const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//来记录日志 可以使用 %v 来格式化数据</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="条件日志记录"><a href="#条件日志记录" class="headerlink" title="条件日志记录"></a>条件日志记录</h4><p>满足条件后，开始记录日志，不满足条件不会记录，使用如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOG_IF(condition, LEVEL)</div><div class="line">CLOG_IF(condition, LEVEL, logger ID)</div></pre></td></tr></table></figure></p>
<h4 id="记录特定次数日志"><a href="#记录特定次数日志" class="headerlink" title="记录特定次数日志"></a>记录特定次数日志</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LOG_EVERY_N(n, LEVEL)</div><div class="line">CLOG_EVERY_N(n, LEVEL, logger ID)</div><div class="line"></div><div class="line">LOG_AFTER_N(n, LEVEL); <span class="comment">//Only logs when we have reached hit counts of n</span></div><div class="line">LOG_N_TIMES(n, LEVEL); <span class="comment">//Logs n times</span></div></pre></td></tr></table></figure>
<p>源文件 <code>sample</code> 下有使用示例。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/muflihun/easyloggingpp&quot;&gt;easyloggingpp&lt;/a&gt; 是一个只需引用一个头文件的 &lt;code&gt;C++&lt;/code&gt; 日志库，它具有轻量高效、可扩展、线程安全、可嵌入到自己开发模块等等特性。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="日志库" scheme="http://abumaster.com/tags/%E6%97%A5%E5%BF%97%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>cpr阅读笔记</title>
    <link href="http://abumaster.com/2018/03/18/cpr%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2018/03/18/cpr阅读笔记/</id>
    <published>2018-03-18T13:15:22.000Z</published>
    <updated>2018-03-24T08:18:10.224Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://github.com/whoshuu/cpr">C++ Request: Curl for prople request</a></strong> 是一个将<a href="https://github.com/curl/curl">curl</a>用 C++11 标准封装过之后的版本，使得发送网络请求更加方便，本文对源码阅读到库的编译使用做一个详细的总结，对一些 C++ 11 的新标准做一个回顾。  </p>
<a id="more"></a>
<h3 id="cpr-源码结构和安装"><a href="#cpr-源码结构和安装" class="headerlink" title="cpr 源码结构和安装"></a>cpr 源码结构和安装</h3><p><strong>cpr源码结构：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-3-20/58201427.jpg" alt="">  </p>
<ul>
<li>cpr中是cpp文件；  </li>
<li><code>include</code> 下是头文件，用到此库需要包含的；  </li>
<li><code>opt</code> 中使用的是第三方库，包括了 <code>curl</code> ，用于测试的 <code>googletest</code> 以及web服务端程序；  </li>
<li><code>test</code> 中包含了单元测试文件  </li>
</ul>
<p><strong>编译安装</strong><br>使用 <code>cmake</code> 源码安装，首先下载 <code>opt</code> 下的第三方依赖库到指定目录。然后，在<code>cpr</code>根目录下新建文件夹 <code>build</code> 输入一下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> build</div><div class="line">cmake ..</div><div class="line"><span class="comment"># 等待cmake完成后</span></div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">make        <span class="comment"># 构建项目</span></div><div class="line">make <span class="built_in">test</span>   <span class="comment"># 进行测试</span></div></pre></td></tr></table></figure></p>
<p>一切完成后，在 <code>build</code> 目录下生成了 <code>lib</code> 库。  </p>
<h3 id="cpp-的知识备忘"><a href="#cpp-的知识备忘" class="headerlink" title="cpp 的知识备忘"></a>cpp 的知识备忘</h3><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><code>initializer_list</code> 初始化的列表，C++ 11中添加的用于列表初始化的模板类型，列表初始化如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//定义并初始化</span></div><div class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;   <span class="comment">//列表初始化</span></div><div class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;<span class="comment">//列表初始化</span></div></pre></td></tr></table></figure></p>
<p><code>initializer_list</code> 的出现丰富了这种列表初始化的应用范围，可以使用如下构造函数来构造初始化列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst;                <span class="comment">//默认初始化；T类型元素的空列表</span></div><div class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst&#123;a,b,c...&#125;;      <span class="comment">//</span></div><div class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst = &#123;a,b,c...&#125;;   <span class="comment">//</span></div><div class="line">lst2(lst1);</div></pre></td></tr></table></figure></p>
<p>注意在初始化列表中其元素是一个常量，无法更改和插入。拷贝和赋值的时候只会发生引用，而不会复制元素。<br>例子：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//自定义结构体，支持使用列表初始化</span></div><div class="line"><span class="comment">//1.template class</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> MyS &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;T&gt; vec_;</div><div class="line">    MyS(<span class="built_in">initializer_list</span>&lt;T&gt; lst) :vec_(lst)&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"initializer with "</span> &lt;&lt; lst.size() &lt;&lt; <span class="string">" elements\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">initializer_list</span>&lt;T&gt; lst)</span></div><div class="line">    </span>&#123;</div><div class="line">        vec_.insert(vec_.end(), lst.begin(), lst.end());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">    &#125;</div><div class="line">    pair&lt;T*, <span class="keyword">size_t</span>&gt; c_arr() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>&#123; &amp;vec_[<span class="number">0</span>], vec_.size() &#125;;<span class="comment">//返回初始化列表的一个副本</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">//2.template function</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">template_fn</span><span class="params">(T)</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    MyS&lt;<span class="keyword">int</span>&gt; S = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;<span class="comment">//列表初始化</span></div><div class="line">    S.print();</div><div class="line">    S.append(&#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;);<span class="comment">//初始化列表添加元素</span></div><div class="line">    S.print();</div><div class="line">    <span class="comment">//template_fn(&#123; 1, 2, 3, 4 &#125;);//无法推导出正确的类型</span></div><div class="line">    template_fn&lt;<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;);</div><div class="line">    template_fn&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</div><div class="line">    </div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="左值和右值-分发"><a href="#左值和右值-分发" class="headerlink" title="左值和右值 分发"></a>左值和右值 分发</h4><p><strong>左值：</strong>是即能放在等号的左边又能放在等号的右边，是在内存中有实体的存在，占有内存空间；<br><strong>右值：</strong>是只能放在等号的右边，不能被赋值，只是一个临时变量，存放在寄存器中，没有分配存储空间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;      <span class="comment">//a是左值</span></div><div class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">//a+1是右值</span></div></pre></td></tr></table></figure></p>
<p><strong>左值引用</strong> 使用 <code>Type &amp;左值引用名 = 左值表达式;</code> 是左值的一个别名，本质是一个指针；<br><strong>右值引用</strong>  用法 <code>Type &amp;&amp;右值引用名 = 右值表达式;</code> 由于右值在内存中没有具体的内存空间，所以不能复制给左值引用，使用右值引用，如在函数的声明过程中
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;&#125;<span class="comment">//函数</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">function(i+<span class="number">1</span>);          <span class="comment">//会出现错误</span></div><div class="line"><span class="comment">//可以将函数的定义改为：</span></div><div class="line"><span class="comment">//1 void function(const int &amp;a)&#123;&#125;   常量引用</span></div><div class="line"><span class="comment">//2 void function(int &amp;&amp;a)&#123;&#125;        右值引用</span></div><div class="line"><span class="comment">//也可以在调用前使用 int &amp;&amp;rval = move(a+1); 将其变为右值引用</span></div></pre></td></tr></table></figure></p>
<p><strong>所谓的 <code>forward</code> 完美转发</strong><br>根据类型T是左值或者右值来转发，在右值引用作为函数的形参的时候，在函数内部，右值引用变为了左值引用，无法保留原始的类型，所以需要使用 <code>forward</code> 来完美转发。原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">// arg is always lvalue</span></div><div class="line">    foo(<span class="built_in">std</span>::forward&lt;T&gt;(arg)); <span class="comment">// Forward as lvalue or as rvalue, depending on T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常要将原始的类型转发参数。如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">//重载了两个函数，分别以左值引用和右值引用作为参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> &amp;&amp;a)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> A&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">(A &amp;&amp;a)</span> </span>&#123;               <span class="comment">//使用G函数转发参数</span></div><div class="line">    <span class="comment">//return F(std::forward&lt;A&gt;(a));     //1 完美转发</span></div><div class="line">    <span class="keyword">return</span> F(a);                        <span class="comment">//2 将a作为了左值转发</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">    G(i);</div><div class="line">    G(<span class="number">1</span>);</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/whoshuu/cpr&quot;&gt;C++ Request: Curl for prople request&lt;/a&gt;&lt;/strong&gt; 是一个将&lt;a href=&quot;https://github.com/curl/curl&quot;&gt;curl&lt;/a&gt;用 C++11 标准封装过之后的版本，使得发送网络请求更加方便，本文对源码阅读到库的编译使用做一个详细的总结，对一些 C++ 11 的新标准做一个回顾。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用笔记</title>
    <link href="http://abumaster.com/2018/03/08/Git-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2018/03/08/Git-使用笔记/</id>
    <published>2018-03-08T11:31:17.000Z</published>
    <updated>2018-03-28T08:55:43.789Z</updated>
    
    <content type="html"><![CDATA[<p>Git 使用简单总结。
<a id="more"></a></p>
<h4 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h4><p>代码库中有一个主分支 <code>master</code> ，用于保存稳定的版本，自动随仓库建立的，默认在此分支上开发。日常的开发要在一个开发分支上进行，不直接修改 <code>master</code> 分支，需要更新时向主分支合并开发分支。<br>Git创建开发分支 <code>devvelop</code> 的命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取 master 的最新代码</span></div><div class="line">git checkout master</div><div class="line">git pull</div><div class="line"><span class="comment"># 为 master 创建一个名为 develop 的分支</span></div><div class="line">git checkout -b develop master</div></pre></td></tr></table></figure></p>
<h4 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h4><p>分支在修改后，需要提交到本地仓库，和远程仓库中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将修改的文件加入</span></div><div class="line">git add .</div><div class="line"><span class="comment"># 查看文件变化状态</span></div><div class="line">git status</div><div class="line"><span class="comment"># 提交修改</span></div><div class="line">git commit -m<span class="string">'message'</span></div></pre></td></tr></table></figure></p>
<h4 id="第三步：与主分支保持一致"><a href="#第三步：与主分支保持一致" class="headerlink" title="第三步：与主分支保持一致"></a>第三步：与主分支保持一致</h4><p>开发过程中需要与主分支的代码保持一致，命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git rebase origin/master</div></pre></td></tr></table></figure></p>
<h4 id="第四步：合并到-master分支"><a href="#第四步：合并到-master分支" class="headerlink" title="第四步：合并到 master分支"></a>第四步：合并到 master分支</h4><p>当 <code>develop</code> 分支测试没有问题后，合并到 <code>master</code> 中，命令：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先切换到 master 分支中</span></div><div class="line">git checkout master</div><div class="line"><span class="comment"># 对 develop 分支进行合并</span></div><div class="line">git merge --no-ff develop</div></pre></td></tr></table></figure></p>
<p>合并的参数 <code>--no-ff</code> 是在 <code>master</code> 分支中生成一个新节点，将 <code>develop</code> 分支连接到前一个节点和新生成的节点之间。  </p>
<h4 id="第五步：-推送到远程仓库"><a href="#第五步：-推送到远程仓库" class="headerlink" title="第五步： 推送到远程仓库"></a>第五步： 推送到远程仓库</h4><p><strong>两种情况：</strong><br><strong>自己的仓库：</strong>如果在<code>master</code>分支上合并开发分支后，可以直接推送<code>master</code>到远程仓库中，命令如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --force origin master</div></pre></td></tr></table></figure></p>
<p><strong>fork的别人的仓库：</strong>在 <code>develop</code> 分支上进行修改后，没有在 <code>master</code> 上进行合并，需要向主分支提交一个新的分支，表明自己的修改状况，向主分支发送合并的请求，命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --force origin develop-myfeature</div></pre></td></tr></table></figure></p>
<p>提交代码到远程仓库中后，发起 <code>Pull Request</code> 到 <code>master</code> ，请求别人确认合并到 <code>master</code>。  </p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">参考链接</a></p>
<h4 id="fork的代码如何与源保持一致"><a href="#fork的代码如何与源保持一致" class="headerlink" title="fork的代码如何与源保持一致"></a>fork的代码如何与源保持一致</h4><p>从别人仓库中 <code>forke</code> 的一个项目并 <code>clone</code> 到本地进行开发，当源仓库的代码发生更新时，也需要用到最新的代码，一个思路是从源仓库拉取最新的代码到本地，然后合并本地仓库，最后推送到远程自己的仓库中。  </p>
<ul>
<li>首先，创建一个远程仓库，指定源仓库所在的地址，语法为 <code>git remote add [shotname] [url]</code>，可以使用 <code>git remote -v</code> 查看远程仓库的信息，一般会有一个 <code>fetch</code> 和 <code>push</code> 匹配，分别用于取代码和推送代码；  </li>
<li>然后从远程仓库抓取数据，<code>git fetch [remote-name]</code> ，<code>fetch</code> 相当于从远程仓库中 <code>pull</code> 了最新的代码并 <code>merge</code> 到当前本地仓库；  </li>
<li>再切换到本地的<code>master</code>分支，并将这个远程仓库的本地仓库与主分支合并，<code>git merge [remote-name/origin] master</code> ，这时可能主仓库的代码更改与本地仓库的更改冲突，需要解决<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000">合并冲突</a>。按照提示解决冲突文件重新提交即可。  </li>
<li>推送到远程仓库，与源仓库的代码保持一致 <code>git push [remote-name] [branch-name]</code> 。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 使用简单总结。
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Git" scheme="http://abumaster.com/tags/Git/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 Caffe 深度学习框架</title>
    <link href="http://abumaster.com/2017/11/17/Ubuntu%E5%AE%89%E8%A3%85caffe/"/>
    <id>http://abumaster.com/2017/11/17/Ubuntu安装caffe/</id>
    <published>2017-11-17T03:03:02.000Z</published>
    <updated>2018-01-30T07:00:16.126Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>详细介绍了Ubuntu系统下安装caffe深度学习框架的过程。</p>
</blockquote>
<a id="more"></a>
<h2 id="Ubuntu14-04-Caffe-CPU版"><a href="#Ubuntu14-04-Caffe-CPU版" class="headerlink" title="Ubuntu14.04 + Caffe CPU版"></a>Ubuntu14.04 + Caffe CPU版</h2><p><strong>1.安装依赖项</strong><br>包括了Caffe使用的第三方库
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler  </div><div class="line">sudo apt-get install --no-install-recommends libboost-all-dev</div><div class="line">sudo apt-get install libatlas-base-dev</div></pre></td></tr></table></figure></p>
<p><strong>2.安装python环境</strong><br>使用<a href="https://www.anaconda.com/download/">Anaconda</a>集成的python环境，其中打包了python的很多包，用conda管理python包是一个很好的选择。 </p>
<p><strong>3.安装OpenCV</strong>  </p>
<ul>
<li><p><a href="https://github.com/jayrambhia/Install-OpenCV">从网上下载安装脚本</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/jayrambhia/Install-OpenCV</div></pre></td></tr></table></figure>
</li>
<li><p>进入其中的 <code>Ubuntu</code> 目录下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo sh ./dependencies.sh</div><div class="line">cd 2.4</div><div class="line">sudo sh opencv2_4_10.sh</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong>虚拟机环境下CPU核数的限制会发生卡顿死机，要将 <code>opencv_2_4_10.sh</code> 中的一条命令 <code>make -j</code> 改为 <code>make</code> 即可。  </p>
<p><strong>4.caffe的配置</strong></p>
<ul>
<li>从<a href="https://github.com/BVLC/caffe.git">github</a>上下载caffe源码；</li>
<li><p>拷贝根目录下的 <code>config</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp Makefile.config.example Makefile.config</div></pre></td></tr></table></figure>
</li>
<li><p>配置其中的信息，使用cpu，注释掉 cuda的目录等，主要注意如果使用python层，要配置python的相关路径，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">## Refer to http://caffe.berkeleyvision.org/installation.html</div><div class="line"># Contributions simplifying and improving our build system are welcome!</div><div class="line"></div><div class="line"># cuDNN acceleration switch (uncomment to build with cuDNN).</div><div class="line"># USE_CUDNN := 1</div><div class="line"></div><div class="line"># CPU-only switch (uncomment to build without GPU support).</div><div class="line">CPU_ONLY := 1</div><div class="line"></div><div class="line"># To customize your choice of compiler, uncomment and set the following.</div><div class="line"># N.B. the default for Linux is g++ and the default for OSX is clang++</div><div class="line"># CUSTOM_CXX := g++</div><div class="line"></div><div class="line"># CUDA directory contains bin/ and lib/ directories that we need.</div><div class="line"># CUDA_DIR := /usr/local/cuda</div><div class="line"># On Ubuntu 14.04, if cuda tools are installed via</div><div class="line"># "sudo apt-get install nvidia-cuda-toolkit" then use this instead:</div><div class="line"># CUDA_DIR := /usr</div><div class="line"></div><div class="line"># CUDA architecture setting: going with all of them.</div><div class="line"># For CUDA &lt; 6.0, comment the *_50 lines for compatibility.</div><div class="line">#CUDA_ARCH := -gencode arch=compute_20,code=sm_20 \</div><div class="line">#       -gencode arch=compute_20,code=sm_21 \</div><div class="line">#       -gencode arch=compute_30,code=sm_30 \</div><div class="line">#       -gencode arch=compute_35,code=sm_35 \</div><div class="line">#       -gencode arch=compute_50,code=sm_50 \</div><div class="line">#       -gencode arch=compute_50,code=compute_50</div><div class="line">#</div><div class="line"># BLAS choice:</div><div class="line"># atlas for ATLAS (default)</div><div class="line"># mkl for MKL</div><div class="line"># open for OpenBlas</div><div class="line">BLAS := atlas</div><div class="line"># Custom (MKL/ATLAS/OpenBLAS) include and lib directories.</div><div class="line"># Leave commented to accept the defaults for your choice of BLAS</div><div class="line"># (which should work)!</div><div class="line"># BLAS_INCLUDE := /path/to/your/blas</div><div class="line"># BLAS_LIB := /path/to/your/blas</div><div class="line"></div><div class="line"># Homebrew puts openblas in a directory that is not on the standard search path</div><div class="line"># BLAS_INCLUDE := $(shell brew --prefix openblas)/include</div><div class="line"># BLAS_LIB := $(shell brew --prefix openblas)/lib</div><div class="line"></div><div class="line"># This is required only if you will compile the matlab interface.</div><div class="line"># MATLAB directory should contain the mex binary in /bin.</div><div class="line"># MATLAB_DIR := /usr/local</div><div class="line"># MATLAB_DIR := /Applications/MATLAB_R2012b.app</div><div class="line"></div><div class="line"># NOTE: this is required only if you will compile the python interface.</div><div class="line"># We need to be able to find Python.h and numpy/arrayobject.h.</div><div class="line">#PYTHON_INCLUDE := /usr/include/python2.7 \</div><div class="line">#       /usr/lib/python2.7/dist-packages/numpy/core/include</div><div class="line"># Anaconda Python distribution is quite popular. Include path:</div><div class="line"># Verify anaconda location, sometimes it's in root.</div><div class="line"> ANACONDA_HOME := $(HOME)/anaconda2</div><div class="line"> PYTHON_INCLUDE := $(ANACONDA_HOME)/include \</div><div class="line">         $(ANACONDA_HOME)/include/python2.7 \</div><div class="line">         $(ANACONDA_HOME)/lib/python2.7/site-packages/numpy/core/include \</div><div class="line"></div><div class="line"># We need to be able to find libpythonX.X.so or .dylib.</div><div class="line"># PYTHON_LIB := /usr/lib</div><div class="line"> PYTHON_LIB := $(ANACONDA_HOME)/lib</div><div class="line"></div><div class="line"># Homebrew installs numpy in a non standard path (keg only)</div><div class="line"># PYTHON_INCLUDE += $(dir $(shell python -c 'import numpy.core; print(numpy.core.__file__)'))/include</div><div class="line"># PYTHON_LIB += $(shell brew --prefix numpy)/lib</div><div class="line"></div><div class="line"># Uncomment to support layers written in Python (will link against Python libs)</div><div class="line">WITH_PYTHON_LAYER := 1</div><div class="line"></div><div class="line"># Whatever else you find you need goes here.</div><div class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include</div><div class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib</div><div class="line"></div><div class="line"># If Homebrew is installed at a non standard location (for example your home directory) and you use it for general dependencies</div><div class="line"># INCLUDE_DIRS += $(shell brew --prefix)/include</div><div class="line"># LIBRARY_DIRS += $(shell brew --prefix)/lib</div><div class="line"></div><div class="line"># Uncomment to use `pkg-config` to specify OpenCV library paths.</div><div class="line"># (Usually not necessary -- OpenCV libraries are normally installed in one of the above $LIBRARY_DIRS.)</div><div class="line"># USE_PKG_CONFIG := 1</div><div class="line"></div><div class="line">BUILD_DIR := build</div><div class="line">DISTRIBUTE_DIR := distribute</div><div class="line"></div><div class="line"># Uncomment for debugging. Does not work on OSX due to https://github.com/BVLC/caffe/issues/171</div><div class="line"># DEBUG := 1</div><div class="line"></div><div class="line"># The ID of the GPU that 'make runtest' will use to run unit tests.</div><div class="line">#TEST_GPUID := 0</div><div class="line"></div><div class="line"># enable pretty build (comment to see full commands)</div><div class="line">Q ?= @</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>5.安装caffe</strong><br>编译安装caffe
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">make all   </div><div class="line">make test  </div><div class="line">make runtest  </div><div class="line">make pycaffe</div></pre></td></tr></table></figure></p>
<h3 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h3><ul>
<li><p><code>Cannot build caffe with anaconda. Error: while loading shared libraries: libhdf5_hl.so.10</code> 不能找到hdf5链接库，由于使用的是Anaconda发行版的python，所以要将其链接库目录加入到链接库中，具体命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&#123;anaconda_dir&#125;/lib</div><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p>使用python接口是出错提示没有protobuf模块，解决方法，使用<code>conda install protobuf</code>安装最新的protobuf python模块，<code>exportPYTHONPATH=/home/zero/Documents/caffe-master/python:$PYTHONPATH</code>。</p>
</li>
</ul>
<h2 id="Ubuntu14-04-Caffe-GPU版"><a href="#Ubuntu14-04-Caffe-GPU版" class="headerlink" title="Ubuntu14.04 + Caffe GPU版"></a>Ubuntu14.04 + Caffe GPU版</h2><p><a href="http://blog.csdn.net/ubunfans/article/details/47724341">参考</a><br><strong>1.安装GPU驱动程序和工具包</strong><br>驱动程序也可以在安装CUDA过程中安装，NVIDIA官网注册下载CUDAV8.0或者CUDA7.5工具包，安装。再下载cudnn v5.0，一般这个版本比较主流不会在安装一些变种caffe版本时出错。<br><strong>2.安装cudnn</strong><br>下载过，解压，将头文件放入到指定文件夹下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar -zxvf cudnn-7.5-linux-x64-v5.0-ga.tgz  </div><div class="line">cd cuda  </div><div class="line">sudo cp lib/lib* /usr/local/cuda/lib64/  </div><div class="line">sudo cp include/cudnn.h /usr/local/cuda/include/</div></pre></td></tr></table></figure></p>
<p>更新链接信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/cuda/lib64/</div><div class="line">sudo chmod +r libcudnn.so.5.0.5</div><div class="line">sudo ln -sf libcudnn.so.5.0.5 libcudnn.so.5</div><div class="line">sudo ln -sf libcudnn.so.5 libcudnn.so</div><div class="line">sudo ldconfig</div></pre></td></tr></table></figure></p>
<p>添加cuda环境变量
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/profile</div><div class="line">PATH = /usr/local/cuda/bin:$PATH</div><div class="line">export PATH</div><div class="line">source /etc/profile #使环境变量生效</div></pre></td></tr></table></figure></p>
<p>添加lib库路径,在 <code>/etc/ld.so.conf.d/</code> 加入文件 <code>cuda.conf</code>，内容为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/local/cuda/lib64  </div><div class="line">sudo ldconfig #使路径生效</div></pre></td></tr></table></figure></p>
<p>接下来的caffe安装与CPU版本一样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;详细介绍了Ubuntu系统下安装caffe深度学习框架的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
  </entry>
  
  <entry>
    <title>ACE学习笔记4：任务和主动对象</title>
    <link href="http://abumaster.com/2017/11/17/ACE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%B8%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1/"/>
    <id>http://abumaster.com/2017/11/17/ACE学习笔记4：任务和主动对象/</id>
    <published>2017-11-17T03:03:02.000Z</published>
    <updated>2017-11-27T13:09:10.186Z</updated>
    
    <content type="html"><![CDATA[<p>主动对象区别于被动对象，被动对象的方法代码是在调用线程中执行的。主动对象持有自己的线程用于执行自己的方法。在对象中封装一个或一组线程的对象，称为 <em>主动对象</em>。  任务。  </p>
<a id="more"></a>
<h4 id="任务的简单使用"><a href="#任务的简单使用" class="headerlink" title="任务的简单使用"></a>任务的简单使用</h4><p>要创建任务和主动对象，要从 <code>ACE_Task</code> 中派生一个任务子类，然后必须进行以下的工作：  </p>
<ul>
<li><strong>实现初始化和终止方法</strong>：<code>open()</code> 方法实现专属任务的初始化代码，连接控制块、锁以及内存资源，<code>close()</code> 则是终止方法；  </li>
<li><strong>调用启动方法</strong>：主动对象实例化必须调用 <code>activate()</code> 方法，要在主动对象中创建的线程数目及其他的一些信息作为参数传递给此函数；  </li>
<li><strong>实现任务专有的处理方法</strong>：主动对象启动后，各个线程在 <code>svc()</code> 中启动，必须定义此方法。  </li>
</ul>
<p><strong>任务间的通信</strong>  每个任务底层都有一个消息队列，通常被用作任务间进行通信的一种方式。当一个任务想要与其他任务进行通信的时候会将消息放入与之谈话的消息队列中，通过调用 <code>getq()</code> 函数来获取消息，没有消息则进行睡眠，有消息到达时会自动唤醒并处理此消息。<br>使用：假设任务A和任务B之间通信，<code>A-&gt;B</code> 发送消息。首先，定义一个 <code>ACE_Message_Block</code> 类型的消息块<code>*mb</code>，可以是单一的类型，也可以是数据结构，然后，在A中通过调用 <code>B-&gt;putq(mb)</code> 向底层消息管道中压入一个消息快；然后B中用 <code>getq(mb)</code> 获取消息队列中的消息。实现两个任务之间的通信。  </p>
<h4 id="主动对象"><a href="#主动对象" class="headerlink" title="主动对象"></a>主动对象</h4><blockquote>
<p>主动对象模式用于降低方法执行和方法调用之间的耦合。该模式描述了另外一种更为透明的任务间通信方法。<br>传统上，所有的对象都是被动的代码段，对象中的代码是在对它发出方法调用的线程中执行的，当方法被调用时，调用线程将阻塞，直至调用结束。而主动对象却不一样。这些对象具有自己的命令执行线程，主动对象的方法将在自己的执行线程中执行，不会阻塞调用方法。</p>
</blockquote>
<p><strong>ACE主动对象模式实现至少涉及3个类模块:</strong>  </p>
<ul>
<li>提供多线程池 <code>ACE_Task_Base</code> 或者 <code>ACE_Task</code> 或者 <code>ACE_Thread_Manager</code> ；  </li>
<li>提供请求排队的 <code>ACE_Activation_Queue</code>，其内部维护了 <code>ACE_Message_Queue</code> 的 <code>message_block</code> 消息指针队列；  </li>
<li>提供了 <code>ACE_Activation_Queue</code> 队列操作实例的 <code>ACE_Method_Request</code> ，<code>ACE_Method_Request</code>是command模式，最低消耗仅为实现其内部的call方法。  </li>
</ul>
<p><strong>ACE主动对象实现需要依赖以上3个模块，至少构建2个类:</strong></p>
<ul>
<li>分发器，负责将请求参数排队，并提供数个执行线程。</li>
<li>分发对象。请求队列的排队实例。</li>
</ul>
<p><a href="https://www.cnblogs.com/TianFang/archive/2006/12/11/589168.html">ACE 主动对象参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主动对象区别于被动对象，被动对象的方法代码是在调用线程中执行的。主动对象持有自己的线程用于执行自己的方法。在对象中封装一个或一组线程的对象，称为 &lt;em&gt;主动对象&lt;/em&gt;。  任务。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="ACE" scheme="http://abumaster.com/tags/ACE/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ACE学习笔记3：线程管理</title>
    <link href="http://abumaster.com/2017/11/07/ACE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://abumaster.com/2017/11/07/ACE学习笔记3：线程管理/</id>
    <published>2017-11-07T05:20:10.000Z</published>
    <updated>2017-11-10T06:55:19.590Z</updated>
    
    <content type="html"><![CDATA[<p>不同平台下，有着若干不同的线程管理接口，提供了近乎相同的功能，但是API却相差很大，而 <code>ACE_Thread</code> 提供了对不同平台API接口的封装，可以在不同的平台下创建，挂起，销毁线程，做到平台无关性，另外还提供了一套同步和管理机制。  </p>
<a id="more"></a>
<h4 id="创建和取消线程"><a href="#创建和取消线程" class="headerlink" title="创建和取消线程"></a>创建和取消线程</h4><p>ACE_Thread 对 OS 的线程函数进行简单的封装，提供了一组与平台无关的接口。<br>头文件：<code>ace/Thread.h</code><br>线程标识：<code>ACE_thread_t</code>，线程句柄：<code>ACE_hthread_t</code><br>提供的函数：<code>ACE_Thread::spawn_n</code> 或 <code>ACE_Thread::spawn</code> 可以用 <code>ACE_Thread::join()</code> 函数等待线程的结束<br>与普通的创建线程过程无异。  </p>
<h4 id="ACE-同步原语"><a href="#ACE-同步原语" class="headerlink" title="ACE 同步原语"></a>ACE 同步原语</h4><h5 id="ACE-Lock-类属"><a href="#ACE-Lock-类属" class="headerlink" title="ACE Lock 类属"></a>ACE Lock 类属</h5><p>其中包含了一些锁类机制：互斥锁、信号量、读写锁、令牌。<br><code>ACE_Mutex</code> 封装互斥机制的包装类，用于简单有效地对共享资源访问的序列化，可用于线程和进程之间的同步。<br><code>ACE_Thread_Mutex</code> 和 <code>ACE_Process_Mutex</code> 用于线程和进程之间同步，可以替换。<br><code>ACE_RW_Mutex</code> 封装读写的包装类，分别对读写获取锁。<br><code>ACE_Semaphore</code> 实现计数信号量。<br><code>ACE_Token</code> 提供递归互斥体，一个获取锁的，可以多次获取不发生阻塞。<br><code>ACE_Lock</code> 定义锁定接口的接口类，是一个纯虚类。<br><code>ACE_Lock_Adapter</code> 基于模板的适配类，用于将前面的锁类型适配到纯虚类上。  </p>
<h5 id="ACE-守卫类属"><a href="#ACE-守卫类属" class="headerlink" title="ACE 守卫类属"></a>ACE 守卫类属</h5><p>用于自动获取和释放锁，守卫类的对象定义一个代码块，进入时获取，退出时释放。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arguments)</span></div><div class="line"></span>&#123;</div><div class="line">    Args *arg = (Args*)arguments;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arg-&gt;iterations_; ++i)</div><div class="line">    &#123;</div><div class="line">        ACE_DEBUG((LM_DEBUG, <span class="string">"(%t) trying to get a hold of this iteration\n"</span>));</div><div class="line">        <span class="comment">//关键段</span></div><div class="line">        ACE_Guard&lt;ACE_Thread_Mutex&gt; quard(arg-&gt;mutex_);</div><div class="line">        &#123;</div><div class="line">            ACE_DEBUG((LM_DEBUG, <span class="string">"(%t) this iteration is %d\n"</span>, i));</div><div class="line">            ACE_OS::sleep(<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="ACE-条件类属"><a href="#ACE-条件类属" class="headerlink" title="ACE 条件类属"></a>ACE 条件类属</h5><p>条件变量原语的包装类，特定条件满足后线程才能继续进行。<br>使用条件变量的步骤：  </p>
<ul>
<li>获取全局资源的锁；  </li>
<li>检查条件；  </li>
<li>如果条件满足执行，不满足调用 <code>wait()</code> 等待未来条件满足；  </li>
<li>当另一个线程在此全局资源上进行操作时，向其他测试条件的线程发送信号；  </li>
<li>线程醒来后，测试条件是否为真。  </li>
</ul>
<h4 id="线程管理类"><a href="#线程管理类" class="headerlink" title="线程管理类"></a>线程管理类</h4><p>使用 <code>ACE_THREAD_MANAGER</code> 进行线程管理。简单的 <code>ACE_Thread</code> 包装类用于创建和销毁线程，功能有限。 <code>ACE_Thread_Manager</code> 提供了它全部的功能，并能成组创建销毁线程，提供了丰富的管理功能，对一组线程进行管理。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不同平台下，有着若干不同的线程管理接口，提供了近乎相同的功能，但是API却相差很大，而 &lt;code&gt;ACE_Thread&lt;/code&gt; 提供了对不同平台API接口的封装，可以在不同的平台下创建，挂起，销毁线程，做到平台无关性，另外还提供了一套同步和管理机制。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="ACE" scheme="http://abumaster.com/tags/ACE/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ACE学习笔记2：内存分配</title>
    <link href="http://abumaster.com/2017/11/06/ACE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://abumaster.com/2017/11/06/ACE学习笔记2：内存分配/</id>
    <published>2017-11-06T12:00:14.000Z</published>
    <updated>2017-11-06T14:16:34.625Z</updated>
    
    <content type="html"><![CDATA[<p>一个成熟的框架或软件，都会有一个丰富的内存管理类，用于方便高效地管理内存。如STL中的内存池、Nginx中的内存池，通过预先从堆中申请空间，使用的时候可以从空闲存储中取（只是移动指针），避免频繁调用api和操作符从堆中申请释放空间，更有效率。ACE 中提供了两种不同的类用于管理内存（从堆中申请的内存或进程间共享的内存）。根据不同的开发应用选择合适的内存管理方案。  </p>
<a id="more"></a>
<h4 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h4><p>ACE 提供了两组不同的类进行内存管理：  </p>
<ul>
<li>基于 <code>ACE_Allocator</code> 类，用于局部的动态内存分配，使用动态绑定和策略模式来提供灵活性和扩展性；  </li>
<li>基于 <code>ACE_Malloc</code> 模板类，用于局部动态内存管理类和共享内存类，通过C++模板和外部多态性为内存分配提供灵活性。   </li>
</ul>
<h4 id="分配器（ACE-Allocator）"><a href="#分配器（ACE-Allocator）" class="headerlink" title="分配器（ACE_Allocator）"></a>分配器（ACE_Allocator）</h4><p>分配器用于动态内存管理，提供了若干不同策略的分配器，提供相同的功能但是具有不同的特性。不同策略的分配器及其特性的描述：  </p>
<ul>
<li><code>ACE_Allocator</code> ACE 中的分配器类的接口类。这些类使用继承和动态绑定来提供灵活性。  </li>
<li><code>ACE_Static_Allocator</code> 该分配器管理固定大小的内存。每当收到分配内存的请求时，它就移动内部指针、以返回内存块。它还假定内存一旦被分配，就再也不会被释放。  </li>
<li><code>ACE_Cached_Allocator</code> 使用内存池预先分配一定大小的内存块，连成空闲链表，内存的申请和释放只是取和放内存块。  </li>
<li><code>ACE_New_Allocator</code> 封装了C++中的 <code>new</code> 和 <code>delete</code> 运算符。  </li>
</ul>
<p><strong>使用：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Log_Msg.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Thread_Mutex.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc_T.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//分配 1k 大小的内存块，内存块简单的为char</span></div><div class="line"><span class="comment">//也可以用合适的结构和类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> MEMORY_BLOCK[<span class="number">1024</span>];</div><div class="line"><span class="keyword">typedef</span> ACE_Cached_Allocator&lt;MEMORY_BLOCK, ACE_SYNCH_MUTEX&gt; Allocator;</div><div class="line"><span class="keyword">class</span> MessageManager</div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MessageManager(<span class="keyword">int</span> n_blocks) :allocator_(n_blocks), message_count_(<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        msg_array_ = <span class="keyword">new</span> <span class="keyword">char</span> *[n_blocks];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">allocate_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></div><div class="line">    </span>&#123;</div><div class="line">        msg_array_[message_count_] = (<span class="keyword">char</span>*)allocator_.<span class="built_in">malloc</span>(ACE_OS::<span class="built_in">strlen</span>(msg) + <span class="number">1</span>);</div><div class="line">        ACE_OS::<span class="built_in">strcpy</span>(msg_array_[message_count_], msg);</div><div class="line">        ++message_count_;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free_all_msg</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; message_count_; ++i)</div><div class="line">            allocator_.<span class="built_in">free</span>(msg_array_[i]);</div><div class="line"></div><div class="line">        message_count_ = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display_all_msg</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; message_count_; ++i)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"msg: %s\n"</span>, msg_array_[i]);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> **msg_array_;</div><div class="line">    Allocator allocator_;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> message_count_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">    <span class="keyword">char</span> *message = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</div><div class="line">    <span class="function">MessageManager <span class="title">manage</span><span class="params">(n)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">sprintf</span>(message, <span class="string">"msg id %d, hello"</span>, i);</div><div class="line">        manage.allocate_msg(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    manage.display_all_msg();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ACE-Malloc"><a href="#ACE-Malloc" class="headerlink" title="ACE_Malloc"></a>ACE_Malloc</h4><p>ACE_Malloc 模板类进行内存管理，有两个模板参数，一个是内存池，另一个是锁。应用有自己的空闲内存表，当内存不够用时，则向底层内存池申请，释放时不会释放给内存池，而是连接到自己的空闲链表中，所以内存只会增大不会减小，可以调用<code>remove()</code>方法将内存还给系统。<br>使用：<br>首先选定内存池和锁机制实例化一个<code>ACE_Malloc</code>模板，生成一个分配器。用该分配器实例化一个对象，这就是应用中可以使用的分配器。可用的内存池：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Local_Memory_Pool.h"</span> <span class="comment">//使用c++的new和delete创建的局部内存池，不可进程间共享</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/MMAP_Memory_Pool.h"</span> <span class="comment">//mmap创建的内存池，可以进程间共享</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Sbrk_Memory_Pool.h"</span> <span class="comment">//sbrk调用创建的内存池</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Shared_Memory_Pool.h"</span> <span class="comment">//shmget调用创建</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Pagefile_Memory_Pool.h"</span></span></div></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Shared_Memory_MM.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc_T.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_SIZE 100</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE1 <span class="meta-string">"Hiya over there client process"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE2 <span class="meta-string">"Did you hear me the first time?"</span></span></div><div class="line">LPCTSTR poolname=<span class="string">"My_Pool"</span>;</div><div class="line"><span class="keyword">typedef</span> ACE_Malloc&lt;ACE_SHARED_MEMORY_POOL,ACE_Null_Mutex&gt; Malloc_Allocator;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server</span> <span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">//Create the memory allocator passing it the shared memory</span></div><div class="line">    <span class="comment">//pool that you want to use</span></div><div class="line">    <span class="function">Malloc_Allocator <span class="title">shm_allocator</span><span class="params">(poolname)</span></span>;</div><div class="line">    <span class="comment">//Create a message, allocate memory for it and bind it with</span></div><div class="line">    <span class="comment">//a name so that the client can the find it in the memory</span></div><div class="line">    <span class="comment">//pool</span></div><div class="line">    <span class="keyword">char</span>* Message1=(<span class="keyword">char</span>*)shm_allocator.<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(MESSAGE1));</div><div class="line">    ACE_OS::<span class="built_in">strcpy</span>(Message1,MESSAGE1);</div><div class="line">    shm_allocator.bind(<span class="string">"FirstMessage"</span>,Message1);</div><div class="line">    ACE_DEBUG((LM_DEBUG,<span class="string">"&lt;&lt;%s\n"</span>,Message1));</div><div class="line">    <span class="comment">//How about a second message</span></div><div class="line">    <span class="keyword">char</span>* Message2=(<span class="keyword">char</span>*)shm_allocator.<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(MESSAGE2));</div><div class="line">    ACE_OS::<span class="built_in">strcpy</span>(Message2,MESSAGE2);</div><div class="line">    shm_allocator.bind(<span class="string">"SecondMessage"</span>,Message2);</div><div class="line">    ACE_DEBUG((LM_DEBUG,<span class="string">"&lt;&lt;%s\n"</span>,Message2));</div><div class="line">    <span class="comment">//Set the Server to go to sleep for a while so that the client has</span></div><div class="line">    <span class="comment">//a chance to do its stuff</span></div><div class="line">    ACE_DEBUG((LM_DEBUG,</div><div class="line">    <span class="string">"Server done writing.. going to sleep zzz..\n\n\n"</span>));</div><div class="line">    ACE_OS::sleep(<span class="number">2</span>);</div><div class="line">    <span class="comment">//Get rid of all resources allocated by the server. In other</span></div><div class="line">    <span class="comment">//words get rid of the shared memory pool that had been</span></div><div class="line">    <span class="comment">//previously allocated</span></div><div class="line">    shm_allocator.remove();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">//Create a memory allocator. Be sure that the client passes</span></div><div class="line">    <span class="comment">// in the "right" name here so that both the client and the</span></div><div class="line">    <span class="comment">//server use the same memory pool. We wouldn’t want them to</span></div><div class="line">    <span class="comment">// BOTH create different underlying pools.</span></div><div class="line">    <span class="function">Malloc_Allocator <span class="title">shm_allocator</span><span class="params">(poolname)</span></span>;</div><div class="line">    <span class="comment">//Get that first message. Notice that the find is looking up the</span></div><div class="line">    <span class="comment">//memory based on the "name" that was bound to it by the server.</span></div><div class="line">    <span class="keyword">void</span> *Message1;</div><div class="line">    <span class="keyword">if</span>(shm_allocator.find(<span class="string">"FirstMessage"</span>,Message1)==<span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        ACE_ERROR((LM_ERROR,</div><div class="line">                <span class="string">"Client: Problem cant find data that server has sent\n"</span>));</div><div class="line">        ACE_OS::<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    ACE_OS::<span class="built_in">printf</span>(<span class="string">"&gt;&gt;%s\n"</span>,(<span class="keyword">char</span>*) Message1);</div><div class="line">    ACE_OS::fflush(<span class="built_in">stdout</span>);</div><div class="line">    <span class="comment">//Lets get that second message now.</span></div><div class="line">    <span class="keyword">void</span> *Message2;</div><div class="line">    <span class="keyword">if</span>(shm_allocator.find(<span class="string">"SecondMessage"</span>,Message2)==<span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        ACE_ERROR((LM_ERROR,</div><div class="line">                <span class="string">"Client: Problem cant find data that server has sent\n"</span>));</div><div class="line">        ACE_OS::<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    ACE_OS::<span class="built_in">printf</span>(<span class="string">"&gt;&gt;%s\n"</span>,(<span class="keyword">char</span>*)Message2);</div><div class="line">    ACE_OS::fflush(<span class="built_in">stdout</span>);</div><div class="line">    ACE_DEBUG((LM_DEBUG,<span class="string">"Client done reading! BYE NOW\n"</span>));</div><div class="line">    ACE_OS::fflush(<span class="built_in">stdout</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">switch</span> (ACE_OS::fork ())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</div><div class="line">            ACE_ERROR_RETURN ((LM_ERROR, <span class="string">"%p\n"</span>, <span class="string">"fork"</span>), <span class="number">1</span>);</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="comment">// Make sure the server starts up first.</span></div><div class="line">            ACE_OS::sleep (<span class="number">1</span>);</div><div class="line">            client ();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            server ();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Windows　平台下将上述代码中改为<code>typedef ACE_Malloc&lt;ACE_MMAP_MEMORY_POOL, ACE_Null_Mutex&gt; Malloc_Allocator;</code> ，并且，不能用fork来创建子进程，需要分两个程序来测试。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个成熟的框架或软件，都会有一个丰富的内存管理类，用于方便高效地管理内存。如STL中的内存池、Nginx中的内存池，通过预先从堆中申请空间，使用的时候可以从空闲存储中取（只是移动指针），避免频繁调用api和操作符从堆中申请释放空间，更有效率。ACE 中提供了两种不同的类用于管理内存（从堆中申请的内存或进程间共享的内存）。根据不同的开发应用选择合适的内存管理方案。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="ACE" scheme="http://abumaster.com/tags/ACE/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ACE学习笔记-1</title>
    <link href="http://abumaster.com/2017/11/04/ACE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://abumaster.com/2017/11/04/ACE学习笔记-1/</id>
    <published>2017-11-04T06:48:01.000Z</published>
    <updated>2017-11-04T07:11:37.308Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ACE</strong> (Adaptive Communication Environment) 自适配通信环境，一个高效的、跨平台的、稳定的C++网络 <em>中间件</em> 提供了众多功能和特性。第一章安装。<br><a id="more"></a></p>
<ul>
<li><p><strong>平台</strong><br>Windows 10 + vs2013 + ACE6.4.0  </p>
</li>
<li><p>下载  <a href="http://download.dre.vanderbilt.edu/">地址</a>。解压得到文件夹 <code>ACE_wrappers</code>，其中包含了源文件以及工程文件；  </p>
</li>
<li><p>目录下有 <code>ACE-INSTALL.html</code> 包含了安装指导，在ace文件夹下新建一个 <code>config.h</code> 文件，其中添加头文件和宏定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ACE_HAS_STANDARD_CPP_LIBRARY 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config-win32.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ACE_NO_INLINE</span></div></pre></td></tr></table></figure>
</li>
<li><p>打开 <code>ace_vc12.sln</code> 解决方案，根据情况编译 Debug 或者 Release 版本的ace库，编译完成后在 <code>ACE_wrappers/lib</code> 下生成了 <code>lib</code> 和 <code>dll</code> 。  </p>
</li>
<li>使用，新建工程可以将头文件目录以及库目录添加到工程中。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ACE&lt;/strong&gt; (Adaptive Communication Environment) 自适配通信环境，一个高效的、跨平台的、稳定的C++网络 &lt;em&gt;中间件&lt;/em&gt; 提供了众多功能和特性。第一章安装。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>秋招之路-反思</title>
    <link href="http://abumaster.com/2017/10/25/%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF-%E5%8F%8D%E6%80%9D/"/>
    <id>http://abumaster.com/2017/10/25/秋招之路-反思/</id>
    <published>2017-10-25T01:18:24.000Z</published>
    <updated>2017-11-16T06:02:52.588Z</updated>
    
    <content type="html"><![CDATA[<p>七八月开始准备找工作，期间看了几本书，做了不少的算法题。从八月底开始投递简历，开始做笔试。然后九月开始四处跑宣讲会，做笔试，面试，累。等到十月的中旬才找到了工作，算是比较垫底的薪资水准了，我的水平难道是不过如此了吗？第一份工作就不过如此了。<br><a id="more"></a></p>
<blockquote class="blockquote-center">
不乱于心，不困于情，不畏将来，不念过往，如此，安好。<br>–丰子恺 《不宠无惊过一生》
</blockquote>

<center>
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-10-25/34678281.jpg" alt=""><br></center>

<div class="note primary"><p>第一次面试  </p>
</div>  
<p>第一次面试的公司是<strong>富途证券</strong>，算是第一次正式面试的公司吧，印象有点深刻。校招流程很简单：线下宣讲会，然后笔试，隔天开始通知面试，现场多轮面试。很有幸过了笔试（后来才发现与线上的笔试相比，线下的笔试要简单许多）。然后通知去面试，时间2017年9月16号。<br>面试是在一个酒店里面，公司的一票人在那里订了房间，有hr和随行的技术人员，一晚上的时间来改完试卷开始通知面试。面试官在房间里等着，hr挨个喊人进去面试，第一次很紧张，说不紧张都是假的。同行的还有徐蔚和石多。我们等了一会就被叫进房间开始各自的面试了。<br>面试我的是一个和我差不多大小的年轻老师（暂且叫面试官老师吧），做技术的一般不是太讲究，然后首先让我自我介绍一下，我就随便说说，也没有组织的太多，想到哪里就说到哪里。然后，他开始问我问题，感觉对我的期望还是蛮高的，可能是卷面的成绩有点高吧。问了我Linux下的一些问题及编译程序，coredump出现时的解决办法。哎，这些问题平时都是在用到的时候到网上查，并没有太多的总结，所以在这吃亏了，回答的并不是太全面。问了我一个程序改错题，我还是不知道是紧张还是程序阅读能力太低，对此没有回答的太全面。最后，一面挂了。对了，还有一道算法题，我和他说这个我以前是刷过，但是忘了，太诚实了，太幼稚了。面试时间也就二十分钟左右，可能是尬聊了，问啥啥不会。。<br>面试也不过如此了，我真的是不擅长表达！还是心态不好，紧张。  </p>
<div class="note info"><p>面啥挂啥，我能怎么办？  </p>
</div>
<p>金九银十，我们的状态是跑宣讲会，听公司吹牛，顺便做一做他们的笔试题，然后去参加他们的面试，也就是去积累一些经验，见识一些题目，见识一些面试问题，见识一些比你牛很多的人。<br>一般笔试的题目都很简单，一般都可以进面试的，最重要的是面试的时候，该怎么聊才能给面试官留下很深的印象，或者认为你这个人有潜力，值得公司培养，或者公司付出小的成本，你能给公司带来巨大的收益。他们的期望与你自己的表现之间的差值。<br>有时感觉自己聊的很好啊，但是没有亮点还是不行的。比如蓝港集团，一家游戏公司。也没有问什么项目问题、技术问题也没有问，只是让我在那里自己陈述自己做过什么，他在就此回答问题。其中我说我比较熟悉stl中的内存管理机制，其实这一方面的细节我都忘的差不多了，我就简单的说了一下，可能是没有说清楚吧，他也没有细问，估计也不是很懂。然后到最后的提问环节，我问了一些技术问题，我不知道的，他没有回答，而是问问我的看法，我不懂啊，我说了不知道（后来才知道这种干脆的回答是致命的错误，你给面试官一个信息：你不擅长思考，不能就问题提出自己的见解和判断）。其实，问题并没有标准的答案，只要是想一想能回答个大概，我当时就是因为不确定是否正确。才没有回答，这是一个缺点：对于不确定的事物，我不想回答，连思考都懒得去思考。<br>后来参加了多家，趋势科技，绿盟，58集团，wps，烽火科技等，自己的能力确实太差劲了。<br><strong>最糟糕的面试体验</strong>，任子行公司的面试体验真是差劲到爆。刚开始群面，也是服了，你说搞技术的人有多少能聊的，确实有，不过也只是只会动动嘴皮子罢了。这也没得说的。然后第二天是上机，说是分开时间段，但是你只准备一台机器，让几个人挨个上机是怎么回事啊，还只有一个面试官老师，上午九点去的，然后下午三点多才搞完。技术面试的时候两个人一起是怎么回事啊。无语了。  </p>
<div class="note sucess"><p>选择  </p>
</div>  
<p>总会面临一些选择，对错？很难确定。杭州的一家游戏公司也给我发了offer，感觉公司的氛围很不错的，而且待遇什么的都很好，在杭州这个充满了奇迹的地方。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;七八月开始准备找工作，期间看了几本书，做了不少的算法题。从八月底开始投递简历，开始做笔试。然后九月开始四处跑宣讲会，做笔试，面试，累。等到十月的中旬才找到了工作，算是比较垫底的薪资水准了，我的水平难道是不过如此了吗？第一份工作就不过如此了。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://abumaster.com/categories/life/"/>
    
    
      <category term="其他" scheme="http://abumaster.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>curl库的使用</title>
    <link href="http://abumaster.com/2017/10/20/curl%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2017/10/20/curl库的使用/</id>
    <published>2017-10-20T10:28:11.000Z</published>
    <updated>2017-10-21T12:32:50.194Z</updated>
    
    <content type="html"><![CDATA[<p><em>curl</em>是利用URL语法在命令行下工作的一种文件传输工具。支持文件的上传和下载，可以应用到多个平台，支持各种传输协议。<em>libcurl</em>是一种开发库，支持多种协议多个平台的文件传输库。<a href="https://curl.haxx.se/libcurl/">libcurl</a>。方便网络应用的开发。  </p>
<a id="more"></a>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p>从上述的<a href="https://curl.haxx.se/libcurl/">官网</a>下载源码，Linux平台<code>configure</code>和<code>make</code>就行了。说一下在 Windows 平台下的编译使用。<br>打开源码目录下的<code>winbuild</code>文件夹，按照<code>BUILD.WINDOWS.txt</code>文档中提供的编译信息，然后利用vs提供的命令行工具进行编译生成<code>.lib</code>或<code>.dll</code>文件。<br>使用，将lib文件和头文件加入到自己的工程中，然后添加预编译定义<code>CURL_STATICLIB</code>，或者在<code>curl.h</code>文件中添加一行宏定义<code>#define CURL_STATICLIB</code>。然后就可以编译使用了。  </p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>1.<code>CURLcode curl_global_init(long flags);</code><br>描述：用于全局初始化，清理之前，只能被调用一次，如果在函数<code>curl_easy_init</code>前没有显示调用，则lcurl库会自动调用，所以多线程中应在主线程中显示调用此函数来初始化。初始化参数包括：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CURL_GLOBAL_ALL                      <span class="comment">//初始化所有的可能的调用。</span></div><div class="line">CURL_GLOBAL_SSL                      <span class="comment">//初始化支持 安全套接字层。</span></div><div class="line">CURL_GLOBAL_WIN32            <span class="comment">//初始化win32套接字库。</span></div><div class="line">CURL_GLOBAL_NOTHING         <span class="comment">//没有额外的初始化。</span></div></pre></td></tr></table></figure></p>
<p>2.<code>void curl_global_cleanup(void);</code><br>与上述初始化函数类似，在结束使用的时候，调用此函数进行清理工作，这个函数仍然不是线程安全的，因此多线程环境下保证在主线程中调用一次来完成清理工作。  </p>
<p>3.<code>CURL *curl_easy_init( );</code><br>初始化一个<code>CURL</code>指针，类似文件指针那样，意味着一个会话的开始。  </p>
<p>4.<code>void curl_easy_cleanup(CURL *handle);</code><br>调用此函数来释放初始化的指针，完成清理工作。  </p>
<p>5.<code>char *curl_version( );</code><br>描述当前库的版本信息。  </p>
<p>6.<code>CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</code><br>重要的一个函数，设置选项。告知程序要有何种行为。第一个参数表示初始化获得指针，第二个参数表示选项，第三个参数可以是函数指针、对象指针或者是一个long型变量，主要依赖第二个参数。<br>选项：<br><code>CURLOPT_URL</code> 设置访问URL；<br><code>CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</code> 写数据，<br>回调函数原型为：<code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code> 函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。 <code>CURLOPT_WRITEDATA</code>  用于表明 <code>CURLOPT_WRITEFUNCTION</code> 函数中的stream指针的来源。<br>如果你没有通过 <code>CURLOPT_WRITEFUNCTION</code> 属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 <code>CURLOPT_WRITEDATA</code> 属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。<br><code>CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</code> 回调函数原型为 <code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code> libcurl一旦接收到http 头部数据后将调用该函数。<code>CURLOPT_WRITEDATA</code>  传递指针给libcurl，该指针表明 <code>CURLOPT_HEADERFUNCTION</code> 函数的stream指针的来源。<br><code>CURLOPT_READFUNCTION CURLOPT_READDATA</code> libCurl需要读取数据传递给远程主机时将调用 <code>CURLOPT_READFUNCTION</code> 指定的函数，函数原型是：<code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)</code> 。<br><code>CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</code><br>跟数据传输进度相关的参数。<code>CURLOPT_PROGRESSFUNCTION</code> 指定的函数正常情况下每秒被libcurl调用一次，为了使 <code>CURLOPT_PROGRESSFUNCTION</code>被调用，<code>CURLOPT_NOPROGRESS</code> 必须被设置为false，<code>CURLOPT_PROGRESSDATA</code> 指定的参数将作为 <code>CURLOPT_PROGRESSFUNCTION</code> 指定函数的第一个参数。<br><code>CURLOPT_FOLLOWLOCATION</code> 设置重定位URL。<br><code>CURLOPT_RANGE: CURLOPT_RESUME_FROM:</code> 断点重传相关设置。<code>CURLOPT_RANGE</code> 指定<code>char *</code>参数传递给libcurl，用于指明http域的RANGE头域，例如：表示头500个字节：bytes=0-499。<code>CURLOPT_RESUME_FROM</code> 传递一个long参数给libcurl，指定你希望开始传递的偏移量。<br>7.<code>CURLcode curl_easy_perform(CURL *handle);</code><br>让前面设置过选型的程序运行起来。参数为指针。返回值为0表示成功，非零表示错误，可以调用<code>const char *curl_easy_strerror(CURLcode errornum )</code>函数来获取错误信息。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;curl&lt;/em&gt;是利用URL语法在命令行下工作的一种文件传输工具。支持文件的上传和下载，可以应用到多个平台，支持各种传输协议。&lt;em&gt;libcurl&lt;/em&gt;是一种开发库，支持多种协议多个平台的文件传输库。&lt;a href=&quot;https://curl.haxx.se/libcurl/&quot;&gt;libcurl&lt;/a&gt;。方便网络应用的开发。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="网络" scheme="http://abumaster.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>UML基础学习</title>
    <link href="http://abumaster.com/2017/10/11/UML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://abumaster.com/2017/10/11/UML基础学习/</id>
    <published>2017-10-11T02:03:05.000Z</published>
    <updated>2017-10-16T10:39:42.593Z</updated>
    
    <content type="html"><![CDATA[<p>UML，Unified Modeling Language，统一建模语言，一种有特殊用途的语言。从用途和分类，到简单应用做一个总结。其他学习<a href="http://blog.csdn.net/column/details/u-m-l.html">网站CSDN专栏</a>。在线 UML 工具 <a href="https://www.processon.com/">ProcessOn</a>。  </p>
<a id="more"></a>
<h4 id="UML-分类"><a href="#UML-分类" class="headerlink" title="UML 分类"></a>UML 分类</h4><p>UML 可分为两类：结构型、行为型。<br>结构性的UML有：  </p>
<ul>
<li>类图，显示了系统的静态结构，用于对系统中的各种概念建模，并描绘他们之间的关系，类是相同数据结构行为和关系的一组对象；  </li>
<li>对象图，类的实例化；  </li>
<li>构件图，将可重用的代码或模块封装成可替换的物理单元，称为构件，描述构件之间的关系；  </li>
<li>部署图  </li>
<li>包图<br>行为型的图有：  </li>
<li>活动图  </li>
<li>状态机图  </li>
<li>顺序图  </li>
<li>通信图  </li>
<li>用例图  </li>
<li>时间图  </li>
</ul>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p>参考C++中的类，具有类名称、类的属性以及操作。属性和操作对其他类的可见性通过三种方式进行控制，公有私有和保护。<br>类图之间的关系：<br>类与类之间的关系通常有4种，即依赖关系（Dependency）、泛化关系（Generalization）、关联关系（Association）、实现关系（Realization）。<br><a href="http://blog.csdn.net/jiuqiyuliang/article/details/8568303">参考</a>。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UML，Unified Modeling Language，统一建模语言，一种有特殊用途的语言。从用途和分类，到简单应用做一个总结。其他学习&lt;a href=&quot;http://blog.csdn.net/column/details/u-m-l.html&quot;&gt;网站CSDN专栏&lt;/a&gt;。在线 UML 工具 &lt;a href=&quot;https://www.processon.com/&quot;&gt;ProcessOn&lt;/a&gt;。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="uml" scheme="http://abumaster.com/tags/uml/"/>
    
      <category term="软件设计" scheme="http://abumaster.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>一面攒人品-趋势科技</title>
    <link href="http://abumaster.com/2017/09/19/%E4%B8%80%E9%9D%A2%E6%94%92%E4%BA%BA%E5%93%81-%E8%B6%8B%E5%8A%BF%E7%A7%91%E6%8A%80/"/>
    <id>http://abumaster.com/2017/09/19/一面攒人品-趋势科技/</id>
    <published>2017-09-19T11:16:01.000Z</published>
    <updated>2017-09-20T09:14:32.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>趋势科技面试题目汇总，不是太难，面试官人很好，基础还是很薄弱的，好多东西都忘了。</p>
</blockquote>
<a id="more"></a>
<p><strong>1.知道迭代器吗，迭代器失效</strong><br>我回答了迭代器是一个指针，vector在插入和删除会引起迭代器的失效，记得在stl源码剖析中看到过，但是没有系统的回答出来。<br>标准回答：<br>vector在进行插入和删除操作后会使部分或者全部的迭代器失效，因为vector是顺序存储的，当容量不够时会删除原有的旧空间，然后将元素拷贝到新的空间中，导致所有的原空间上的迭代器失败。删除操作后，指向删除点的迭代器和其后的迭代器全部失效。<br>deque容器在首部尾部插入迭代器不会失效，首部和尾部删除元素会使删除元素的迭代器失效，在中间删除元素会使所有的迭代器失效。<br>list很少失效，只有删除的元素的迭代器失效。  </p>
<p><strong>2.删除容器中值为2的元素</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.begin(); it != vec.end();)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (*it == <span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            it = vec.erase(it);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            ++it;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.进程同步，共享存储在一个进程失效后，会如何回收</strong><br><a href="http://blog.chinaunix.net/uid-26833883-id-3230564.html">共享内存</a><br>共享内存的介绍：共享内存是一种高效的进程间通信，直接读写内存是一种高效的数据拷贝；内核中专门开辟一块内存区，进程直接映射到自己的私有地址空间中，直接读取不需要拷贝，所以更加高效；多个进程共享这块内存，所以需要一种同步机制。<br>流程：  </p>
<ul>
<li>创建或者打开共享存储；  </li>
<li>映射共享内存，将指定的内存映射到进程地址空间便于访问；  </li>
<li>撤销共享内存的映射；  </li>
<li>删除共享内存对象。<br>控制共享内存：  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</div><div class="line"><span class="comment">//shmid 共享内存标识</span></div><div class="line"><span class="comment">//cmd :IPC_STAT 得到共享内存的状态；IPC_SET 改变共享内存的状态；IPC_RMID 删除共享内存</span></div><div class="line"><span class="comment">//buf  是一个结构体指针。IPC_STAT的时候，取得的状态放在这个结构体中。如果要改变共享内存的状态，用这个结构体指定；</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>IPC_RMID命令实际上不从内核删除一个段，而是仅仅把这个段标记为删除，实际的删除发生最后一个进程离开这个共享段时。<br>当cmd为IPC_RMID时，第三个参数应为NULL。呵呵，大部分我们都是这样做,用这个函数删除共享内存。  </p>
<p><strong>4.程序崩溃</strong><br>一种方法，程序崩溃一般通过COREDUMP文件进行调试，在windows下面这部分需要自己在程序中添加代码，网上有源代码，添加到程序中即可。程序崩溃是点击COREDUMP文件，运行VS2010即可快速定位。  </p>
<p>另外一种方法，没有COREDUMP时，先运行程序，然后在VS2010中，把工程附加到进程，注意工程中运行涉及的所有文件必须是VS2010最新代码编译的。这种情况下，VS2010工程中不需要打断点，当程序运行出现崩溃时，自动跳转VS2010的代码中。这种情况非常适合服务器程序，尤其是崩溃发生的条件不清楚，无法再现的情况。尤其服务器运行几天后，崩溃，这种情况非常有用。  </p>
<p><strong>5.sql数据库加锁</strong><br><a href="http://blog.csdn.net/gz2008gz/article/details/5398529">数据库加锁</a><br>处理多用户并发访问的方法是加锁。锁是防止其他事务访问指定的资源控制、实现并发控制的一种主要手段。当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象。加锁对并发访问的影响体现在锁的粒度上。为了控制锁定的资源，应该首先了解系统的空间管理。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;趋势科技面试题目汇总，不是太难，面试官人很好，基础还是很薄弱的，好多东西都忘了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>硬币找零问题—动态规划</title>
    <link href="http://abumaster.com/2017/09/15/%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://abumaster.com/2017/09/15/硬币找零问题—动态规划/</id>
    <published>2017-09-15T00:32:53.000Z</published>
    <updated>2017-09-15T04:00:01.663Z</updated>
    
    <content type="html"><![CDATA[<p>硬币找零问题主要分为求最少硬币找零和最多组合数找零，一个是求用最少的硬币来达到目标，一个是达到目标的组合数。<br><a id="more"></a></p>
<h4 id="最少硬币找零问题"><a href="#最少硬币找零问题" class="headerlink" title="最少硬币找零问题"></a>最少硬币找零问题</h4><p><strong>问题描述</strong><br>给不同面值的硬币若干种（每种硬币个数无限多），用这若干种硬币组合为某种面额的钱，使用的硬币的个数最少。<br><strong>分析</strong>
贪心策略往往不是最优的。这时用到动态规划，假设硬币面值为<code>{v1,v2,v3,...,vn}</code>，纸币金额为<code>sum</code>，可以假设<code>dp[i]</code>表示面值为i的纸币所需的最少硬币个数，然后对于每个i遍历所有的硬币数目，更新最小值。如何转移？对于第i面值的纸币，遍历每个硬币，如果当前硬币的值小于，则可以分解为子问题，+1，更新最小值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">coinsUsed[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cents = <span class="number">1</span>; cents &lt;= money; cents++) &#123;  </div><div class="line">    <span class="comment">// 当用最小币值的硬币找零时，所需硬币数量最多  </span></div><div class="line">    <span class="keyword">int</span> minCoins = cents;  </div><div class="line"></div><div class="line">    <span class="comment">// 遍历每一种面值的硬币，看是否可作为找零的其中之一  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kind = <span class="number">0</span>; kind &lt; valueKinds; kind++) &#123;               </div><div class="line">        <span class="comment">// 若当前面值的硬币小于当前的cents则分解问题并查表  </span></div><div class="line">        <span class="keyword">if</span> (values[kind] &lt;= cents) &#123;  </div><div class="line">            <span class="keyword">int</span> temp = coinsUsed[cents - values[kind]] + <span class="number">1</span>;  </div><div class="line">            <span class="keyword">if</span> (temp &lt; minCoins) &#123;  </div><div class="line">                minCoins = temp;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 保存最小硬币数  </span></div><div class="line">coinsUsed[cents] = minCoins;</div></pre></td></tr></table></figure></p>
<h4 id="硬币面值组合问题"><a href="#硬币面值组合问题" class="headerlink" title="硬币面值组合问题"></a>硬币面值组合问题</h4><p><strong>问题描述</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">假设我们有8种不同面值的硬币｛1，2，5，10，20，50，100，200｝，用这些硬币组合够成一个给定的数值n。例如n=200，那么一种可能的组合方式为 200 = 3 * 1 + 1＊2 + 1＊5 + 2＊20 + 1 * 50 + 1 * 100. 问总过有多少种可能的组合方式？</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/python27/archive/2013/09/05/3303721.html">参考</a><br>定义 <code>dp[i][m]</code>表示前i种硬币构成m的组合数，对于第i个硬币可以用<code>{0,1,...,m/coins[i]}</code>个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][sum] = dp[i-1][sum - 0*Vm] + dp[i-1][sum - 1*Vm]+ dp[i-1][sum - 2*Vm] + ... + dp[i-1][sum - K*Vm]; 其中K = sum / Vm</div></pre></td></tr></table></figure></p>
<p>关键代码
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncoins; ++i)<span class="comment">//硬币种类数</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)<span class="comment">//兑换的面值</span></div><div class="line">        &#123;</div><div class="line">            dp[i][j] = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j / arr[i - <span class="number">1</span>]; ++k)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - k*arr[i - <span class="number">1</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="限制级的找零"><a href="#限制级的找零" class="headerlink" title="限制级的找零"></a>限制级的找零</h4><p>找零问题，限制硬币的个数，硬币的面值，如腾讯2018秋招的笔试题大意为：拥有硬币面值为<code>2^k</code>，数量各为两个，求拼凑出num的硬币组合数，如拼凑出6的组合数为：<code>{4,2},{4,1,1},{2,2,1,1}</code>，拥有的硬币面值为1,2,4,8,16,…各位2个。<br>与第一个问题类似，只不过限定了硬币用的个数k，以及硬币的面值，所以根据给定的兑换金额可以确定硬币的面值序列，每个面值最多用2个，然后问题就简单了，代码如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//兑换sum元的组合数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LimitCoinsComb</span><span class="params">(<span class="keyword">int</span> sum)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">//硬币的面值为：1,2,4,8,16...2^k 各位2个</span></div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">log</span>(sum) / <span class="built_in">log</span>(<span class="number">2</span>);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = <span class="built_in">pow</span>(<span class="number">2</span>, i);</div><div class="line">        coins.push_back(temp);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        dp[i].resize(sum + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化，sum==0时只有一种组合，其它初始为0中组合</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j / coins[i - <span class="number">1</span>], <span class="number">2</span>); ++k)<span class="comment">//最多用2个或者j/coins[i]个，最小值</span></div><div class="line">            &#123;</div><div class="line">                dp[i][j] += dp[i<span class="number">-1</span>][j - k*coins[i - <span class="number">1</span>]];<span class="comment">//递推公式</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n+<span class="number">1</span>][sum];<span class="comment">//返回结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬币找零问题主要分为求最少硬币找零和最多组合数找零，一个是求用最少的硬币来达到目标，一个是达到目标的组合数。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="动态规划" scheme="http://abumaster.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>常见算法模板</title>
    <link href="http://abumaster.com/2017/09/06/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <id>http://abumaster.com/2017/09/06/常见算法模板/</id>
    <published>2017-09-06T13:12:25.000Z</published>
    <updated>2017-09-15T06:43:57.848Z</updated>
    
    <content type="html"><![CDATA[<p>常见的算法模板，如并查集、字典树等。
<a id="more"></a></p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p><strong>定义</strong>：并查集是一种树型结构，又叫“不相交集合”，保持了一组不相交的动态集合，每个集合有一个代表标识着集合，通常用根节点表示。<br><strong>三种基本操作</strong><br>1.初始化 <code>Make_Set(x)</code> ，建立一个新的集合，集合中只有一个元素x，因此x代表整个集合，要求集合不相交，因此x不会出现在其他集合中。<br>2.查找代表 <code>Find_Set(x)</code> 查找可以代表x的集合的代表，返回x所在集合的根节点；<br>3.合并集合 <code>Union(x, y)</code> 合并x和y代表的集合，查找两个集合的根节点，相同则不必合并，不同则需要合并。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立一个新的集合，每一个子节点就是一个数，本身就是他的根节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Make_Set</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    father[x] = x;</div><div class="line">    R[x] = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过递归向上查找根节点，回溯时改变当前节点的父节点，直接指向根节点。</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Set</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x != father[x])</div><div class="line">        father[x] = Find_set(father[x]);</div><div class="line">    <span class="keyword">return</span> father[x];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将根节点设置为-1的非递归方法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Set2</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> y = x;</div><div class="line">    <span class="keyword">while</span>(y!= <span class="number">-1</span>)</div><div class="line">        y = father[y];</div><div class="line">    <span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//两个集合的合并算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> GrandX = Find_set(x);</div><div class="line">    <span class="keyword">int</span> GrandY = Find_set(y);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(GrandX == GrandY)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(R[GrandX] &lt; R[GrandY])</div><div class="line">        father[GrandX] = GrandY;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(R[GrandX] == R[GrandY])</div><div class="line">            R[GrandX]++;</div><div class="line">        father[GrandY] = GrandX;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h4><p><a href="http://www.cnblogs.com/tanky_woo/archive/2010/09/24/1833717.html">字典树</a>又称 <em>单词查找树</em>，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br>类似于字典，将一个字符串对应到一棵树上，第一个字母为第一层，第二个字母为第二层，依次向下走。<br>数据结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Trie   </div><div class="line">&#123;   </div><div class="line">    Trie *next[MAX];<span class="comment">//元素的个数，小写字母26个</span></div><div class="line">    <span class="keyword">int</span> v;   <span class="comment">//根据需要变化</span></div><div class="line">&#125;;   </div><div class="line"> </div><div class="line">Trie *root;</div></pre></td></tr></table></figure></p>
<p>支持的操作：<br>创建字典树，动态分配空间，对于给定的字符串中的每一个字符，查找树对应的层，如果为空，那么申请一个新的节点，下一个指针为空，如果存在值加1，指向下一层。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTrie</span><span class="params">(<span class="keyword">char</span> *str)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</div><div class="line">    Trie *p = root, *q;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> id = str[i]-<span class="string">'0'</span>;</div><div class="line">        <span class="keyword">if</span>(p-&gt;next[id] == <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            q = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</div><div class="line">            q-&gt;v = <span class="number">1</span>;    <span class="comment">//初始v==1</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAX; ++j)</div><div class="line">                q-&gt;next[j] = <span class="literal">NULL</span>;</div><div class="line">            p-&gt;next[id] = q;</div><div class="line">            p = p-&gt;next[id];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            p-&gt;next[id]-&gt;v++;</div><div class="line">            p = p-&gt;next[id];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    p-&gt;v = <span class="number">-1</span>;   <span class="comment">//若为结尾，则将v改成-1表示</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查找一段字符串是否是其中的一个前缀字符串，按层次搜索，如果从中间的某一层没有查到，那么查找失败返回0，成功放回-1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTrie</span><span class="params">(<span class="keyword">char</span> *str)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</div><div class="line">    Trie *p = root;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> id = str[i]-<span class="string">'a'</span>;</div><div class="line">        p = p-&gt;next[id];</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)   <span class="comment">//若为空集，表示不存以此为前缀的串</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(p-&gt;v == <span class="number">-1</span>)   <span class="comment">//字符集中已有串是此串的前缀</span></div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//此串是字符集中某串的前缀</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的算法模板，如并查集、字典树等。
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
