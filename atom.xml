<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2017-07-03T13:27:20.575Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c语言中的struct-option结构</title>
    <link href="http://abumaster.com/2017/07/03/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84struct-option%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/07/03/c语言中的struct-option结构/</id>
    <published>2017-07-03T12:52:19.000Z</published>
    <updated>2017-07-03T13:27:20.575Z</updated>
    
    <content type="html"><![CDATA[<p>C语言知识拾遗，struct option 结构体。</p>
<a id="more"></a>
<p><code>struct option</code> 指明了一个长参数，在一些控制台程序中经常用到，需要指明不同的参数来运行程序。如开源软件<strong>webbench</strong>运行<code>./webbench -h</code>后会出现一些可选项，指定不同的参数，程序会做出不同的相应。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-3/68613055.jpg" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> option &#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//name表示的是长参数名</span></div><div class="line">	<span class="keyword">int</span> has_arg；</div><div class="line">	<span class="keyword">int</span> *flag;</div><div class="line">	<span class="keyword">int</span> val; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数说明：<br><em>name</em> 表示长参数的名称；<br><em>has_arg</em> 表示参数名称后面是否需要跟着参数，no_argument(0)不需要，required_argument(1)一定要跟个参数，optional_argument(2)可以有也可以没有；<br><em>flag</em> 决定了<code>getopt_long</code>的返回值，如果为NULL，返回val字段的数值；如果不为NULL，则会使其指向的内容变为val中的值，并且返回0；若未发现长选项，那么指向不变；<br><em>val</em> 指定的默认值。  </p>
<p><strong>长命令参数的解析</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</div></pre></td></tr></table></figure></p>
<p>参数说明：<br><code>argc</code> 和 <code>argv</code> 是命令行参数；<br><code>optstring</code> 选项参数组成的字符串，如果一个字母后面跟着一个冒号如 <code>t:</code>，那么表示这个选项后需要参数；<br><code>longopts</code> 是需要的自定义的option结构体；<br><code>longindex</code> 指定一个索引指针。  </p>
<p><strong>例子</strong>：  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言知识拾遗，struct option 结构体。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-迭代器和traits编程技法</title>
    <link href="http://abumaster.com/2017/06/27/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8Ctraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/"/>
    <id>http://abumaster.com/2017/06/27/STL源码剖析-迭代器和traits编程技法/</id>
    <published>2017-06-27T06:46:37.000Z</published>
    <updated>2017-06-30T02:38:56.651Z</updated>
    
    <content type="html"><![CDATA[<p>STL源码剖析，第三章 迭代器和traits编程技法的读书笔记。</p>
<a id="more"></a>
<div class="note info"><p><em>迭代器</em> 是一种类似指针的对象，各种行为中最重要的是内容提领(dereference)和成员访问(member access)。最重要的是对 <code>operator*</code> 和 <code>operator-&gt;</code> 进行重载。  </p>
</div>  
<h4 id="迭代器的相应型别"><a href="#迭代器的相应型别" class="headerlink" title="迭代器的相应型别"></a>迭代器的相应型别</h4><p>相应型别（associated type）是迭代器所指之物的型别。<br>应用场景：算法中可能用到一个以迭代器所指型别类型的变量，这时如何获取呢？C++ 不支持<code>typeof</code>。<br>解决方法：利用函数模板的参数推导机制，可以推导出型别。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span></div><div class="line"></span>&#123;</div><div class="line">	T tmp; <span class="comment">// T 所指之物的类别 int</span></div><div class="line">	<span class="comment">// ... 这里做原本func做的工作</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span></div><div class="line"><span class="keyword">void</span> <span class="title">func</span><span class="params">(I iter)</span></div><div class="line"></span>&#123;</div><div class="line">	func_impl(iter, *iter); <span class="comment">// func 的工作全部移往 func_impl</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	func(&amp;i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Traits-编程技法"><a href="#Traits-编程技法" class="headerlink" title="Traits 编程技法"></a>Traits 编程技法</h4><p>上述的参数推导机制，无法推导出函数返回值的型别。有一种方法：内嵌型别来解决，内嵌一个类型声明 value type 。如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> MyIter &#123;</div><div class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌式声明（nested type）</span></div><div class="line">	T* ptr;</div><div class="line">	MyIter(T* p=<span class="number">0</span>) : ptr(p) &#123; &#125;</div><div class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="keyword">typename</span> I::value_type <span class="comment">// 这一行是 func 的回返值型別</span></div><div class="line">func(I ite)</div><div class="line">&#123; <span class="keyword">return</span> *ite; &#125;</div><div class="line"><span class="comment">// 调用</span></div><div class="line">MyIter&lt;<span class="keyword">int</span>&gt; ite(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</div><div class="line"><span class="built_in">cout</span> &lt;&lt; func(ite); <span class="comment">// 输出：8</span></div></pre></td></tr></table></figure></p>
<p><strong>并不是所有的迭代器都可以内嵌型别，如原生指针不是 class type，就无法定义型别。</strong>因此，对一般化概念进行特定情况处理，模板偏特化（template partial specialization）可以做到。<br>所谓<em>偏特化</em>是针对任意template参数更进一步限制条件设计出的一个特化版本。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;typeneme T&gt;</div><div class="line"><span class="keyword">class</span> C&lt;T*&gt; &#123;...&#125;<span class="comment">//T为原生指针的情况，是T为任何类型的进一步条件限制</span></div></pre></td></tr></table></figure></p>
<p><strong>特征萃取机</strong><br>负责将迭代器或者原生指针中的特征提取出来。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-30/21514523.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>迭代器各个型别的意义：<br><code>value type</code> 迭代器所指对象的型别。<br><code>difference_type</code> 两个迭代器之间的距离，也可以用来表示一个容器的最大容量。<br><code>reference</code> 引用类型。<br><code>pointer</code> 指针类型。<br><code>iterator_category</code> 迭代器的分类。<br>迭代器通常分为五类：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input Iterator</td>
<td>不允许外部改变，只读</td>
</tr>
<tr>
<td>Output Iterator</td>
<td>只写</td>
</tr>
<tr>
<td>Forward Iterator</td>
<td>单向移动，可读可写</td>
</tr>
<tr>
<td>Bidirectional Iterator</td>
<td>双向移动，区间内可读可写</td>
</tr>
<tr>
<td>Random Access Iterator</td>
<td>随机访问，涵盖所有指针的算术能力</td>
</tr>
</tbody>
</table>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-30/63413455.jpg" alt=""><br><strong>Traits</strong>编程技法。部分源码剖析，<a href="http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html">参考</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于标记迭代器类型</span></div><div class="line"><span class="keyword">struct</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> output_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> forward_iterator_tag : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> bidirectional_iterator_tag : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> random_access_iterator_tag : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> input_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> input_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                  value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance           difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                 pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                 reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> output_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> forward_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                    value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance             difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                   pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                   reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> bidirectional_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Distance&gt; <span class="keyword">struct</span> random_access_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_NAMESPACES</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Category, <span class="keyword">class</span> T, <span class="keyword">class</span> Distance = <span class="keyword">ptrdiff_t</span>,</div><div class="line">          <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt;</div><div class="line"><span class="keyword">struct</span> iterator &#123;</div><div class="line">  <span class="keyword">typedef</span> Category  iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T         value_type;</div><div class="line">  <span class="keyword">typedef</span> Distance  difference_type;</div><div class="line">  <span class="keyword">typedef</span> Pointer   pointer;</div><div class="line">  <span class="keyword">typedef</span> Reference reference;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_NAMESPACES */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></div><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_traits定义</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line"><span class="comment">// 用于traits出迭代其所指对象的型别</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 迭代器类型, STL提供五种迭代器</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代器所指对象的型别</span></div><div class="line">  <span class="comment">// 如果想与STL算法兼容, 那么在类内需要提供value_type定义</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</div><div class="line"></div><div class="line">  <span class="comment">// 这个是用于处理两个迭代器间距离的类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</div><div class="line"></div><div class="line">  <span class="comment">// 直接指向对象的原生指针类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</div><div class="line"></div><div class="line">  <span class="comment">// 这个是对象的引用类型</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 针对指针提供特化版本</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;T*&gt;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> T*                         pointer;</div><div class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 针对指向常对象的指针提供特化</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;<span class="keyword">const</span> T*&gt;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">  <span class="keyword">typedef</span> T                          value_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_traits支持函数</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// iterator_category(const Iterator&amp;)           返回迭代器类别</span></div><div class="line"><span class="comment">// distance_type(const Iterator&amp;)               返回表示迭代器距离的类型</span></div><div class="line"><span class="comment">// value_type(const Iterator&amp;)                  返回迭代器所指对象的类型</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</div><div class="line"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</div><div class="line">  <span class="keyword">return</span> category();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</div><div class="line"><span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</div><div class="line"><span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子：使用，如一个动物接收机构，不同的动物对应不同的处理，但是对于外界来说只有一个共同的接口，内部不同的动物有不同的方法，用虚函数可以实现，但是用traits编程技巧，也能很好的实现这个需求。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义不同的动物标签</span></div><div class="line"><span class="keyword">struct</span> cat_tag&#123;&#125;;</div><div class="line"><span class="keyword">struct</span> dog_tag&#123;&#125;;</div><div class="line"><span class="comment">//不同的动物类</span></div><div class="line"><span class="keyword">struct</span> dog&#123;</div><div class="line">	<span class="keyword">typedef</span> dog_tag animal_type;<span class="comment">//内嵌动物类型</span></div><div class="line">	<span class="comment">//typedef T value_type;</span></div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> cat &#123;</div><div class="line">	<span class="keyword">typedef</span> cat_tag animal_type;</div><div class="line">	<span class="comment">//typedef T value_type;</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//获取动物类型</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> AnimalTraits &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::animal_type animal_type;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">//不同的动物有不同的处理</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;  <span class="keyword">void</span> _Accept(T dog, dog_tag)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is dog accept..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> _Accept(T cat, cat_tag)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is cat accept..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//提供外部通用的接口</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Accept</span><span class="params">(T animal)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> AnimalTraits&lt;T&gt;::animal_type type;</div><div class="line">	_Accept(animal, type());<span class="comment">//依据类别的临时变量决定调用哪个</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL源码剖析，第三章 迭代器和traits编程技法的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-空间配置器</title>
    <link href="http://abumaster.com/2017/06/24/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://abumaster.com/2017/06/24/STL源码剖析-空间配置器/</id>
    <published>2017-06-24T08:15:31.000Z</published>
    <updated>2017-06-24T11:18:21.109Z</updated>
    
    <content type="html"><![CDATA[<p>《STL 源码剖析》读书笔记，第2章 空间配置器（allocator）。</p>
<a id="more"></a>
<h4 id="空间的配置和释放"><a href="#空间的配置和释放" class="headerlink" title="空间的配置和释放"></a>空间的配置和释放</h4><blockquote>
<p>内存配置 -&gt; 对象构造 -&gt; 对象析构 -&gt; 内存释放</p>
</blockquote>
<p>考虑到小内存块可能造成内存碎片的问题，SGI设计了双层配置器，对于大的内存块直接使用以及配置器，直接调用 <code>malloc()</code> 和 <code>free()</code> 函数，其中定义了内存不足的处理函数机制；而对于较小的内存申请（128 bytes 为界限），使用二级配置器，使用了内存池技术（内存的申请和释放交由内存池管理），可以保证效率和减少内存碎片。两个配置器的使用取决于 <code>__USE__MALLOC</code> 宏的定义。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/43353252.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></div><div class="line">...</div><div class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</div><div class="line"><span class="keyword">typedef</span> malloc_alloc alloc; <span class="comment">// 令 alloc 为第一级配置器</span></div><div class="line"><span class="meta"># <span class="meta-keyword">else</span></span></div><div class="line">...</div><div class="line"><span class="comment">// 令 alloc 为第二级配置器</span></div><div class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span></span></div></pre></td></tr></table></figure></p>
<p>包装一个接口提供给用户使用，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</div><div class="line"><span class="keyword">class</span> simple_alloc &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></div><div class="line">		</span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*)  Alloc::allocate (n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">		</span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></div><div class="line">		</span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></div><div class="line">		</span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="第二级配置器剖析"><a href="#第二级配置器剖析" class="headerlink" title="第二级配置器剖析"></a>第二级配置器剖析</h4><p>规定申请的空间小于 128 bytes 时，使用二级配置器完成。二级配置器由自由链表（free-list）组成。内存需求以8的倍数对齐。16个 <em>free-lists</em> 各自管理大小分别为 8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128 bytes 的小额区块。需要哪个大小直接从链表中调拨。<br><strong>链表结构</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> obj &#123;</div><div class="line">	<span class="keyword">union</span> obj * free_list_link;</div><div class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析：<br>union共用存储空间。<code>free_list_link</code> 指向下一个 obj ；第二个字段，可以看成一个指针，指向了实际的区块。<code>client_data</code> 为数组名称，是数组的首地址，因此是一个指针，指向了obj的地址，即<code>&amp;obj == obj-&gt;client_data</code>。实现了链表结点只使用一个指针的大小空间, 却能同时做索引和指向内存区域。<br><strong>空间配置函数 allocate()</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n must be &gt; 0</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></div><div class="line"></span>&#123;</div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	obj * result;</div><div class="line">	<span class="comment">// 大于128的调用一级配置器</span></div><div class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)</div><div class="line">		<span class="keyword">return</span>(malloc_alloc::allocate(n));	</div><div class="line">	<span class="comment">// 寻找自由链表中的合适的大小</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	result = *my_free_list;</div><div class="line">	<span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 沒找到可用的 free list ，重新填充</span></div><div class="line">		<span class="keyword">void</span> *r = refill(ROUND_UP(n)); <span class="comment">//</span></div><div class="line">		<span class="keyword">return</span> r;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 调整空闲链表</span></div><div class="line">	*my_free_list = result -&gt; free_list_link;</div><div class="line">	<span class="keyword">return</span> (result);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>示意图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/14223605.jpg" alt=""><br><strong>空间释放函数 deallocate()</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 不可以是 0</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></div><div class="line"></span>&#123;</div><div class="line">	obj *q = (obj *)p;</div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	<span class="comment">// 大於 128 请求一级配置器</span></div><div class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</div><div class="line">		malloc_alloc::deallocate(p, n);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 根据大小寻找对应的 free list</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	<span class="comment">// 重新调整 free list ，回收区块进链表</span></div><div class="line">	q -&gt; free_list_link = *my_free_list;</div><div class="line">	*my_free_list = q;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示意图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-24/78747924.jpg" alt=""><br>配置和释放的过程：  </p>
<ul>
<li>根据请求的大小，找到16个free lists中对应的list或者请求一级配置器；  </li>
<li>然后将第一块空闲区返回给用户，没有空闲的可以到内存池中再重新注入一些空闲的数据块。<br><strong>重新填充 free lists</strong><br>分配时，发现free list中没有空闲的区块，则从内存池中填充一部分新区快，默认为20个新区快。内存池中没有那么多也可能会少于20个。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回一个大小为n的对象，恰当时候可以为free list增加新的节点</span></div><div class="line"><span class="comment">//n已经是8的倍数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> nobjs = <span class="number">20</span>;</div><div class="line">	<span class="comment">//从内存池中申请 nobjs 个大小为 n 的对象(n*objs)，chunk指向这块内存</span></div><div class="line">	<span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);<span class="comment">//nobjs为引用参数</span></div><div class="line">	obj * <span class="keyword">volatile</span> * my_free_list;</div><div class="line">	obj * result;</div><div class="line">	obj * current_obj, * next_obj;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="comment">//只得到了一块，那么直接返回，不需要加入free list中了</span></div><div class="line">	<span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</div><div class="line">	<span class="comment">//找到合适的free list</span></div><div class="line">	my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">	result = (obj*)chunk;<span class="comment">//返回的空间</span></div><div class="line">	<span class="comment">//指向下一个空闲块</span></div><div class="line">	*my_free_list = next_obj = (obj *)(chunk + n);</div><div class="line">	<span class="comment">//开始加入free list中</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123; <span class="comment">// 0的已经返回给用户</span></div><div class="line">		current_obj = next_obj;</div><div class="line">		next_obj = (obj *)((<span class="keyword">char</span> *)next_obj + n);</div><div class="line">		<span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;<span class="comment">//最后一个</span></div><div class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">//分成大小n的块，并连成链表</span></div><div class="line">			current_obj -&gt; free_list_link = next_obj;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span>(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>内存池</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </div><div class="line"><span class="keyword">char</span>*  </div><div class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">char</span> * result;  </div><div class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;  </div><div class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;  <span class="comment">// 计算内存池剩余容量  </span></div><div class="line">    <span class="comment">// 如果内存池中剩余内存&gt;=需要分配的内内存, 返回start_free指向的内存块,</span></div><div class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></div><div class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </div><div class="line">        result = start_free;  </div><div class="line">        start_free += total_bytes;  </div><div class="line">        <span class="keyword">return</span>(result);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span></div><div class="line">    <span class="comment">// 返回所能分配的最多的节点, 返回start_free指向的内存块  </span></div><div class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;  </div><div class="line">        nobjs = bytes_left/size;  </div><div class="line">        total_bytes = size * nobjs;  </div><div class="line">        result = start_free;  </div><div class="line">        start_free += total_bytes;  </div><div class="line">        <span class="keyword">return</span>(result);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 内存池剩余内存连一个节点也不够分配  </span></div><div class="line">    <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);  </div><div class="line">        <span class="comment">// 将剩余的内存分配给指定的free_list[FREELIST_INDEX(bytes_left)]  </span></div><div class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </div><div class="line">            obj * __VOLATILE * my_free_list =  </div><div class="line">                        free_list + FREELIST_INDEX(bytes_left);  </div><div class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </div><div class="line">            *my_free_list = (obj *)start_free;  </div><div class="line">        &#125;  </div><div class="line">        start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);  </div><div class="line">        <span class="comment">// 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span></div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;  </div><div class="line">           <span class="keyword">int</span> i;  </div><div class="line">           obj * __VOLATILE * my_free_list, *p;  </div><div class="line">           <span class="comment">//不打算配置较小的内存块</span></div><div class="line">           <span class="comment">//检索在free list中足够大的空闲块 </span></div><div class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </div><div class="line">                my_free_list = free_list + FREELIST_INDEX(i);  </div><div class="line">                p = *my_free_list;  </div><div class="line">                <span class="comment">// 找到了一个, 将其加入内存池中  </span></div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </div><div class="line">                    *my_free_list = p -&gt; free_list_link;  </div><div class="line">                    start_free = (<span class="keyword">char</span> *)p;  </div><div class="line">                    end_free = start_free + i;  </div><div class="line">                    <span class="comment">// 内存池更新完毕, 重新分配需要的内存</span></div><div class="line">                    <span class="comment">//递归调用</span></div><div class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </div><div class="line">                    <span class="comment">// 内存零头被编到了对应free list中  </span></div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助</span></div><div class="line">            <span class="comment">// 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span></div><div class="line">            <span class="comment">// 最好直接log, 然后让程序崩溃  </span></div><div class="line">        end_free = <span class="number">0</span>;   <span class="comment">// In case of exception.  </span></div><div class="line">            start_free = (<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);  </div><div class="line">        &#125;  </div><div class="line">        heap_size += bytes_to_get;  </div><div class="line">        end_free = start_free + bytes_to_get;  </div><div class="line">        <span class="comment">// 内存池更新完毕, 重新分配需要的内存  </span></div><div class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html">参考链接</a>。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《STL 源码剖析》读书笔记，第2章 空间配置器（allocator）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Nginx源码学习-数据结构</title>
    <link href="http://abumaster.com/2017/06/18/Nginx%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/06/18/Nginx源码学习-数据结构/</id>
    <published>2017-06-18T10:29:52.000Z</published>
    <updated>2017-06-20T11:24:52.414Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx源码学习中的数据结构，主要包括数组结构<code>ngx_array_t</code>、链表结构<code>ngx_list_t</code>、队列结构<code>ngx_queue_t</code>、哈希结构<code>ngx_hash_t</code>、字符串结构<code>ngx_string_t</code>。在内存池的基础之上进一步整合组织数据。  </p>
<a id="more"></a>
<h4 id="Nginx数组结构ngx-array-t"><a href="#Nginx数组结构ngx-array-t" class="headerlink" title="Nginx数组结构ngx_array_t"></a>Nginx数组结构ngx_array_t</h4><p>数组结构位于源文件<code>\Src\Core\Ngx_array.h{c}</code>  </p>
<h5 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">void</span>        *elts; <span class="comment">//指向数组空间的起始地址</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>   nelts; <span class="comment">//数组中实际的元素个数</span></div><div class="line">    <span class="keyword">size_t</span>       size; <span class="comment">//数组元素的大小</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>   nalloc; <span class="comment">//实际分配的空间</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>  *pool; <span class="comment">//数组交由此内存池来管理空间</span></div><div class="line">&#125; <span class="keyword">ngx_array_t</span>;<span class="comment">//数组头占用的空间为20字节，头+数据</span></div></pre></td></tr></table></figure>
<p>几种数据结构之间的关系图<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-18/21845022.jpg" alt="">  </p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p><strong>1.一个内联函数</strong><br>功能：在内存池<code>pool</code>上分配一块大小为<code>n*size</code>的空间，并将数组的<code>elts</code>指针指向这个空间的首地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化数组大小为n，参数：数组指针，内存池，数组空间的，每个元素大小</span></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline ngx_int_t</div><div class="line"><span class="title">ngx_array_init</span><span class="params">(<span class="keyword">ngx_array_t</span> *<span class="built_in">array</span>, <span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">/*</div><div class="line">     * set "array-&gt;nelts" before "array-&gt;elts", otherwise MSVC thinks</div><div class="line">     * that "array-&gt;nelts" may be used without having been initialized</div><div class="line">     */</span></div><div class="line"></div><div class="line">    <span class="built_in">array</span>-&gt;nelts = <span class="number">0</span>;<span class="comment">//数组中的元素个数为0</span></div><div class="line">    <span class="built_in">array</span>-&gt;size = size;<span class="comment">//每个元素的大小</span></div><div class="line">    <span class="built_in">array</span>-&gt;nalloc = n;<span class="comment">//分配n个空间，空间大小(n*size)</span></div><div class="line">    <span class="built_in">array</span>-&gt;pool = pool;</div><div class="line">	<span class="comment">//用内存池函数分配一个大小(n*size)的空间并将首地址返回给数组的elts</span></div><div class="line">    <span class="built_in">array</span>-&gt;elts = ngx_palloc(pool, n * size);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//成功初始化数组</span></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2.创建数组</strong><br>功能：提供数组元素的个数并且知道每个元素所占用的空间，在内存池p中创建一个有n个元素的数组。返回数组的指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_array_t</span> *</div><div class="line">ngx_array_create(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_array_t</span> *a;</div><div class="line"><span class="comment">//首先为数组的头分配一个空间，这个数组指针指向的是数组头的起始地址</span></div><div class="line">    a = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="keyword">ngx_array_t</span>));</div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//用内联函数初始化这个数组</span></div><div class="line">    <span class="keyword">if</span> (ngx_array_init(a, p, n, size) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.销毁数组</strong><br>功能：销毁数组实际上没有释放数组占用的内存空间，而是移动首尾指针，这样保证了效率。<br>代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></div><div class="line"><span class="title">ngx_array_destroy</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//数组所用的内存池</span></div><div class="line">    p = a-&gt;pool;</div><div class="line"><span class="comment">//数组不是内存池中的最后一个？还能删除？</span></div><div class="line">    <span class="keyword">if</span> ((u_char *) a-&gt;elts + a-&gt;size * a-&gt;nalloc == p-&gt;d.last) &#123;</div><div class="line">        p-&gt;d.last -= a-&gt;size * a-&gt;nalloc;<span class="comment">//将内存池的指针向前移动</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">//删除数组头</span></div><div class="line">    <span class="keyword">if</span> ((u_char *) a + <span class="keyword">sizeof</span>(<span class="keyword">ngx_array_t</span>) == p-&gt;d.last) &#123;</div><div class="line">        p-&gt;d.last = (u_char *) a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.向数组中插入元素</strong><br>功能：向数组指针a中插入元素，返回插入元素的空间地址
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_array_push</span><span class="params">(<span class="keyword">ngx_array_t</span> *a)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>        *elt, *<span class="keyword">new</span>;</div><div class="line">    <span class="keyword">size_t</span>       size;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//数组中元素已经满了</span></div><div class="line">    <span class="keyword">if</span> (a-&gt;nelts == a-&gt;nalloc) &#123;</div><div class="line">        size = a-&gt;size * a-&gt;nalloc;<span class="comment">//此时数组的占用空间的大小</span></div><div class="line">        p = a-&gt;pool;</div><div class="line">    <span class="comment">//数组后面有多余的空间可以扩展</span></div><div class="line">        <span class="keyword">if</span> ((u_char *) a-&gt;elts + size == p-&gt;d.last</div><div class="line">            &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/*</div><div class="line">             * the array allocation is the last in the pool</div><div class="line">             * and there is space for new allocation</div><div class="line">             */</span></div><div class="line">	<span class="comment">//向后扩展一个元素的空间</span></div><div class="line">            p-&gt;d.last += a-&gt;size;</div><div class="line">            a-&gt;nalloc++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* allocate a new array */</span></div><div class="line">	<span class="comment">//没有多余的空间进行扩展，则重新申请一个数组，大小为当前的2倍</span></div><div class="line">            <span class="keyword">new</span> = ngx_palloc(p, <span class="number">2</span> * size);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">	<span class="comment">//将原数组元素拷贝到新的数组中，并设置新数组的一些参数（老数组没有销毁）</span></div><div class="line">            ngx_memcpy(<span class="keyword">new</span>, a-&gt;elts, size);</div><div class="line">            a-&gt;elts = <span class="keyword">new</span>;</div><div class="line">            a-&gt;nalloc *= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//将指针指向下一个空闲区域</span></div><div class="line">    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;</div><div class="line">    a-&gt;nelts++;</div><div class="line">	<span class="comment">//返回这个空闲空间的指针</span></div><div class="line">    <span class="keyword">return</span> elt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加n个元素<code>void * ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)</code>。  </p>
<h4 id="Nginx链表结构ngx-list-t"><a href="#Nginx链表结构ngx-list-t" class="headerlink" title="Nginx链表结构ngx_list_t"></a>Nginx链表结构ngx_list_t</h4><h5 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_list_part_s  <span class="keyword">ngx_list_part_t</span>;</div><div class="line"><span class="comment">//链表节点结构</span></div><div class="line"><span class="keyword">struct</span> ngx_list_part_s &#123;</div><div class="line">    <span class="keyword">void</span>             *elts;<span class="comment">//实际指向的内存区域大小为size*nalloc</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        nelts;<span class="comment">//元素的个数</span></div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *next;<span class="comment">//下一个节点的地址</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//链表头结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *last;<span class="comment">//指向链表最后一个节点</span></div><div class="line">    <span class="keyword">ngx_list_part_t</span>   part;<span class="comment">//链表头中也有一个节点</span></div><div class="line">    <span class="keyword">size_t</span>            size;<span class="comment">//每个元素的大小</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        nalloc;<span class="comment">//链表包含的空间，实际分配的空间个数</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *pool;<span class="comment">//在此内存池中分配</span></div><div class="line">&#125; <span class="keyword">ngx_list_t</span>;</div></pre></td></tr></table></figure>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-18/25501941.jpg" alt="">  </p>
<h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><p><strong>1.内联函数-链表的初始化</strong><br>功能：初始化链表实体，头结点
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline ngx_int_t</div><div class="line"><span class="title">ngx_list_init</span><span class="params">(<span class="keyword">ngx_list_t</span> *<span class="built_in">list</span>, <span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="built_in">list</span>-&gt;part.elts = ngx_palloc(pool, n * size);<span class="comment">//实际存储空间</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;part.elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">list</span>-&gt;part.nelts = <span class="number">0</span>;<span class="comment">//当前元素个数</span></div><div class="line">    <span class="built_in">list</span>-&gt;part.next = <span class="literal">NULL</span>;<span class="comment">//下一个没有</span></div><div class="line">    <span class="built_in">list</span>-&gt;last = &amp;<span class="built_in">list</span>-&gt;part;<span class="comment">//最后一个指向了自己</span></div><div class="line">    <span class="built_in">list</span>-&gt;size = size;<span class="comment">//大小</span></div><div class="line">    <span class="built_in">list</span>-&gt;nalloc = n;<span class="comment">//元素的个数</span></div><div class="line">    <span class="built_in">list</span>-&gt;pool = pool;<span class="comment">//内存池</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</div><div class="line"> *</div><div class="line"> *  the iteration through the list:</div><div class="line"> *</div><div class="line"> *  part = &amp;list.part;//先获得链表头中的节点</div><div class="line"> *  data = part-&gt;elts;//获得数据的存储区域</div><div class="line"> *</div><div class="line"> *  for (i = 0 ;; i++) &#123;</div><div class="line"> *判断此节点中元素的个数，依次取出</div><div class="line"> *      if (i &gt;= part-&gt;nelts) &#123;</div><div class="line"> *          if (part-&gt;next == NULL) &#123;//无下一个节点则跳出</div><div class="line"> *              break;</div><div class="line"> *          &#125;</div><div class="line"> *取出下一个节点</div><div class="line"> *          part = part-&gt;next;</div><div class="line"> *          data = part-&gt;elts;</div><div class="line"> *          i = 0;</div><div class="line"> *      &#125;</div><div class="line"> *进行此节点中的数据操作</div><div class="line"> *      ...  data[i] ...</div><div class="line"> *</div><div class="line"> *  &#125;</div><div class="line"> */</span></div></pre></td></tr></table></figure></p>
<p><strong>2.创建链表</strong><br>功能：创建一个链表，指定内存池，个数以及每个元素的大小
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_list_t</span> *</div><div class="line">ngx_list_create(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> n, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_list_t</span>  *<span class="built_in">list</span>;</div><div class="line"><span class="comment">//为链表头分配空间大小sizeof(ngx_list_t) = 28B</span></div><div class="line">    <span class="built_in">list</span> = ngx_palloc(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_list_t</span>));</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//调用内联函数进行链表的初始化，包含一个节点的链表头</span></div><div class="line">    <span class="keyword">if</span> (ngx_list_init(<span class="built_in">list</span>, pool, n, size) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//返回此链表头结点</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.添加结点</strong><br>功能：向链表中添加一个元素，返回添加元素数据区的地址
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_list_push</span><span class="params">(<span class="keyword">ngx_list_t</span> *l)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>             *elt;</div><div class="line">    <span class="keyword">ngx_list_part_t</span>  *last;</div><div class="line"><span class="comment">//得到链表中的最后一个节点，在链表的尾部插入新的节点</span></div><div class="line">    last = l-&gt;last;</div><div class="line"><span class="comment">//最后一个节点的元素个数已经满了</span></div><div class="line">    <span class="keyword">if</span> (last-&gt;nelts == l-&gt;nalloc) &#123;</div><div class="line">	<span class="comment">//需要重新创建一个链表节点</span></div><div class="line">        last = ngx_palloc(l-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_list_part_t</span>));</div><div class="line">        <span class="keyword">if</span> (last == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//为节点分配空间</span></div><div class="line">        last-&gt;elts = ngx_palloc(l-&gt;pool, l-&gt;nalloc * l-&gt;size);</div><div class="line">        <span class="keyword">if</span> (last-&gt;elts == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//设置新节点信息</span></div><div class="line">        last-&gt;nelts = <span class="number">0</span>;</div><div class="line">        last-&gt;next = <span class="literal">NULL</span>;</div><div class="line">	<span class="comment">//连接到链表中</span></div><div class="line">        l-&gt;last-&gt;next = last;</div><div class="line">        l-&gt;last = last;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//获得地址</span></div><div class="line">    elt = (<span class="keyword">char</span> *) last-&gt;elts + l-&gt;size * last-&gt;nelts;</div><div class="line">    last-&gt;nelts++;</div><div class="line"><span class="comment">//返回可用存储空间的地址</span></div><div class="line">    <span class="keyword">return</span> elt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.链表设计思路</strong><br>在链表头中设置一些链表节点的信息：<code>last</code>指针用于指向链表的最后一个节点，方便插入元素和数据；<code>part</code>链表头中的结点；<code>size</code>链表中存放元素的大小；<code>nalloc</code>一个节点所占用的空间，可以放元素的个数；<code>pool</code>指定内存池。<br>在链表节点中只存放了指向数据元素存储区的指针<code>elts</code>；当前节点存放的元素个数<code>nelts</code>；以及下一个节点指针<code>next</code>。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/93613137.jpg" alt="">  </p>
<h4 id="Nginx队列结构-ngx-queue-t"><a href="#Nginx队列结构-ngx-queue-t" class="headerlink" title="Nginx队列结构 ngx_queue_t"></a>Nginx队列结构 ngx_queue_t</h4><blockquote>
<p>Nginx 中的队列数据结构是用双向循环链表实现。节点结构为ngx_queue_t。 </p>
</blockquote>
<h5 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_queue_s  <span class="keyword">ngx_queue_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_queue_s &#123;<span class="comment">//队列的结构</span></div><div class="line">    <span class="keyword">ngx_queue_t</span>  *prev;<span class="comment">//前指针</span></div><div class="line">    <span class="keyword">ngx_queue_t</span>  *next;<span class="comment">//后指针</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h5><p>通过定义的一组宏来实现队列的基本操作。  </p>
<p><strong>1.初始化队列</strong><br>初始化头尾指针指向本身。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_init(q)  \</div><div class="line">    (q)-&gt;prev = q;         \</div><div class="line">    (q)-&gt;next = q</span></div></pre></td></tr></table></figure></p>
<p><strong>2.判断队列是否为空</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_empty(h)  \</div><div class="line">    (h == (h)-&gt;prev)</span></div></pre></td></tr></table></figure></p>
<p><strong>3.插入节点</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在头插入</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_insert_head(h, x)                                           \</div><div class="line">    (x)-&gt;next = (h)-&gt;next;                                                    \</div><div class="line">    (x)-&gt;next-&gt;prev = x;                                                      \</div><div class="line">    (x)-&gt;prev = h;                                                            \</div><div class="line">    (h)-&gt;next = x</span></div><div class="line"><span class="comment">//在尾插入</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_insert_tail(h, x)                                           \</div><div class="line">    (x)-&gt;prev = (h)-&gt;prev;                                                    \</div><div class="line">    (x)-&gt;prev-&gt;next = x;                                                      \</div><div class="line">    (x)-&gt;next = h;                                                            \</div><div class="line">    (h)-&gt;prev = x</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/20171048.jpg" alt=""><br><strong>4.访问</strong><br>队列的头结点是固定的，依次链接成了双向链表，进行访问数据。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_head(h)                                                     \</div><div class="line">    (h)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_last(h)                                                     \</div><div class="line">    (h)-&gt;prev</span></div><div class="line"><span class="comment">//哨兵，用于排序</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_sentinel(h)                                                 \</div><div class="line">    (h)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_next(q)                                                     \</div><div class="line">    (q)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_prev(q)                                                     \</div><div class="line">    (q)-&gt;prev</span></div></pre></td></tr></table></figure></p>
<p><strong>5.修改队列</strong><br>删除队列中的节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_remove(x)                                                   \</div><div class="line">    (x)-&gt;next-&gt;prev = (x)-&gt;prev;                                              \</div><div class="line">    (x)-&gt;prev-&gt;next = (x)-&gt;next;                                              \</div><div class="line">    (x)-&gt;prev = NULL;                                                         \</div><div class="line">    (x)-&gt;next = NULL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_remove(x)                                                   \</div><div class="line">    (x)-&gt;next-&gt;prev = (x)-&gt;prev;                                              \</div><div class="line">    (x)-&gt;prev-&gt;next = (x)-&gt;next</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>分割队列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_split(h, q, n)                                              \</div><div class="line">    (n)-&gt;prev = (h)-&gt;prev;                                                    \</div><div class="line">    (n)-&gt;prev-&gt;next = n;                                                      \</div><div class="line">    (n)-&gt;next = q;                                                            \</div><div class="line">    (h)-&gt;prev = (q)-&gt;prev;                                                    \</div><div class="line">    (h)-&gt;prev-&gt;next = h;                                                      \</div><div class="line">    (q)-&gt;prev = n;</span></div></pre></td></tr></table></figure></p>
<p>h为队列头(即链表头指针)，将该队列从q节点将队列(链表)分割为两个队列(链表)，q之后的节点组成的新队列的头节点为n。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-19/10619716.jpg" alt=""><br>合并队列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_add(h, n)                                                   \</div><div class="line">    (h)-&gt;prev-&gt;next = (n)-&gt;next;                                              \</div><div class="line">    (n)-&gt;next-&gt;prev = (h)-&gt;prev;                                              \</div><div class="line">    (h)-&gt;prev = (n)-&gt;prev;                                                    \</div><div class="line">    (h)-&gt;prev-&gt;next = h;</span></div></pre></td></tr></table></figure></p>
<p>两个队列的头结点。最后只保留h头结点。  </p>
<h5 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h5><p>获取队列节点的数据，由队列基本结构和以上操作可知，nginx的队列操作只对链表指针进行简单的修改指向操作，并不负责节点数据空间的分配。<br>因此，用户在使用nginx队列时，要自己定义数据结构并分配空间，且在其中包含一个<code>ngx_queue_t</code>的指针或者对象，当需要获取队列节点数据时，使用<code>ngx_queue_data</code>宏，其定义如下:
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_queue_data(q, type, link)                                         \</div><div class="line">    (type *) ((u_char *) q - offsetof(type, link))</span></div><div class="line"><span class="comment">//其中offsetof，是一个宏，用于计算成员在一个数据结构中的偏移量</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(s, m)   (size_t)&amp;(((s *)0)-&gt;m)</span></div><div class="line"><span class="comment">/*</div><div class="line">s是一个结构名，它有一个名为m的成员（s和m 是宏offsetof的形参，它实际是返回结构s的成员m的偏移地址.</div><div class="line">(s *)0 是骗编译器说有一个指向类（或结构）s的指针，其地址值0 </div><div class="line">&amp;((s *)0)-&gt;m   是要取得类s中成员变量m的地址. 因基址为0，这时m的地址当然就是m在s中的偏移</div><div class="line">最后转换size_t 型，即unsigned int。</div><div class="line"> */</span></div></pre></td></tr></table></figure></p>
<p>由该宏定义可以看出，一般定义队列节点结构(该结构类型为type)时，需要将真正的数据放在前面，而<code>ngx_queue_t</code>结构放在后面，故该宏使用减法计算整个节点结构的起始地址(需要进行类型转换)。  </p>
<p><em>获取队列中的中间元素</em>，奇数则返回中间的，偶数则会返回第二部分的第一个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_queue_t</span> *</div><div class="line">ngx_queue_middle(<span class="keyword">ngx_queue_t</span> *<span class="built_in">queue</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_queue_t</span>  *middle, *next;</div><div class="line"><span class="comment">//队列首元素</span></div><div class="line">    middle = ngx_queue_head(<span class="built_in">queue</span>);</div><div class="line"><span class="comment">//只有一个元素返回</span></div><div class="line">    <span class="keyword">if</span> (middle == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> middle;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//用一个指针记录</span></div><div class="line">    next = ngx_queue_head(<span class="built_in">queue</span>);</div><div class="line"><span class="comment">//两个指针向前移动</span></div><div class="line">    <span class="keyword">for</span> ( ;; ) &#123;</div><div class="line">        middle = ngx_queue_next(middle);</div><div class="line">        next = ngx_queue_next(next);</div><div class="line">        <span class="keyword">if</span> (next == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//next指针向前多移动一次</span></div><div class="line">        next = ngx_queue_next(next);</div><div class="line"><span class="comment">//到了尾返回middle</span></div><div class="line">        <span class="keyword">if</span> (next == ngx_queue_last(<span class="built_in">queue</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找中间位置，两个指针，middle移动一次，next移动两次，当next到达尾时，那么middle指向的是中间位置。  </p>
<p><em>排序</em>，稳定插入排序。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">ngx_queue_sort(ngx_queue_t *queue,</div><div class="line">    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *))</div><div class="line">&#123;</div><div class="line">    ngx_queue_t  *q, *prev, *next;</div><div class="line">//获得第一个元素</div><div class="line">    q = ngx_queue_head(queue);</div><div class="line">    if (q == ngx_queue_last(queue)) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">//获得下一个节点</div><div class="line">    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) &#123;</div><div class="line">//</div><div class="line">        prev = ngx_queue_prev(q);</div><div class="line">        next = ngx_queue_next(q);</div><div class="line">//</div><div class="line">        ngx_queue_remove(q);</div><div class="line">//</div><div class="line">        do &#123;</div><div class="line">            if (cmp(prev, q) &lt;= 0) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">//</div><div class="line">            prev = ngx_queue_prev(prev);</div><div class="line">//</div><div class="line">        &#125; while (prev != ngx_queue_sentinel(queue));</div><div class="line">//插入</div><div class="line">        ngx_queue_insert_after(prev, q);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Nginx哈希数据结构"><a href="#Nginx哈希数据结构" class="headerlink" title="Nginx哈希数据结构"></a>Nginx哈希数据结构</h4><p>哈希表是用于（key-value）对应的一种关系，为了直接由key来计算出value，需要构建一个哈希函数，并想方设法去避免冲突，尽量保证键值对的唯一性。<br>讲解详细的博文<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html">链接1</a>和<a href="http://www.nowamagic.net/academy/detail/3008088">链接2</a>。  </p>
<h5 id="hash-结构"><a href="#hash-结构" class="headerlink" title="hash 结构"></a>hash 结构</h5><p><strong>1.ngx_hash_t结构</strong><br>Nginx中的哈希结构为<code>ngx_hash_t</code>以及元素结构<code>ngx_hash_elt_t</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash元素结构</span></div><div class="line">    <span class="keyword">void</span>             *value; <span class="comment">//key对应的值(key, value)中的key</span></div><div class="line">    u_short           len; <span class="comment">//name长度</span></div><div class="line">    u_char            name[<span class="number">1</span>];<span class="comment">//要hash的数据，(key, value)中的key</span></div><div class="line">&#125; <span class="keyword">ngx_hash_elt_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash结构</span></div><div class="line">    <span class="keyword">ngx_hash_elt_t</span>  **buckets;<span class="comment">//哈希桶</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        size;<span class="comment">//哈希桶的个数</span></div><div class="line">&#125; <span class="keyword">ngx_hash_t</span>;</div></pre></td></tr></table></figure></p>
<p><strong>2.ngx_hash_init_t结构</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hash计算函数指针</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ngx_uint_t</span> <span class="params">(*ngx_hash_key_pt)</span> <span class="params">(u_char *data, <span class="keyword">size_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">//hash初始化结构</span></div><div class="line">    <span class="keyword">ngx_hash_t</span>       *hash;<span class="comment">//指向待初始化的hash结构</span></div><div class="line">    ngx_hash_key_pt   key;<span class="comment">//hash函数指针</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        max_size;<span class="comment">//bucket的最大个数</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>        bucket_size;<span class="comment">//每个bucket占用的空间</span></div><div class="line">    <span class="keyword">char</span>             *name;<span class="comment">//该hash结构的名字</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *pool;<span class="comment">//所需空间的由此内存池接管</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>       *temp_pool;<span class="comment">//临时文件</span></div><div class="line">&#125; <span class="keyword">ngx_hash_init_t</span>;</div></pre></td></tr></table></figure></p>
<p>通常是作为参数传递给<code>ngx_hash_init</code>函数。<br><strong>3.ngx_hash_key_t</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;  <span class="comment">//hash key结构  </span></div><div class="line">    <span class="keyword">ngx_str_t</span>         key;   <span class="comment">//key，为nginx的字符串结构  </span></div><div class="line">    <span class="keyword">ngx_uint_t</span>  key_hash; <span class="comment">//由该key计算出的hash值(通过hash函数)  </span></div><div class="line">    <span class="keyword">void</span>    *value;  <span class="comment">//该key对应的值，组成一个键-值对&lt;key,value&gt;  </span></div><div class="line">&#125; <span class="keyword">ngx_hash_key_t</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;                    <span class="comment">//字符串结构  </span></div><div class="line">    <span class="keyword">size_t</span>      len;                <span class="comment">//字符串长度  </span></div><div class="line">    u_char     *data;               <span class="comment">//字符串内容  </span></div><div class="line">&#125; <span class="keyword">ngx_str_t</span>;</div></pre></td></tr></table></figure></p>
<p>该结构也主要用来保存要hash的数据，即键-值对<key,value>，在实际使用中，一般将多个键-值对保存在<code>ngx_hash_key_t</code>结构的数组中，作为参数传给<code>ngx_hash_init()</code>或<code>ngx_hash_wildcard_init()</code>函数。<br><strong>哈希结构的内存布局：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-20/23126191.jpg" alt="">  </p>
<center><a href="https://code.google.com/archive/p/nginxsrp/wikis/NginxCodeReview.wiki">图片来源 Google Code</a></center>  

<h5 id="hash-操作"><a href="#hash-操作" class="headerlink" title="hash 操作"></a>hash 操作</h5><p><strong>1.计算ngx_hash_elt_t的大小</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//name为ngx_hash_key_t</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HASH_ELT_SIZE(name)                                               \</div><div class="line">    (sizeof(void *) + ngx_align((name)-&gt;key.len + 2, sizeof(void *)))</span></div></pre></td></tr></table></figure></p>
<p><code>sizeof(void *)=4B</code>,4字节对齐。<br><strong>2.hash函数</strong><br>hash函数提供了几种计算hash的方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_hash(key, c)   ((ngx_uint_t) key * 31 + c)</span></div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_key(u_char *data, <span class="keyword">size_t</span> len);</div><div class="line"><span class="comment">//lc表示lower case，即字符串转换为小写后再计算hash值  </span></div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_key_lc(u_char *data, <span class="keyword">size_t</span> len);</div><div class="line"><span class="keyword">ngx_uint_t</span> ngx_hash_strlow(u_char *dst, u_char *src, <span class="keyword">size_t</span> n);</div><div class="line"><span class="comment">//如：</span></div><div class="line"><span class="keyword">ngx_uint_t</span></div><div class="line">ngx_hash_key(u_char *data, <span class="keyword">size_t</span> len)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_uint_t</span>  i, key;</div><div class="line"></div><div class="line">    key = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        key = ngx_hash(key, data[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> key;</div><div class="line">&#125;</div><div class="line"><span class="comment">//相当于：</span></div><div class="line"><span class="comment">/*</div><div class="line">Key[0] = data[0]  </div><div class="line">Key[1] = data[0]*31 + data[1]  </div><div class="line">Key[2] = (data[0]*31 + data[1])*31 + data[2]  </div><div class="line">...  </div><div class="line">Key[len-1] = ((((data[0]*31 + data[1])*31 + data[2])*31) ... data[len-2])*31 + data[len-1] </div><div class="line"> */</span></div><div class="line"><span class="comment">//key[len-1]即为传入的参数data对应的hash值。</span></div></pre></td></tr></table></figure></p>
<p><strong>3.hash初始化</strong><br>hash的初始化是用<code>ngx_hash_init</code>完成，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hinit hash结构指针；names 为ngx_hash_key_t结构数组；nelts为数组中元素个数</span></div><div class="line"><span class="comment">/*</div><div class="line">该函数初始化的结果就是将names数组保存的键-值对&lt;key,value&gt;，</div><div class="line">通过hash的方式将其存入相应的一个或多个hash桶(即代码中的buckets)中，</div><div class="line">该hash过程用到的hash函数一般为ngx_hash_key_lc等。</div><div class="line">hash桶里面存放的是ngx_hash_elt_t结构的指针(hash元素指针)，该指针指向一个基本连续的数据区。</div><div class="line">该数据区中存放的是经hash之后的键-值对&lt;key',value'&gt;，即ngx_hash_elt_t结构中的字段&lt;name,value&gt;。</div><div class="line">每一个这样的数据区存放的键-值对&lt;key',value'&gt;可以是一个或多个。</div><div class="line"> */</span></div><div class="line"></div><div class="line"><span class="keyword">ngx_int_t</span></div><div class="line">ngx_hash_init(<span class="keyword">ngx_hash_init_t</span> *hinit, <span class="keyword">ngx_hash_key_t</span> *names, <span class="keyword">ngx_uint_t</span> nelts)</div><div class="line">&#123;</div><div class="line">    u_char          *elts;</div><div class="line">    <span class="keyword">size_t</span>           len;</div><div class="line">    u_short         *test;</div><div class="line">    <span class="keyword">ngx_uint_t</span>       i, n, key, size, start, bucket_size;</div><div class="line">    <span class="keyword">ngx_hash_elt_t</span>  *elt, **buckets;</div><div class="line"><span class="comment">//允许的hash桶的最大数量为0，错误</span></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;max_size == <span class="number">0</span>) &#123;</div><div class="line">        ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                      <span class="string">"could not build %s, you should "</span></div><div class="line">                      <span class="string">"increase %s_max_size: %i"</span>,</div><div class="line">                      hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size);</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//对于数组中的每个元素，如果hash元素大小大于桶的容量，出错</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (hinit-&gt;bucket_size &lt; NGX_HASH_ELT_SIZE(&amp;names[n]) + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))</div><div class="line">        &#123;</div><div class="line">            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"could not build %s, you should "</span></div><div class="line">                          <span class="string">"increase %s_bucket_size: %i"</span>,</div><div class="line">                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//分配一块2*max_size大小的空间，没有在内存池上分配，只是临时的</span></div><div class="line">    test = ngx_alloc(hinit-&gt;max_size * <span class="keyword">sizeof</span>(u_short), hinit-&gt;pool-&gt;<span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (test == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//桶的大小减去4字节</span></div><div class="line">    bucket_size = hinit-&gt;bucket_size - <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line"><span class="comment">//确定起始位置</span></div><div class="line">    start = nelts / (bucket_size / (<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    start = start ? start : <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;max_size &gt; <span class="number">10000</span> &amp;&amp; nelts &amp;&amp; hinit-&gt;max_size / nelts &lt; <span class="number">100</span>) &#123;</div><div class="line">        start = hinit-&gt;max_size - <span class="number">1000</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (size = start; size &lt;= hinit-&gt;max_size; size++) &#123;</div><div class="line"></div><div class="line">        ngx_memzero(test, size * <span class="keyword">sizeof</span>(u_short));</div><div class="line"><span class="comment">//标记1：此块代码是检查bucket大小是否够分配hash数据</span></div><div class="line">        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">            <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"><span class="comment">//计算key和names中所有name长度，并保存在test[key]中</span></div><div class="line">            key = names[n].key_hash % size;</div><div class="line">            test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: %ui %ui \"%V\""</span>,</div><div class="line">                          size, key, test[key], &amp;names[n].key);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (test[key] &gt; (u_short) bucket_size) &#123;</div><div class="line">                <span class="keyword">goto</span> next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">goto</span> found;</div><div class="line"></div><div class="line">    next:</div><div class="line"></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size = hinit-&gt;max_size;</div><div class="line"></div><div class="line">    ngx_log_error(NGX_LOG_WARN, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                  <span class="string">"could not build optimal %s, you should increase "</span></div><div class="line">                  <span class="string">"either %s_max_size: %i or %s_bucket_size: %i; "</span></div><div class="line">                  <span class="string">"ignoring %s_bucket_size"</span>,</div><div class="line">                  hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size,</div><div class="line">                  hinit-&gt;name, hinit-&gt;bucket_size, hinit-&gt;name);</div><div class="line"></div><div class="line">found:<span class="comment">//找到</span></div><div class="line"><span class="comment">//test[i]初始化为4</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        test[i] = <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">    &#125;</div><div class="line"> <span class="comment">/** </div><div class="line">  * 标记2：与标记1代码基本相同，但此块代码是再次计算所有hash数据的总长度(标记1的检查已通过)</div><div class="line">  但此处的test[i]已被初始化为4，即相当于后续的计算再加上一个void指针的大小。</div><div class="line">  */</span></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        key = names[n].key_hash % size;</div><div class="line">        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (test[i] == <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//对test[i]按ngx_cacheline_size对齐(32位平台，ngx_cacheline_size=32)  </span></div><div class="line">        test[i] = (u_short) (ngx_align(test[i], ngx_cacheline_size));</div><div class="line">        len += test[i];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//在内存池中分配hash头及buckets数组(size个ngx_hash_elt_t*结构)</span></div><div class="line">    <span class="keyword">if</span> (hinit-&gt;hash == <span class="literal">NULL</span>) &#123;</div><div class="line">        hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_wildcard_t</span>)</div><div class="line">                                             + size * <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_elt_t</span> *));</div><div class="line">        <span class="keyword">if</span> (hinit-&gt;hash == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_free(test);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buckets = (<span class="keyword">ngx_hash_elt_t</span> **)</div><div class="line">                      ((u_char *) hinit-&gt;hash + <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_wildcard_t</span>));</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buckets = ngx_pcalloc(hinit-&gt;pool, size * <span class="keyword">sizeof</span>(<span class="keyword">ngx_hash_elt_t</span> *));</div><div class="line">        <span class="keyword">if</span> (buckets == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_free(test);</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    elts = ngx_palloc(hinit-&gt;pool, len + ngx_cacheline_size);</div><div class="line">    <span class="keyword">if</span> (elts == <span class="literal">NULL</span>) &#123;</div><div class="line">        ngx_free(test);</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    elts = ngx_align_ptr(elts, ngx_cacheline_size);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (test[i] == <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buckets[i] = (<span class="keyword">ngx_hash_elt_t</span> *) elts;</div><div class="line">        elts += test[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        test[i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nelts; n++) &#123;</div><div class="line">        <span class="keyword">if</span> (names[n].key.data == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        key = names[n].key_hash % size;</div><div class="line">        elt = (<span class="keyword">ngx_hash_elt_t</span> *) ((u_char *) buckets[key] + test[key]);</div><div class="line"></div><div class="line">        elt-&gt;value = names[n].value;</div><div class="line">        elt-&gt;len = (u_short) names[n].key.len;</div><div class="line"></div><div class="line">        ngx_strlow(elt-&gt;name, names[n].key.data, names[n].key.len);</div><div class="line"></div><div class="line">        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (buckets[i] == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        elt = (<span class="keyword">ngx_hash_elt_t</span> *) ((u_char *) buckets[i] + test[i]);</div><div class="line"></div><div class="line">        elt-&gt;value = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngx_free(test);</div><div class="line"></div><div class="line">    hinit-&gt;hash-&gt;buckets = buckets;</div><div class="line">    hinit-&gt;hash-&gt;size = size;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">ngx_str_t</span>   val;</div><div class="line">        <span class="keyword">ngx_uint_t</span>  key;</div><div class="line"></div><div class="line">        elt = buckets[i];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (elt == <span class="literal">NULL</span>) &#123;</div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: NULL"</span>, i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (elt-&gt;value) &#123;</div><div class="line">            val.len = elt-&gt;len;</div><div class="line">            val.data = &amp;elt-&gt;name[<span class="number">0</span>];</div><div class="line"></div><div class="line">            key = hinit-&gt;key(val.data, val.len);</div><div class="line"></div><div class="line">            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                          <span class="string">"%ui: %p \"%V\" %ui"</span>, i, elt, &amp;val, key);</div><div class="line"></div><div class="line">            elt = (<span class="keyword">ngx_hash_elt_t</span> *) ngx_align_ptr(&amp;elt-&gt;name[<span class="number">0</span>] + elt-&gt;len,</div><div class="line">                                                   <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>常用的有创建 hash 和在 hash 中进行查找两个操作，对于创建hash的操作,过程一般为：  </p>
<ul>
<li>构造一个 <code>ngx_hash_key_t</code> 为成员的数组， 包含 key, value 和 使用key计算出的一个hash值  </li>
<li>构建一个 <code>ngx_hash_init_t</code> 结构体的变量， 其中包含了 <code>ngx_hash_t</code> 的成员， 为hash的结构体， 还包括一些其他初始设置，如bucket的大小，内存池等   </li>
<li>调用 <code>ngx_hash_init</code> 传入 <code>ngx_hash_init_t</code> 结构， <code>ngx_hash_key_t</code> 的数组，和数组的长度， 进行初始化，这样 <code>ngx_hash_init_t</code>的hash成员就是我们要的hash结构  </li>
</ul>
<p>查找的过程很简单</p>
<ul>
<li>计算 key 的hash值  </li>
<li>使用 <code>ngx_hash_find</code> 进行查找，需要同时传入 hash值和key ,返回的就是value的指针
需要注意的是，nginx 的 hash 在查找时使用的是分桶后线性查找法，因此当分桶数确定时查找效率同其中的总 key-val 对数量成反比。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx源码学习中的数据结构，主要包括数组结构&lt;code&gt;ngx_array_t&lt;/code&gt;、链表结构&lt;code&gt;ngx_list_t&lt;/code&gt;、队列结构&lt;code&gt;ngx_queue_t&lt;/code&gt;、哈希结构&lt;code&gt;ngx_hash_t&lt;/code&gt;、字符串结构&lt;code&gt;ngx_string_t&lt;/code&gt;。在内存池的基础之上进一步整合组织数据。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>笔记：虚函数实现机制</title>
    <link href="http://abumaster.com/2017/06/10/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://abumaster.com/2017/06/10/笔记：虚函数实现机制/</id>
    <published>2017-06-10T15:26:43.000Z</published>
    <updated>2017-06-11T00:20:28.488Z</updated>
    
    <content type="html"><![CDATA[<p>C++的虚函数是实现多态的一种方法，那么它的实现机制如何，笔记记录如下。  </p>
<a id="more"></a>
<p>虚函数的实现机制就是：虚表和虚指针。虚函数在运行期间来确定类型，即动态绑定，而构造函数在构造对象的时候就应该知道类型，这也是构造函数不能声明为虚函数的原因。<br>先看一个例子，假设两个类A和B：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://ooo.0o0.ooo/2017/06/11/593c8c1a67649.png" alt="">  </p>
<p>虚函数地址的获得<br><code>A *p = new B;</code><br>p:是个指针。<br><code>(int *)p</code>：转换成 int 类型的指针<br><code>*(int *)p</code>：把转换成int 类型指针p 的内容取出<br><code>(int *)( *(int *)p)</code>：在转换成 int 类型的指针<br><code>(int *)( *(int *)p) +0</code>：取出第一个元素的地址<br><code>*((int *)( *(int *)p) +0)</code>：得到第一个元素的内容<br><code>(void *)(*((int *)( *(int *)p) +0))</code>：得到第一个元素的地址  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++的虚函数是实现多态的一种方法，那么它的实现机制如何，笔记记录如下。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx源码学习-内存池</title>
    <link href="http://abumaster.com/2017/06/08/Nginx%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <id>http://abumaster.com/2017/06/08/Nginx源码学习-内存池/</id>
    <published>2017-06-08T08:45:30.000Z</published>
    <updated>2017-06-09T08:40:44.377Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Nginx</strong> 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占用内存少，并发能力强。其编写简洁高效，有诸多学习之处。</p>
<a id="more"></a>
<div class="note info"><p>C/C++ 的内存管理，往往让人头痛。要时刻注意分配足够的内存，并在不用的时候记得释放内存，直接使用系统调用 <code>malloc/free, new/delete</code> 会有如下的一些弊端：  </p>
<ul>
<li>系统调用时根据最先匹配、最优匹配原则，有时会合并，产生额外的开销；  </li>
<li>频繁使用，会产生大量的内存碎片，降低程序运行速度；  </li>
<li>稍有不慎容易造成内存泄漏。  </li>
</ul>
<p><strong>内存池（memory pool）</strong>的出现代替了直接的系统调用。它是首先向系统申请足够大的空间，当需要时向内存池申请，而不是来进行系统调用，使用内存池可以对应解决以上的缺陷。  </p>
</div>  
<h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><p><em>注：Nginx源码中用 xx_xx_t 来表示type；用 xx_xx_s 表示struct。</em><br>在源码 <code>/Src/Core/Ngx_palloc.h{c}</code> 中<br><strong>内存池数据块类型 ngx_pool_data_t</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    u_char               *last;<span class="comment">//指向已用的数据结尾</span></div><div class="line">    u_char               *end;<span class="comment">//指向存储空间结尾(内存池结束位置)</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>           *next;<span class="comment">//下一个内存块</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>            failed;<span class="comment">//内存池分配错误次数</span></div><div class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</div></pre></td></tr></table></figure></p>
<p><strong>内存池头部结构 ngx_pool_s</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ngx_pool_s &#123;</div><div class="line">    <span class="keyword">ngx_pool_data_t</span>       d; <span class="comment">//内存池数据块</span></div><div class="line">    <span class="keyword">size_t</span>                max; <span class="comment">//内存池数据块的最大值</span></div><div class="line">    <span class="keyword">ngx_pool_t</span>           *current; <span class="comment">//指向当前的内存池</span></div><div class="line">    <span class="keyword">ngx_chain_t</span>          *chain;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>     *large; <span class="comment">//指向大块内存</span></div><div class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup; <span class="comment">//释放内存时的回调函数</span></div><div class="line">    <span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>; <span class="comment">//日志信息</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_s 	<span class="keyword">ngx_pool_t</span>;</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-8/29000766.jpg" alt="">  </p>
<h4 id="内存池的基本操作"><a href="#内存池的基本操作" class="headerlink" title="内存池的基本操作"></a>内存池的基本操作</h4><p>内存池对外提供的函数如下：  </p>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建内存池</td>
<td><code>ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);</code></td>
</tr>
<tr>
<td>销毁内存池</td>
<td><code>void ngx_destroy_pool(ngx_pool_t *pool);</code></td>
</tr>
<tr>
<td>重置内存池</td>
<td><code>void ngx_reset_pool(ngx_pool_t *pool);</code></td>
</tr>
<tr>
<td>内存申请（对齐）</td>
<td><code>void *ngx_palloc(ngx_pool_t *pool, size_t size);</code></td>
</tr>
<tr>
<td>内存申请（不对齐）</td>
<td><code>void *ngx_pnalloc(ngx_pool_t *pool, size_t size);</code></td>
</tr>
<tr>
<td>内存申请并且置为0</td>
<td><code>void *ngx_pcalloc(ngx_pool_t *pool, size_t size);</code></td>
</tr>
<tr>
<td>内存清除</td>
<td><code>ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);</code></td>
</tr>
</tbody>
</table>
<h5 id="封装的系统调用"><a href="#封装的系统调用" class="headerlink" title="封装的系统调用"></a>封装的系统调用</h5><p>两个函数 <code>ngx_alloc</code> 和 <code>ngx_calloc</code> 对系统调用 <code>malloc</code> 进行封装。源码<code>./src/Os/Unix（Win32）/ngx_alloc.h/.c</code>。<br>调用malloc申请内存。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>  *p;</div><div class="line"></div><div class="line">    p = <span class="built_in">malloc</span>(size);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</div><div class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</div><div class="line">                      <span class="string">"malloc(%uz) failed"</span>, size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"malloc: %p:%uz"</span>, p, size);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>申请内存并且置0
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></div><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_calloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>  *p;</div><div class="line"></div><div class="line">    p = ngx_alloc(size, <span class="built_in">log</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p) &#123;</div><div class="line">        ngx_memzero(p, size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="内存池的创建"><a href="#内存池的创建" class="headerlink" title="内存池的创建"></a>内存池的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_pool_t</span> *</div><div class="line">ngx_create_pool(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"><span class="comment">//申请内存并对齐</span></div><div class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//sizeof(ngx_pool_t) = 40B	sizeof(ngx_pool_data_t) = 16B</span></div><div class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);<span class="comment">//指针设置到跳过内存池的头结构</span></div><div class="line">    p-&gt;d.end = (u_char *) p + size;<span class="comment">//内存池的结尾</span></div><div class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;d.failed = <span class="number">0</span>;</div><div class="line"><span class="comment">//可用的最大字节数</span></div><div class="line">    size = size - <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</div><div class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</div><div class="line"><span class="comment">//其他的一些设置</span></div><div class="line">    p-&gt;current = p;</div><div class="line">    p-&gt;chain = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;large = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</div><div class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"><span class="comment">//它调用了系统函数</span></div><div class="line"><span class="comment">/*</div><div class="line">函数：void * memalign (size_t boundary, size_t size) </div><div class="line">函数memalign将分配一个由size指定大小，地址是boundary的倍数的内存块。</div><div class="line">参数boundary必须是2的幂！函数memalign可以分配较大的内存块，并且可以为返回的地址指定粒度。</div><div class="line">*/</span></div></pre></td></tr></table></figure>
<p>nginx对内存的管理分为大内存与小内存，当某一个申请的内存大于某一个值时，就需要从大内存中分配空间，否则从小内存中分配空间。<br>nginx中的内存池是在创建的时候就设定好了大小，在以后分配小块内存的时候，如果内存不够，则是重新创建一块内存串到内存池中，而不是将原有的内存池进行扩张。当要分配大块内存是，则是在内存池外面再分配空间进行管理的，称为大块内存池。  </p>
<h5 id="内存的申请"><a href="#内存的申请" class="headerlink" title="内存的申请"></a>内存的申请</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !(NGX_DEBUG_PALLOC)</span></div><div class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;<span class="comment">//申请的空间小于内存池的最大空间</span></div><div class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//申请小内存</span></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></div><div class="line"></span>&#123;</div><div class="line">    u_char      *m;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p;</div><div class="line"></div><div class="line">    p = pool-&gt;current;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        m = p-&gt;d.last;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (align) &#123;</div><div class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</div><div class="line">        &#125;<span class="comment">//是否需要对齐，需要则按NGX_ALIGNMENT对齐</span></div><div class="line">	</div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</div><div class="line">        	<span class="comment">//未使用的空间大于申请的，则不需要链接新的内存块了</span></div><div class="line">            p-&gt;d.last = m + size;<span class="comment">//移动使用空间末尾指针</span></div><div class="line">            <span class="keyword">return</span> m;<span class="comment">//返回新申请空间开始的指针(m, m+size)空间</span></div><div class="line">        &#125;</div><div class="line">		<span class="comment">//空间不够向链表的下一个节点查询</span></div><div class="line">        p = p-&gt;d.next;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">while</span> (p);</div><div class="line">    <span class="comment">//遍历完还是没有找到，那么再申请</span></div><div class="line">    <span class="keyword">return</span> ngx_palloc_block(pool, size);</div><div class="line">&#125;</div><div class="line"><span class="comment">//内存对齐</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                   \</div><div class="line">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    u_char      *m;</div><div class="line">    <span class="keyword">size_t</span>       psize;</div><div class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>;</div><div class="line"><span class="comment">//计算第一块的大小</span></div><div class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</div><div class="line"><span class="comment">//申请与第一块内存相同大小的空间并用m指向</span></div><div class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//新的内存块，变为内存池类型</span></div><div class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</div><div class="line"><span class="comment">//初始化其中的数据</span></div><div class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</div><div class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</div><div class="line"><span class="comment">//申请内存的结尾设置</span></div><div class="line">    m += <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_data_t</span>);</div><div class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</div><div class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</div><div class="line"><span class="comment">//将新的内存块连接到内存池链表中</span></div><div class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</div><div class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</div><div class="line">            pool-&gt;current = p-&gt;d.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    p-&gt;d.next = <span class="keyword">new</span>;</div><div class="line"><span class="comment">//返回size大小的内存的起始指针(m, m+size)空间</span></div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于申请小的内存（申请大小 &lt; 设定的内存池数据块大小），基本流程就是，在内存池的链表中找空闲的内存，不满足条件的话再创建新的内存块并连接到内存池链表中，注意在内存池中申请内存，只是<strong>控制移动指针</strong>而已，这时注意字节的对齐，保证读写的高效。  </p>
<p><strong>大内存块的申请</strong><br>应用场景：当申请的内存比设置内存块大小大的时候，不能通过链接内存块的方法申请内存，这时需要申请大块内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//大块内存的结构，类似于一个链表，alloc指向实际的内存</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_large_s  <span class="keyword">ngx_pool_large_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_pool_large_s &#123;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>     *next;</div><div class="line">    <span class="keyword">void</span>                 *alloc;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line"><span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">void</span>              *p;</div><div class="line">    <span class="keyword">ngx_uint_t</span>         n;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</div><div class="line"><span class="comment">//直接调用申请size大小的空间，p指向</span></div><div class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    n = <span class="number">0</span>;</div><div class="line"><span class="comment">//在大内存块链表中查找空的large</span></div><div class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</div><div class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</div><div class="line">            large-&gt;alloc = p;</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;<span class="comment">//为了效率，查找3次没有找到跳出</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//重新分配一块large sizeof(ngx_pool_large_t) = 8B</span></div><div class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</div><div class="line">        ngx_free(p);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//链接（插入）到链表的头</span></div><div class="line">    large-&gt;alloc = p;</div><div class="line">    large-&gt;next = pool-&gt;large;</div><div class="line">    pool-&gt;large = large;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-9/75412545.jpg" alt=""><br>过程：在已经有的大块内存中查找 <code>large-&gt;alloc == NULL</code> 的节点，不存在则会新建一个 <code>ngx_pool_large_s</code> 的节点，插入大块内存链表的头，并且使 <code>large-&gt;alloc == new</code>。  </p>
<h5 id="内存池的重置和清理"><a href="#内存池的重置和清理" class="headerlink" title="内存池的重置和清理"></a>内存池的重置和清理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></div><div class="line"><span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">ngx_pool_t</span>        *p;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</div><div class="line"><span class="comment">//重置所有大块内存区</span></div><div class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</div><div class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</div><div class="line">            ngx_free(l-&gt;alloc);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//重置所有小块内存区</span></div><div class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</div><div class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</div><div class="line">        p-&gt;d.failed = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pool-&gt;current = pool;</div><div class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</div><div class="line">    pool-&gt;large = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">ngx_int_t</span></div><div class="line">ngx_pfree(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</div><div class="line"><span class="comment">//只针对大内存进行释放</span></div><div class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</div><div class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</div><div class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">                           <span class="string">"free: %p"</span>, l-&gt;alloc);</div><div class="line">            ngx_free(l-&gt;alloc);</div><div class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> NGX_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_DECLINED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在使用内存池时，可以使用<code>ngx_palloc</code>进行分配，使用<code>ngx_pfree</code>释放。而对于大内存，这样做是没有问题的，而对于小内存就不一样了，分配的小内存，不会进行释放。因为大内存块的分配只对前3个内存块进行检查，否则就直接分配内存，所以大内存块的释放必须及时。<br><code>void ngx_destroy_pool(ngx_pool_t *pool)</code> 函数是用于完全释放内存池中申请的空间。  </p>
<p>Nginx内存池支持通过回调函数，对外部资源的清理。<code>ngx_pool_cleanup_t</code>是回调函数结构体，它在内存池中以链表形式保存，在内存池进行销毁时，循环调用这些回调函数对数据进行清理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ngx_pool_cleanup_s  <span class="keyword">ngx_pool_cleanup_t</span>;</div><div class="line"><span class="keyword">struct</span> ngx_pool_cleanup_s &#123;</div><div class="line">    ngx_pool_cleanup_pt   handler;</div><div class="line">    <span class="keyword">void</span>                 *data;</div><div class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-6-9/40148825.jpg" alt="">   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt; 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占用内存少，并发能力强。其编写简洁高效，有诸多学习之处。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-网络IPC</title>
    <link href="http://abumaster.com/2017/06/05/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9CIPC/"/>
    <id>http://abumaster.com/2017/06/05/UNIX环境高级编程-网络IPC/</id>
    <published>2017-06-05T02:34:09.000Z</published>
    <updated>2017-06-07T02:37:54.501Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程， 第16章 网络IPC：套接字 读书笔记。不同计算机进行通信的机制。</p>
<a id="more"></a>
<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p><strong>套接字</strong> 是通信端点的对象，也有套接字描述符，类似于文件描述符，许多操作也可以直接应用到套接字描述符上。创建一个套接字：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line"><span class="comment">//成功返回套接字描述符，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p>参数说明：<br><em>domain</em> 确定通信的特性，通常有 <code>AF_INET</code> 最常用，表示IPv4因特网域。<br><em>type</em> 套接字类型，tcp和udp的通信协议分别对应 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code> ，面向连接的字节流和面向无连接的报文。<br><em>protocol</em> 通常为零，默认协议。  </p>
<p>关闭套接字：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</div></pre></td></tr></table></figure></p>
<p><em>how</em> 的类别决定关闭的方式：  </p>
<ul>
<li>SHUT_RD 关闭读端，无法从套接字读取数据；  </li>
<li>SHUT_WR 关闭写端，无法向套接字写数据；  </li>
<li>SHUT_RDWR 同时关闭读写，无法向套接字读写数据。  </li>
</ul>
<p>有 <code>close</code> 为何还要用 <code>shutdown</code> 这是因为：<code>close</code> 的调用是在最后一个活动关闭时才释放，而 <code>shutdown</code> 可以使套接字处于非活动状态，不用关心引用的多少；同时，也可以关闭一端。  </p>
<h4 id="关于地址"><a href="#关于地址" class="headerlink" title="关于地址"></a>关于地址</h4><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>字节序是处理器的架构特性，指示像整数这样的大数据类型的内部字节顺序。分为<em>大端字节序（big-endian）</em>和<em>小端模式（little-endian）</em>。<br>TCP/IP协议使用的是大端字节序，异构计算机可以直接进行通信，不会混淆。字节序的转换可以在本地计算机上完成，常用到的函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);<span class="comment">//返回以网络字节序表示的32位整数</span></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);<span class="comment">//返回以网络字节序表示的16位整数</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netint32);<span class="comment">//返回以主机字节序表示的32位整数</span></div><div class="line"><span class="keyword">uint32_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);<span class="comment">//返回以主机字节序表示的16位整数</span></div></pre></td></tr></table></figure></p>
<p>大端：低地址放着高位数据，高地址放着低位数据。<br>小端：低地址放着低位数据，高地址放着高位数据。  </p>
<h5 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h5><p>地址标识了特定通信域的套接字端点，不同格式的地址传入套接字函数，可以用一个统一的结构来保存这个地址，被转换为 <code>sockaddr</code> 结构。因特网地址则定义在：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="keyword">struct</span> in_addr &#123;</div><div class="line">	<span class="keyword">in_addr_t</span> s_addr; <span class="comment">//IPv4地址</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> sockaddr_in &#123;</div><div class="line">	<span class="keyword">sa_family_t</span> sin_family;</div><div class="line">	<span class="keyword">in_port_t</span> sin_port;</div><div class="line">	<span class="keyword">struct</span> in_addr sin_addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>in_port_t</code> 为 <code>uint16_t</code> 类型的，而 <code>in_addr_t</code> 是 <code>uint32_t</code> 类型的。不同的系统下可以自由实现和添加额外的字段。<br>有时，地址的格式不易于人去查看，因此要转换为表达式格式（p），点分十进制。计算机理解的是数值格式（n）。BSD网络软件提供了函数 <code>inet_addr</code> 和 <code>inet_ntoa</code> 用于两者之间的转换。只用于IPv4。下面的函数则可以适用不同协议。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str,\</div><div class="line">						<span class="keyword">socklen_t</span> size)</span></span>;<span class="comment">//成功返回地址字符串指针</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</div><div class="line"><span class="comment">//成功返回1，无效返回0，失败返回-1</span></div></pre></td></tr></table></figure></p>
<h5 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h5><p><strong>1.获得给定计算机的主机信息</strong><br>通过调用 <code>gethostent</code> 函数，返回一个 <code>hostent</code> 结构的数据结构。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> hostent *<span class="title">gethostent</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//成功返回指针，失败返回NULL</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sethostent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>; <span class="comment">//打开主机数据文件，</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endhostent</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//关闭</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> hostent &#123;</div><div class="line">	<span class="keyword">char</span> *h_name; <span class="comment">//host name</span></div><div class="line">	<span class="keyword">char</span> **h_aliases; <span class="comment">//pointer of alternate host name array</span></div><div class="line">	<span class="keyword">int</span> h_addrtype; <span class="comment">//address type</span></div><div class="line">	<span class="keyword">int</span> h_length;</div><div class="line">	<span class="keyword">char</span> **h_addr_list; <span class="comment">//pointer to array of network addresses</span></div><div class="line">	.</div><div class="line">	.</div><div class="line">	.</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>返回地址为网络字节序。<br><strong>2.获取网络名字和网络号</strong>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnetbyaddr</span><span class="params">(<span class="keyword">unint32_t</span> net, <span class="keyword">int</span> type)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnetbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> netent *<span class="title">getnet</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnetent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endnetent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> netent &#123;</div><div class="line">	<span class="keyword">char</span> *n_name;</div><div class="line">	<span class="keyword">char</span> **n_aliasses;</div><div class="line">	<span class="keyword">int</span> n_addrtype;</div><div class="line">	<span class="keyword">uint32_t</span> n_net;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样，网络号按照网络字节序返回，地址类型为一个地址族常量（AF_INET）。<br><strong>3.服务和端口号</strong><br>服务是由地址的端口号部分表示的。每个服务由一个唯一的、熟知的端口号表示。如ssh的端口号是22，http的端口号80等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="comment">//由服务名字来获得信息</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</div><div class="line"><span class="comment">//由端口号来获得信息</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</div><div class="line"><span class="comment">//顺序扫描服务数据库</span></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservenmt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setservent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endservent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> servent &#123;</div><div class="line">	<span class="keyword">char</span> *s_name;</div><div class="line">	<span class="keyword">char</span> **s_aliases;</div><div class="line">	<span class="keyword">int</span> s_port;</div><div class="line">	<span class="keyword">char</span> *s_proto;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>4.两个函数</strong><br>函数 <code>getaddrinfo</code> 允许将一个主机名和服务名映射到一个地址。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">const</span> <span class="keyword">char</span> *service, \</div><div class="line">				<span class="keyword">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result )</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> addrinfo &#123;</div><div class="line">    <span class="keyword">int</span> ai_flags;        <span class="comment">//AI_PASSIVE,AI_CANONNAME,AI_NUMERICHOST</span></div><div class="line">    <span class="keyword">int</span> ai_family;        <span class="comment">//AF_INET,AF_INET6</span></div><div class="line">    <span class="keyword">int</span> ai_socktype;    <span class="comment">//SOCK_STREAM,SOCK_DGRAM</span></div><div class="line">    <span class="keyword">int</span> ai_protocol;    <span class="comment">//IPPROTO_IP, IPPROTO_IPV4, IPPROTO_IPV6 etc.</span></div><div class="line">    <span class="keyword">size_t</span> ai_addrlen;            <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">char</span>* ai_canonname;            <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">struct</span> sockaddr* ai_addr;    <span class="comment">//must be zero or a null pointer</span></div><div class="line">    <span class="keyword">struct</span> addrinfo* ai_next;    <span class="comment">//must be zero or a null pointer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>hostname</em>:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)<br><em>service</em>：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等<br><em>hints</em>：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。<br><em>result</em>：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。<br><em>返回值</em>：0成功，非0出错  </p>
<p>函数 <code>getnameinfo</code> 将地址转换成主机名或服务名。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="keyword">socklen_t</span> salen, <span class="keyword">char</span> *host, \</div><div class="line">				<span class="keyword">size_t</span> hostlen, <span class="keyword">char</span> *serv, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</div></pre></td></tr></table></figure></p>
<p>例子：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//using getnameinfo()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HO 128</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sockaddr_in sa_in;</div><div class="line">	<span class="keyword">char</span> host[MAX_HO], service[MAX_HO];</div><div class="line">	<span class="keyword">int</span> flags;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</div><div class="line">		err_sys(<span class="string">"Usage: a.out &lt;IP&gt; &lt;port&gt;"</span>);</div><div class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">	<span class="comment">//init addr</span></div><div class="line">	sa_in.sin_family = AF_INET;</div><div class="line">	sa_in.sin_port = htons(port);</div><div class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;sa_in.sin_addr.s_addr);</div><div class="line">	flags = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	err = getnameinfo((<span class="keyword">struct</span> sockaddr *)(&amp;sa_in), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr),\</div><div class="line">			host, <span class="keyword">sizeof</span>(host), service, <span class="keyword">sizeof</span>(service), flags);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		gai_strerror(err);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"host := %s ; service := %s\n"</span>, host, service);</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="套接字与地址"><a href="#套接字与地址" class="headerlink" title="套接字与地址"></a>套接字与地址</h5><p>套接字中没有包含太多信息，只是一个描述符，并不知道通信的端口和I地址，而建立客户和服务器之间的连接时，往往需要这些信息，所以，在编程过程中要将socket函数产生的套接字与地址相关联。地址结构类似：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IPv4  </span></div><div class="line"><span class="keyword">struct</span> sockaddr_in  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_len;      <span class="comment">//IPv4地址长度  </span></div><div class="line">    <span class="keyword">short</span> <span class="keyword">int</span>      sin_family;   <span class="comment">//指代协议簇，在TCP套接字编程只能是AF_INET  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;     <span class="comment">//存储端口号（使用网络字节顺序），数据类型是一个16为的无符号整形类型  </span></div><div class="line">    <span class="keyword">struct</span>         in_addr sin_addr;<span class="comment">//存储IP地址，IP地址是一个in_add结构体（结构在下面）  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];     <span class="comment">//为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节  </span></div><div class="line">&#125;; </div><div class="line"><span class="keyword">struct</span> in_addr  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;   <span class="comment">//按照网络字节顺序存储IP地址  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这时需要一个函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第二个参数就是套接字地址结构对象了，它将与第一个参数套接字描述符进行绑定，这里的套接字地址结构参数的类型是通用套接字地址结构类型，因此，在实际调用的时候需要强制转换了。  </p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>在处理面向连接的网络服务时，开始交换数据前，必须在请求服务的套接字（客户端）和提供服务的套接字（服务器）之间建立连接。 <code>connect</code> 函数可以建立这样一个连接。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div><div class="line"><span class="comment">//成功返回0，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p><em>addr</em> 表示是想与之通信的服务器地址。  </p>
<p><strong>服务器</strong>调用 <code>listen</code> 来宣告可以接受连接请求。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>;</div><div class="line"><span class="comment">//成功返回文件描述符，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p><em>backlog</em> 指定了可以连接的数量，超过这一个值则拒绝连接。<br>服务器能够接受到请求，那么会再调用 <code>accept</code> 来获得连接请求并建立连接。<br>它返回的是调用 <code>connect</code> 函数的客户端的套接字描述符。如果不关心客户端的地址信息，则可以忽略后两个参数，将它们设为NULL。当 <code>accept</code> 没有连接请求时，服务器会阻塞直到下一个请求的到来，另外可以使用 <code>pool</code> 和 <code>select</code> 来等待一个请求的到来。<br>基本流程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * 套接字类型，地址，长度，可以连接数量</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> alen, </div><div class="line">		<span class="keyword">int</span> qlen)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</div><div class="line">	<span class="comment">//1.创建套接字</span></div><div class="line">	<span class="keyword">if</span>((fd = socket(addr-&gt;sa_family, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">	<span class="comment">//2.绑定套接字和地址</span></div><div class="line">	<span class="keyword">if</span>(bind(fd, addr, alen) &lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		err = errno;</div><div class="line">		<span class="keyword">goto</span> errout;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//3.准备连接</span></div><div class="line">	<span class="keyword">if</span>(type == SOCK_STREAM || type == SOCK_SEQPACKET)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(listen(fd, qlen) &lt; <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			err = errno;</div><div class="line">			<span class="keyword">goto</span> errout;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">errout:</div><div class="line">	close(fd);</div><div class="line">	errno = err;</div><div class="line">	<span class="keyword">return</span> (<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><strong>send和recv函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></div><div class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);  </div><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</div></pre></td></tr></table></figure></p>
<p>它们的前三个参数类似于<code>read</code> 和 <code>write</code>函数，最后一个参数一般为0。<br>send函数的参数  </p>
<ul>
<li>sockfd：指定发送端套接字描述符。</li>
<li>buff：存放要发送数据的缓冲区</li>
<li>nbytes: 实际要发送的数据的字节数</li>
<li>flags： 一般设置为0  </li>
</ul>
<p>recv函数的参数  </p>
<ul>
<li>sockfd: 接收端套接字描述符</li>
<li>buff：用来存放recv函数接收到的数据的缓冲区</li>
<li>nbytes: 指明buff的长度</li>
<li>flags: 一般设置为0</li>
</ul>
<p><strong>sendto和recvfrom函数</strong><br>这是面向无连接的数据传输，sockfd中不包含地址信息，所以需要指定地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</div><div class="line">    		<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="keyword">int</span> destlen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</div><div class="line">			<span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程， 第16章 网络IPC：套接字 读书笔记。不同计算机进行通信的机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-进程间通信</title>
    <link href="http://abumaster.com/2017/05/30/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://abumaster.com/2017/05/30/UNIX环境高级编程-进程间通信/</id>
    <published>2017-05-30T07:12:26.000Z</published>
    <updated>2017-06-04T13:00:38.863Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第14章 进程间通信IPC读书笔记。</p>
<a id="more"></a>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/36378614.jpg" alt="">  </p>
<div class="note primary"><p><strong>进程间通信</strong>( <em>inteprocess communication</em> ) 的目的是：
进行数据传输，不同进程协作处理一些数据；资源共享，多个进程间共享数据；通知事件，一个进程向其他进程通知一个事件发生；<br>进程间的通信主要分为：pipe，fifo，消息队列，信号量，共享存储，uds，套接字。</p>
</div>  
<h4 id="pipe和fifo"><a href="#pipe和fifo" class="headerlink" title="pipe和fifo"></a>pipe和fifo</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>pipe又称管道，提供了一个半双工的父子进程之间通信的机制。创建管道很简单：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>
<p>fd[0]可以用来读数据，fd[1]可以用来写数据。它们中间会有一个缓冲区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmd,<span class="keyword">const</span> <span class="keyword">char</span>* type)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE* fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>打开的是一个可执行的命令，<code>type</code>只能是 <code>r</code> 和 <code>w</code> 可能会返回执行命令的结果。实现上我们值得思考一下，就是 <code>popen</code> 通常来说肯定是创建了一个进程，然后FILE里面记录的 <code>fd</code> 必然和这个进程号做了一个绑定。不然我们在 <code>pclose</code> 使用 <code>FILE*</code>必须能够找到，我们应该 <code>wait</code> 什么进程终止。 在 <code>pclose</code> 必须 <code>fclose</code> 掉句柄，不然如果作为一输入命令的话那么会一直等待输入完成。  </p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/1955979.jpg" alt=""><br><strong>实例</strong><br>通过 <code>popen</code> 对输入进行变换的程序。向标准输出一个提示，从标准输入读取一行，使用 <code>popen</code> 可以在标准输入和输出之间添加一个程序来对输入进行变换处理，（当然也可以写成一个函数的形式来解决），基本流程如图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/54057635.jpg" alt=""><br>从标准输入读入字符，将其转换成小写的程序。<br><figure class="highlight c"><figcaption><span>myuclc.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>((c = getchar()) != EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">isupper</span>(c))</div><div class="line">			c=<span class="built_in">tolower</span>(c);</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">putchar</span>(c) == EOF)</div><div class="line">			err_sys(<span class="string">"output error"</span>);</div><div class="line">		<span class="keyword">if</span>(c==<span class="string">'\n'</span>)</div><div class="line">			fflush(<span class="built_in">stdout</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>编译为可执行文件myuclc，然后通过程序调用它。<br><figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">char</span> line[MAXLINE];</div><div class="line">	FILE *fpin;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>((fpin=popen(<span class="string">"./myuclc"</span>,<span class="string">"r"</span>)) == <span class="literal">NULL</span>)</div><div class="line">		err_sys(<span class="string">"popen error"</span>);</div><div class="line">	<span class="keyword">for</span>( ; ;)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">fputs</span>(<span class="string">"prompt&gt; "</span>, <span class="built_in">stdout</span>);</div><div class="line">		fflush(<span class="built_in">stdout</span>);</div><div class="line">		<span class="keyword">if</span>(fgets(line, MAXLINE, fpin) == <span class="literal">NULL</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">fputs</span>(line, <span class="built_in">stdout</span>) == EOF)</div><div class="line">			err_sys(<span class="string">"fputs error to pipe"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(pclose(fpin) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"pclose error"</span>);</div><div class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>  </p>
<p><strong>协同进程</strong><br>当一个程序产生某个过滤程序的输入，并且又读取该过滤程序的输出时，该过滤程序被称为 <em>协同进程coprocess</em> ，<code>popen</code> 只提供连接到另一进程的单向管道，所以需要两个单向管道。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/12251209.jpg" alt="">  </p>
<h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><blockquote>
<p>FIFO通常被称为命名管道，它是一种文件类型.stat结构中的st_mode指明其类型，可以用宏S_ISFIFO 进行测试。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="comment">//成功返回0，失败返回-1</span></div></pre></td></tr></table></figure>
<p>类似于管道，若用<code>write</code>写一个没有进程为读而打开的FIFO，则会产生SIG_PIPE信号，若FIFO最后一个写进程关闭了该FIFO，那么会为读进程产生一个文件结束标志。 
FIFO用途：  </p>
<ul>
<li>将数据从一条管道线传送到另一条，无需创建临时文件；  </li>
<li>用于客户进程-服务器进程的程序中，客户服务器之间传送数据。  </li>
</ul>
<p><strong>实例</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/10176095.jpg" alt=""><br>通常打开FIFO的方式有四种：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY);<span class="comment">//读，阻塞</span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY | O_NONBLOCK);<span class="comment">//非阻塞  </span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY);<span class="comment">//写，阻塞，一直等待</span></div><div class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY | O_NONBLOCK);<span class="comment">//写，非阻塞</span></div><div class="line"><span class="comment">//阻塞情况下，没有对应端打开也会一直等待不返回</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-31/70265253.jpg" alt="">  </p>
<div class="note primary"><p><strong>XPS IPC</strong> 即消息队列、信号量、共享存储。</p>
</div>  
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。<br>流程： <code>msgget</code> 创建或打开一个现存的队列， <code>msgsnd</code> 将消息添加到队列尾端， <code>msgrcv</code> 用于从队列中取消息。 
使用 <code>key_t ftok(const char *path, int id);</code>来创建键值， <em>path</em> 必须存在，使用 <em>id</em> 的8位，组合。
消息队列相关的 API 有四个，必须包含的头文件。 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>1.打开或者创建一个队列</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。<br>如果没有消息队列与健值key相对应，并且msgflg中包含了IPC_CREAT标志位或key参数为IPC_PRIVATE时创建新的队列。<br>参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果。<br>调用返回：成功返回消息队列描述字，否则返回-1。  </p>
<p><strong>2.读取消息</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中。msqid为消息队列描述字；消息返回后存储在msgp指向的地址，msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），msgtyp为请求读取的消息类型；读消息标志msgflg可以为以下几个常值的或：  </p>
<ul>
<li>IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG</li>
<li>IPC_EXCEPT 与msgtyp&gt;0配合使用，返回队列中第一个类型不为msgtyp的消息</li>
<li>IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失。</li>
</ul>
<p>调用返回：成功返回读出消息的实际字节数，否则返回-1。  </p>
<p><strong>3.向队列发送一个消息</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure></p>
<p>向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定。对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：</p>
<ul>
<li>当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量；</li>
<li>当前消息队列的消息数（单位”个”）不小于消息队列的总容量（单位”字节数”），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节。</li>
</ul>
<p>调用返回：成功返回0，否则返回-1。  </p>
<p><strong>4.垃圾桶函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID。  </p>
<ul>
<li>IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；</li>
<li>IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员。</li>
<li>IPC_RMID：删除msqid标识的消息队列；</li>
</ul>
<p><strong>消息队列编程模型：</strong><br>接受消息端：申明消息类型——&gt; msgget建立消息队列 ——&gt;循环接收消息msgrcv——&gt;结束判断strcmp——&gt;msgctl(IPC_RMID)删除消息<br>发送消息端：申明消息类型——&gt;msgget建立消息队列——&gt;循环输入数据到消息中——&gt;msgsend向队列发送消息——结束判断strcmp——&gt;msgctl删除消息  </p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p><em>信号量（semaphore）</em> 是一个计数器，用于多进程对共享数据的访问。<br><strong>工作原理</strong>，为了获得共享资源，进程需要：  </p>
<ul>
<li>测试控制资源的信号量；  </li>
<li>若此信号量值为正，则可以使用信号量，并将信号量减1，表示使用了一个资源单位；  </li>
<li>若此信号量值为0，进程休眠，直到信号量大于0，进程唤醒，重复上述。  </li>
</ul>
<p><strong>1.semget函数</strong><br>获取或者创建信号量集。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> flag)</span></span>;</div><div class="line"><span class="comment">//成功返回信号量ID，失败返回-1</span></div></pre></td></tr></table></figure></p>
<p>第一个参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget函数并提供一个键，再由系统生成一个相应的信号标识符（semget函数的返回值），只有semget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。<br>第二个参数nsems指定需要的信号量数目，创建新集合的时候非零指定值，引用现有的集合则可以为0。<br>第三个参数flag，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。  </p>
<p><strong>2.semop函数</strong><br>自动执行信号量集合上的操作数组，原子操作，改变信号量的值。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>;</div></pre></td></tr></table></figure></p>
<p>sem_id是由semget返回的信号量标识符，sembuf结构的定义如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sembuf&#123;  </div><div class="line">    <span class="keyword">short</span> sem_num;<span class="comment">//除非使用一组信号量，否则它为0  </span></div><div class="line">    <span class="keyword">short</span> sem_op;<span class="comment">//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，  </span></div><div class="line">                    <span class="comment">//一个是+1，即V（发送信号）操作。  </span></div><div class="line">    <span class="keyword">short</span> sem_flg;<span class="comment">//通常为SEM_UNDO,使操作系统跟踪信号，  </span></div><div class="line">                    <span class="comment">//并在进程没有释放该信号量而终止时，操作系统释放信号量  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>一个例子</strong><br>设置一个信号量，使多进程之间共享。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> semun</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> val;</div><div class="line">	<span class="keyword">struct</span> semid_ds *buf;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//创建信号量</span></div><div class="line">sem_id = semget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span>|IPC_CREAT);</div><div class="line"></div><div class="line"><span class="comment">//初始化信号量，使用前必须这样做</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">union</span> semun sem_union;</div><div class="line"></div><div class="line">	sem_union.val = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union)==<span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">union</span> semun sem_union;</div><div class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"del semvalue error"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//p操作</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sembuf sem_b;</div><div class="line">	sem_b.sem_num = <span class="number">0</span>;</div><div class="line">	sem_b.sem_op = <span class="number">-1</span>;</div><div class="line">	sem_b.sem_flg = SEM_UNDO;</div><div class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//v操作</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">struct</span> sembuf sem_b;</div><div class="line">	sem_b.sem_num = <span class="number">0</span>;</div><div class="line">	sem_b.sem_op = <span class="number">1</span>;</div><div class="line">	sem_b.sem_flg = SEM_UNDO;</div><div class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.semctl函数</strong><br>控制信号量信息。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd,...<span class="comment">/* union semun arg */</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>如果有第四个参数，它通常是一个union semum结构，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> semun&#123;  </div><div class="line">    <span class="keyword">int</span> val;  </div><div class="line">    <span class="keyword">struct</span> semid_ds *buf;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>共享存储允许两个或更多的进程共享以给定的存储区。无需进程间的复制，是一种最快的IPC。多个进程对同一存储区的同步访问。<br><strong>1.shmget函数</strong><br>获取一个共享存储标识符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</div><div class="line"><span class="comment">//成功返回共享存储ID，出错返回-1</span></div></pre></td></tr></table></figure></p>
<p>第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。<br>不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget函数的返回值），只有shmget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。<br>第二个参数，size以字节为单位指定需要共享的内存容量。<br>第三个参数，flag是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。<br><strong>2.shmat函数</strong><br>第一次创建完共享内存时，它还不能被任何进程访问，shmat函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数，是semget返回的存储空间标识；<br>第二个参数，为0，则连接到第一个可用的地址上，推荐使用；非0并且没有指定SHM_RND，则连接到<em>addr</em>指定的地址；<br>第三个参数，是一组标志位，通常为0。<br><strong>3.shmdt函数</strong><br>用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>addr 参数是调用 <code>shmat</code> 的返回值。<br><strong>4.shmctl函数</strong><br>对共享存储段进行多种操作。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数，shmid是shmget函数返回的共享内存标识符。<br>第二个参数，cmd是要采取的操作，它可以取下面的三个值 ：  </p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。  </li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值。  </li>
<li>IPC_RMID：删除共享内存段。<br>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。
shmid_ds结构至少包括以下成员：  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> shmid_ds  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">uid_t</span> shm_perm.uid;  </div><div class="line">    <span class="keyword">uid_t</span> shm_perm.gid;  </div><div class="line">    <span class="keyword">mode_t</span> shm_perm.mode;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>例子</strong><br>设计流程，注意多进程同时读写的问题。<br>创建共享存储，获得共享存储标识符；将共享存储连接到进程空间，获得首地址指针；设置存储空间格式；读写存储区。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第14章 进程间通信IPC读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-高级IO</title>
    <link href="http://abumaster.com/2017/05/26/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/"/>
    <id>http://abumaster.com/2017/05/26/UNIX环境高级编程-高级IO/</id>
    <published>2017-05-26T07:01:48.000Z</published>
    <updated>2017-05-27T08:27:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程，第14章 高级I/O 读书笔记。高级 I/O 包括：非阻塞 I/O，记录锁、系统V流机制、I/O多路转换、存储映射 I/O 。  </p>
<a id="more"></a>
<h4 id="I-O多路转换"><a href="#I-O多路转换" class="headerlink" title="I/O多路转换"></a>I/O多路转换</h4><p><strong>应用场景：</strong> 在服务器编程模型中，客户请求到来时，服务器开启一个进程去服务，但是请求量很大时，服务器不可能一直开启的进程无法满足大量请求。这时，一个进程去服务多个客户，多个客户由于情况不同，不能在一个客户身上浪费太多的时间（阻塞），这时就引入了 I/O 多路复用的技术。<br><div class="note info"><p>其实，解决多用户请求可以用到的方法主要有：非阻塞IO，通过一种叫做 <em>轮询</em> 的方法进行遍历多个描述符，符合要求就去读，不符合下一个，这样在“路上”浪费一些时间，避免使用这种方法；还有一种 <em>异步IO</em> 的方法，核心思想是当一个描述符准备好后，用信号通知，这种方法有一定的系统限制；比较好的方法就是 <em>IO多路转换</em> 了，下面详细介绍。</p>
</div>  </p>
<h5 id="select和pselect函数"><a href="#select和pselect函数" class="headerlink" title="select和pselect函数"></a>select和pselect函数</h5><p>传向<code>select</code>的参数告诉内核：  </p>
<ul>
<li>关心的描述符；  </li>
<li>对于每个描述符关心的状态（读、写）；  </li>
<li>愿意等待的时间。<br>返回时，内核告诉我们：  </li>
<li>已准备好的描述符数量；  </li>
<li>对于读、写、异常的状态的每一个，哪些描述符已准备好。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds,</div><div class="line">			fd_set *<span class="keyword">restrict</span> writefds,</div><div class="line">			fd_set *<span class="keyword">restrict</span> exceptfds,</div><div class="line">			<span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</div><div class="line"><span class="comment">//返回值：准备就绪的描述符，超时返回0，失败返回-1</span></div><div class="line"><span class="keyword">struct</span> timeval &#123;</div><div class="line">	<span class="keyword">long</span> tv_sec; <span class="comment">//seconds</span></div><div class="line">	<span class="keyword">long</span> tv_usec; <span class="comment">//microseconds</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>关于返回值有三种情况：  </p>
<ul>
<li><code>tvpr==NULL</code> 永远等待，有描述符准备好或捕获到一个信号中断等待；  </li>
<li><code>tvpr-&gt;tv_sec==0 &amp;&amp; tvpr-&gt;tv_usec==0</code> 完全不等待；  </li>
<li>有一个不等于0，则是等待特定时间。<br>中间的三个参数指定描述符集的指针，可以通过以下API来设置。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//清空集合</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>; </div><div class="line"><span class="comment">//将一个给定的文件描述符加入集合之中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">//将一个给定的文件描述符从集合中删除   </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   </div><div class="line"><span class="comment">//检查集合中指定的文件描述符是否可以读写</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一个参数表示最大的描述符加1。为了限制在指定的范围内查找。<br><div class="note warning"><p><code>select</code> 有三个可能的返回值。<br>1.返回值 -1 表示出错。<br>2.返回值 0 表示没有描述符准备好，所有描述符集被清零。<br>3.正返回值，表示准备好的描述符数量，在描述符集中对应的位表示准备好的描述符。</p>
</div><br><code>pselect</code> 为 <code>select</code> 的变形，不同点在于，超时的结构，更精细的粒度来控制超时时间；可以设定信号屏蔽字。 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfd1, fd_set *readfds, </div><div class="line">			fd_set *writefds, fd_set exceptfds, </div><div class="line">			<span class="keyword">const</span> <span class="keyword">struct</span> timespec *tsptr, </div><div class="line">			<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>缺点：</strong>  </p>
<ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 </li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 </li>
<li>select支持的文件描述符数量太小了，默认是1024</li>
</ol>
<h5 id="pool函数"><a href="#pool函数" class="headerlink" title="pool函数"></a>pool函数</h5><p><code>pool</code>函数可用于任何类型的文件描述符，不是为每个状态构造一个描述符集，而是构造了一个 <code>poolfd</code> 结构数组，每个数组元素指定一个描述符编号以及对其关心的状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"><span class="keyword">struct</span> pollfd&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">short</span> events; <span class="comment">//常用的读POLLIN/写POLLOUT</span></div><div class="line">    <span class="keyword">short</span> revents; <span class="comment">//在fd上出现的event，可忽略设置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>poll</code> 第一个参数是一个fd数组集合, 每个fd关联一个pollfd结构, 该结构说明fd的关心状态是读还是写<br><code>poll</code> 第二个参数是第一个参数中fd的个数<br><code>poll</code> 第三个参数是等待时间, -1表示无限等待, 0表示不等待, 其它正值表示可等待的毫秒数<br><strong>流程：</strong>将结构数组中的元素<code>events</code>成员设置为标志（POOLIN POOLOUT等），通过设置这些来告诉内核我们对该描述符关心的是什么，返回时内核设置 <code>revents</code> 来对于该描述符上已经发生了什么事件。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> poolfd pfds[<span class="number">2</span>];<span class="comment">//定义poolfd结构数组</span></div><div class="line">pfds[<span class="number">0</span>].fd=STDIN_FILENO;<span class="comment">//关心的描述符</span></div><div class="line">pfds[<span class="number">0</span>].events=POOLIN;<span class="comment">//对于fd关心的events</span></div><div class="line">...</div><div class="line">pool(pfds, <span class="number">2</span>, <span class="number">-1</span>);<span class="comment">//设置pool，永远等待</span></div><div class="line"><span class="comment">//判断是否有满足的返回</span></div><div class="line"><span class="keyword">if</span>(pfds[<span class="number">0</span>].revents &amp; POOLIN) <span class="comment">//满足</span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h4><div class="note info"><p><em>存储映射I/O（Memory-mapped I/O）</em> 使一个磁盘文件和存储空间的一个缓冲区相映射，于是当从缓冲区中取数据，就相当于读文件中对应字节，向缓冲区写数据相当于自动写到文件中相应字节。可以在不使用 <code>read</code> 和 <code>write</code> 情况下执行IO。</p>
</div>  
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>首先，通知内核将一个文件映射到存储区中，调用 <code>mmap</code> 函数。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> filedes, <span class="keyword">off_t</span> off)</span></span>;</div><div class="line"><span class="comment">//返回值：若成功则返回映射区的起始地址，出错返回MAP_FAILED</span></div></pre></td></tr></table></figure></p>
<p> <em>addr</em> 参数用于指定映射存储区的起始地址，一般设置为0，表示由系统选择该映射区的起始地址，函数返回地址是映射区的起始地址。<br> <em>filedes</em> 指定要被映射文件的描述符，先要打开该文件。<br> <em>len</em> 表示映射的字节数。 <em>off</em> 映射文件在文件中的起始偏移量。<br> <em>prot</em> protect参数说明对映射存储区的保护要求。<br><code>PROT_READ, PROT_WRITE, PROT_EXEC, PROT_NONE</code> 可读可写可执行及不可访问。<br><img src="http://images.cnitblog.com/i/507263/201405/132119172653497.png" alt="">  </p>
<p>其他函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="comment">//更改一个现存映射存储区的权限</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</div><div class="line"><span class="comment">//将页冲洗到被映射的文件中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="comment">//解除映射</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">caddr_t</span> addr, <span class="keyword">size_t</span> len)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>应用：</strong> 参考<a href="http://blog.csdn.net/ctthuangcheng/article/details/9278107">ctthuangcheng 博客</a>的例子。  </p>
<ul>
<li>改变文件的内容，拷贝文件  </li>
<li>进程间共享文件  </li>
<li>父子进程通信  </li>
</ul>
<p>关于内存映射区的地址：<br>将文件或者其他东西映射到内存是以页面大小为单位进行分配的，往往被分配的映射区大小是页面大小的整数倍，如果不够一个页面则强制变为一个页面大小。文件大小到映射区大小之间的映射关系分为三种情况：</p>
<ul>
<li>文件大小等于映射区大小，此时映射区的大小分配</li>
<li>文件大小大于映射区大小</li>
<li>文件大小小于映射区大小</li>
</ul>
<p>如图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-27/49590422.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程，第14章 高级I/O 读书笔记。高级 I/O 包括：非阻塞 I/O，记录锁、系统V流机制、I/O多路转换、存储映射 I/O 。  &lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-线程</title>
    <link href="http://abumaster.com/2017/05/24/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/05/24/UNIX环境高级编程-线程/</id>
    <published>2017-05-24T02:52:22.000Z</published>
    <updated>2017-05-25T07:53:21.247Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第 11、12 章线程和线程控制。</p>
<a id="more"></a>
<div class="note primary"><p>单进程程序中需要处理多个任务时，通常用到多线程来分别处理各个任务，各个线程可以共享进程的资源。Linux中线程函数位于 <em>libpthread</em> 共享库中，因此在编译程序时要加上 <em>lpthread</em> 选项。 </p>
</div>  
<h4 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h4><p><strong>线程标识</strong> 如进程ID一样，线程也有一个为一个标识，只在进程环境中有效，用 _pthread_t_ 数据类型表示，不是一个整数，因此有专门的函数来比较两个线程的ID。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;<span class="comment">//相等返回非零</span></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);<span class="comment">//调用线程的线程ID</span></div></pre></td></tr></table></figure></p>
<p><strong>线程创建</strong> 可以直接调用 <code>pthread_create</code> 函数来创建一个新的线程，线程的执行顺序是不定的，无法保证哪个线程先运行，新的线程可以继承和调用线程的浮点环境和信号屏蔽字，多个线程可以共同访问进程的资源。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_create(pthread_t *restrict tidp,</div><div class="line">					const pthread_attr_t *restrict attr,</div><div class="line">					void *(*start_rtn)(void *),</div><div class="line">					void *restrict arg);</div></pre></td></tr></table></figure></p>
<p>成功返回0，失败返回错误编号。 <em>tidp</em> 表示新创建线程的ID， <em>attr</em> 定制各种不同的线程属性， _start_rtn_ 新创建线程的线程函数， <em>arg</em> 表示传入线程的参数，通常是结构体指针。<br><strong>线程终止</strong> 进程中的任一个线程如果调用了 <code>exit _Exit _exit</code> 函数，那么整个进程就会退出，如果单个线程退出而不影响整个进程，有下面三种方式：  </p>
<ul>
<li>线程从启动例程返回，返回值为线程的退出码；</li>
<li>线程可以被同一进程中的其他线程取消；</li>
<li>线程调用 <code>pthread_exit</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="comment">//终止自己，并设置一个无类型指针表示终止码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div><div class="line"><span class="comment">//访问上述的指针一直阻塞等待，获得线程的终止状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-24/47171841.jpg" alt=""><br>当 <code>pthread_join</code> 返回时，指向的内存必须是全局的或者是动态分配的，否则在栈上会出现覆盖的情况。创建的线程才算终止，才会释放占用的资源。  </p>
<p><strong>进程原语和线程原语的比较</strong>  </p>
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>fork</strong></td>
<td>pthread_create</td>
<td>创建新的控制流</td>
</tr>
<tr>
<td><strong>exit</strong></td>
<td>pthread_exit</td>
<td>从现有的控制流中退出</td>
</tr>
<tr>
<td><strong>waitpid</strong></td>
<td>pthread_join</td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td><strong>atexit</strong></td>
<td>pthread_cleanup_push</td>
<td>注册在退出时调用的函数</td>
</tr>
<tr>
<td><strong>getpid</strong></td>
<td>pthread_self</td>
<td>获取控制流的ID</td>
</tr>
<tr>
<td><strong>abort</strong></td>
<td>pthread_cancel</td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody>
</table>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>同一进程中的多个线程共享进程的资源，会产生竞争，为了保证数据的一致性，需要线程同步。<br><strong>1.互斥量</strong><br>通过使用pthread的互斥接口保护数据，确保同一时间只有一个线程访问数据， <em>互斥量（mutex）</em> 相当于一把锁，在访问共享资源前对其加上一把锁，使用过后，释放。其他线程在访问时，如果加锁会阻塞，直到获取这个互斥锁。<br>互斥变量通常用 <em>pthread_mutex_t</em> 的数据类型表示，使用前必须进行初始化，可以静态也可以动态，动态的话使用后要销毁。对应的 API 如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,</div><div class="line">						const pthread_mutexattr_t *restrict attr);</div><div class="line">int pthread_mutex_destory(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</div><div class="line"></div><div class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</div></pre></td></tr></table></figure></p>
<p><strong>2.避免死锁</strong><br>通过加锁的顺序可以避免死锁，使用多个互斥量。<br><strong>3.读写锁</strong><br>读写锁允许更高的并行性。读写锁有三种状态：读模式下加锁状态、写模式下加锁状态、不加锁状态。可以多读，单独写的策略，被称为 <em>共享-独占锁</em> 非常适合读的次数大于写的次数的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,  </div><div class="line">                                <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">/* 读模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 非阻塞的读模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 写模式下加锁  */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 非阻塞的写模式下加锁 */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;  </div><div class="line"><span class="comment">/* 解锁 */</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>4.条件变量</strong><br>条件变量可以与互斥量一起使用，等待特定条件的发生。条件本身用互斥量保护，获得了互斥量才可以改变条件或者获得条件的状态。<br>数据类型为 <code>pthread_cond_t</code> 用之前用 <code>PTHREAD_COND_INITIALIZER</code> 静态初始化，或者调用函数动态初始化，结束使用后记得销毁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,<span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;     </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,pthread_mutex *mutex,</div><div class="line">							<span class="keyword">const</span> timespec *abstime)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>; <span class="comment">//唤醒单个等待线程</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;  <span class="comment">//唤醒所有等待线程</span></div></pre></td></tr></table></figure></p>
<p>使用 <code>pthread_cond_wait</code> 等待条件为真，互斥量用于保护条件，调用函数时，会进行两个原子操作：  </p>
<ul>
<li>把调用线程放到等待条件的线程列表上；  </li>
<li>对互斥量解锁。<br><code>pthread_cond_timewait</code> 多了一个超时时间，当等待的时间内未满足条件，则会返回一个超时的错误。<br>等待时间的结构  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> timespec&#123;  </div><div class="line"><span class="keyword">time_t</span>  tv_sec    <span class="comment">//Seconds.  </span></div><div class="line"><span class="keyword">long</span>    tv_nsec   <span class="comment">//Nanoseconds.  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>函数要求传入的时间值是一个绝对值，不是相对值，例如，想要等待3分钟，必须先获得当前时间，然后加上3分钟。
要想获得当前系统时间的timespec值，没有直接可调用的函数，需要通过调用gettimeofday函数获取timeval结构，然后转换成timespec结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> timeval now;</div><div class="line"><span class="keyword">struct</span> timespec until;</div><div class="line">gettimeofday(&amp;now);<span class="comment">//获得系统当前时间</span></div><div class="line"></div><div class="line"><span class="comment">//把时间从timeval结构转换成timespec结构</span></div><div class="line">until.tv_sec = now.tv_sec;</div><div class="line">until.tv_nsec = now.tv_usec * <span class="number">1000</span>;</div><div class="line"></div><div class="line"><span class="comment">//增加min</span></div><div class="line">until.tv_sec += <span class="number">3</span> * <span class="number">60</span>;</div></pre></td></tr></table></figure></p>
<h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><p>线程的一些属性设置等。  </p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p><strong>守护进程daemonize</strong>是生存周期较长的一种没有控制终端、后台运行的进程，伴随着系统的启动和关闭。<br><strong>编程规则：</strong>  </p>
<ul>
<li>首先要做的是调用umask将文件模式创建屏蔽字设置为0。由继承得来的文件模式创建屏蔽字可能会拒绝设置某些权限。例如，若守护进程要创建一个组可读、写的文件，而继承的文件模式创建屏蔽字可能屏蔽了这两种权限，于是所要求的组可读、写就不能起作用。  </li>
<li>调用fork，然后使父进程退出（exit）。这样做实现了下面几点：第一，如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕（也就没有了控制终端）；第二，子进程继承了父进程的进程组ID，但具有一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这对于下面就要做的setsid调用是必要的前提条件。  </li>
<li>调用setsid以创建一个新会话。使调用进程：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端。  </li>
<li>将当前工作目录更改为根目录。从父进程出继承过来的当前工作目录可能在一个挂载的文件系统（a mounted file system）中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载的文件系统中，那么该文件系统就不能被卸载。这与挂载文件系统的原意不符。  </li>
<li>关闭不再需要的文件描述符。  </li>
<li>某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出和标准出错的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以不能在终端设备上显示其输出，也无处从交互式用户那里接受输入。即使守护进程是从交互式会话启动的，但因为守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。</li>
</ul>
<p><a href="http://www.cnblogs.com/mickole/p/3188321.html">参考外链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第 11、12 章线程和线程控制。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-信号</title>
    <link href="http://abumaster.com/2017/05/22/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/"/>
    <id>http://abumaster.com/2017/05/22/UNIX环境高级编程-信号/</id>
    <published>2017-05-22T02:01:10.000Z</published>
    <updated>2017-05-24T02:50:22.042Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程，第10章 信号，读书笔记。信号是一种软件中断，用于处理异步事件。</p>
<a id="more"></a>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>信号</strong>都有一个名字，以 <em>SIG</em> 开头，在头文件 <code>&lt;signal.h&gt;</code> 中定义为正整数，信号的编号。信号的产生条件：  </p>
<ul>
<li>终端输入中断按键，如 <code>Ctrl+C</code> 产生了 <code>SIGINT</code> 中断信号；  </li>
<li>硬件异常产生的信号，无效内存引用，除0，等，硬件检测到，通知内核；  </li>
<li>进程调用 <code>kill(2)</code> 函数可将信号发送给同一用户的另一个进程或进程组；  </li>
<li>用户调用 <code>kill(1)</code> 将信号发送给其他进程；  </li>
<li>软件中断。  </li>
</ul>
<p>对于信号的处理，有三种方式：忽略此信号、捕捉信号、执行默认动作。<br><strong>系统信号</strong>  </p>
<table>
<thead>
<tr>
<th>POSIX 信号</th>
<th>说明</th>
<th>默认动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>挂起</td>
<td>终止</td>
</tr>
<tr>
<td>SIGINT</td>
<td>终端中断符</td>
<td>终止</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>退出</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGTRAP</td>
<td>断点或陷阱指令</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGABRT/SIGIOT</td>
<td>abort发送的信号</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>非法内存访问</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>浮点异常</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>kill信号</td>
<td>终止(+)</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>用户信号1</td>
<td>终止</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>无效内存访问</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>用户信号2</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>管道错误</td>
<td>终止</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>alrm发送信号</td>
<td>终止</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>终止信号</td>
<td>终止</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>子进程退出</td>
<td>忽略</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>进程继续</td>
<td>忽略(*)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>进程停止</td>
<td>stop(*)(+)</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>终端停止</td>
<td>stop(*)</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>后台读控制tty</td>
<td>stop(*)</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>后台写tty</td>
<td>stop(*)</td>
</tr>
<tr>
<td>SIGURG</td>
<td>紧急情况</td>
<td>忽略</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>超过CPU限制</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>超过文件长度限制</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>虚拟时钟超时</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>梗概时间超时</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPOLL/SIGIO</td>
<td>轮询事件pool</td>
<td>终止</td>
</tr>
<tr>
<td>SIGSYS/SIGUNUSED</td>
<td>无效系统调用</td>
<td>内核中断</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>协处理器栈故障</td>
<td>终止</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>终端窗口大小改变</td>
<td>忽略</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>电源失效或重启</td>
<td>终止</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>硬件故障</td>
<td>内核中断</td>
</tr>
</tbody>
</table>
<h4 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h4><p>Unix 系统的信号机制最简单的接口就是 <em>signal</em> 函数，当程序收到指定信号时，调用指定的函数。函数原型为
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span>(*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</div><div class="line"><span class="comment">//成功返回信号以前的配置，出错返回 SIG_ERR</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_ERR (void (*) ())-1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL (void (*)())0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN (void (*)())1</span></div></pre></td></tr></table></figure></p>
<p><strong>说明：</strong> <em>signal</em> 函数有两个参数，返回一个函数指针，这个函数指针有一个参数，并且返回空。 <em>signo</em> 表示上表的函数名称或者编号，第二个参数是一个函数指针，整型参数，返回空。<br>通过宏可以更清晰表示函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function">Sigfunc *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>, Sigfunc)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>简单示例：</strong><br>捕获信号 <code>SGIUSR1</code> 和 <code>SGIUSR2</code> 
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//signal proc function</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR1, sig_usr) == SIG_ERR)</div><div class="line">		err_sys(<span class="string">"can't catch SIGUSR1"</span>);</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR2, sig_usr) == SIG_ERR)</div><div class="line">		err_sys(<span class="string">"can not catch SIGUSR2"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(;;)</div><div class="line">		pause();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signo == SIGUSR1)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR1\n"</span>);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGUSR2)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR2\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		err_dump(<span class="string">"received signal:%d\n"</span>, signo);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当在终端后台运行程序后，输入 <code>kill USR1 (进程ID)</code> 会捕获相应的信号，输出对应的信息。  </p>
<h4 id="sigaction-函数"><a href="#sigaction-函数" class="headerlink" title="sigaction 函数"></a>sigaction 函数</h4><div class="note info"><p><em>sigaction</em> 函数的功能是用来检查或者修改与指定信号相关联的处理动作，可以用来取代早期的 <em>signal</em> 函数。 </p>
</div>  
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function">ing <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> act, <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> oact)</span></span>;</div></pre></td></tr></table></figure>
<p>其中， <em>signo</em> 是要检查的信号编号， <em>act</em> 指针非空，则是要修改动作，如果 <em>oact</em> 非空则会经由该指针返回该信号的上一个动作。<br>使用数据结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sigaction</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (*sa_handler) (<span class="keyword">int</span>);<span class="comment">//信号捕获函数的地址</span></div><div class="line">    <span class="keyword">sigset_t</span> sa_mask;<span class="comment">//信号集，调用捕获函数之前，加到信号屏蔽字中</span></div><div class="line">    <span class="keyword">int</span> sa_flags;<span class="comment">//信号处理的选项</span></div><div class="line">    <span class="keyword">void</span> (*sa_restorer) (<span class="keyword">void</span>);<span class="comment">//没有使用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h4><p><strong>信号屏蔽字</strong>规定了当前阻塞而不能递送给该进程的信号集，调用 <em>sigprocmask</em> 函数可以检测和更改其信号屏蔽字，或同时执行两个动作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;</div></pre></td></tr></table></figure></p>
<p> <em>oset</em> 为非空指针，那么进程的当前信号屏蔽字通过 <em>oset</em> 返回。 <em>set</em> 为空，不改变进程的屏蔽字， <em>set</em> 非空，由 <em>how</em> 指定如何修改。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程，第10章 信号，读书笔记。信号是一种软件中断，用于处理异步事件。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>googletest使用</title>
    <link href="http://abumaster.com/2017/05/21/googletest%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2017/05/21/googletest使用/</id>
    <published>2017-05-21T03:02:25.000Z</published>
    <updated>2017-05-21T09:15:48.244Z</updated>
    
    <content type="html"><![CDATA[<p>googletest是Google的一个C++单元测试框架，<a href="https://github.com/google/googletest">Github地址</a>。其中包括了googletest和googlemock。使测试具有良好的独立性和重用性，并可以跨平台使用。<br><a id="more"></a></p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>从<a href="https://github.com/google/googletest">github</a>下载源码，本地解压。在 Windows 平台下用vs打开<code>msvc</code>目录中的<code>gtest.sln</code>，全部生成，根据平台的不同会在同目录下的debug和release中生成<code>gtestd.lib</code>和<code>gtest_maind.lib</code>，用时拷贝include和lib文件，并在工程项目中添加依赖。Linux平台下用cmake生成，在源文件目录下创建一个新文件目录如<code>build</code>，进入<code>build</code>打开终端输入<code>cmake ..</code>，生成<code>makefile</code>文件，输入<code>make</code>，生成<code>libgtest.a</code>文件，使用时将include文件包含入项目，动态链接<code>-lgtest</code>由于用到线程也需要链接<code>-lpthread</code>。更多详细信息可以在源码的<a href="https://github.com/google/googletest/blob/master/googletest/README.md">README.MD</a>。  </p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><blockquote>
<p>Google Test 中使用了类似宏的断言来定义测试内容。一般分为两个版本：<code>ASSERT_*</code>，错误抛出异常并终止运行；<code>EXPECT_*</code>生成不致命的错误，不会终止功能的运行。</p>
</blockquote>
<h4 id="基本断言"><a href="#基本断言" class="headerlink" title="基本断言"></a>基本断言</h4><p>用于判断true/false的断言。  </p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>致命断言</strong></th>
<th style="text-align:left"><strong>非致命</strong></th>
<th style="text-align:left"><strong>验证</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ASSERT_TRUE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><code>EXPECT_TRUE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><em>condition</em> is true</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_FALSE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><code>EXPECT_FALSE(</code><em>condition</em><code>)</code>;</td>
<td style="text-align:left"><em>condition</em> is false</td>
</tr>
</tbody>
</table>
<h4 id="二元比较"><a href="#二元比较" class="headerlink" title="二元比较"></a>二元比较</h4><p>测试比较两个值。  </p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>致命断言</strong></th>
<th style="text-align:left"><strong>非致命断言</strong></th>
<th style="text-align:left"><strong>验证</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ASSERT_EQ(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_EQ(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>==</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>!=</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&lt;</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&lt;=</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&gt;</code> <em>val2</em></td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td style="text-align:left"><em>val1</em> <code>&gt;=</code> <em>val2</em></td>
</tr>
</tbody>
</table>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>测试两个字符串string。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>致命断言</strong></th>
<th style="text-align:left"><strong>非致命断言</strong></th>
<th style="text-align:left"><strong>验证</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ASSERT_STREQ(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STREQ(</code><em>str1</em><code>,</code>_str_2<code>);</code></td>
<td style="text-align:left">两个c字符串有相同的内容</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_STRNE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STRNE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left">两个c字符串不同</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_STRCASEEQ(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STRCASEEQ(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left">两字符串相同，忽略案例</td>
</tr>
<tr>
<td style="text-align:left"><code>ASSERT_STRCASENE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left"><code>EXPECT_STRCASENE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td style="text-align:left">两字符串不同，忽略用例</td>
</tr>
</tbody>
</table>
<h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><h4 id="创建简单测试"><a href="#创建简单测试" class="headerlink" title="创建简单测试"></a>创建简单测试</h4><p>创建简单测试的过程：</p>
<ol>
<li>使用<code>TEST()</code>宏定义和命名一个测试函数，不需要返回值，像普通的c++函数一样；  </li>
<li>在其中可以使用任何合法的C++语句，并包含Googletest的测试宏，用来检查值；  </li>
<li>由其中定义的宏决定返回值，成功或者失败。  </li>
</ol>
<p>如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TEST(test_case_name, test_name) &#123;</div><div class="line"> <span class="comment">//具体测试宏和普通语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数为测试用例的名字，第二个参数为测试的名字，名字符合C++命名规范。  </p>
<p><strong>例子：</strong>  </p>
<blockquote>
<p>测试一个函数 <code>int Factorial(int n); // 返回n的阶乘</code></p>
</blockquote>
<p>则测试用例可以写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Tests factorial of 0.</span></div><div class="line">TEST(FactorialTest, HandlesZeroInput) &#123;</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tests factorial of positive numbers.</span></div><div class="line">TEST(FactorialTest, HandlesPositiveInput) &#123;</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">1</span>));</div><div class="line">  EXPECT_EQ(<span class="number">2</span>, Factorial(<span class="number">2</span>));</div><div class="line">  EXPECT_EQ(<span class="number">6</span>, Factorial(<span class="number">3</span>));</div><div class="line">  EXPECT_EQ(<span class="number">40320</span>, Factorial(<span class="number">8</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述一个测试用例，包含了两个不同输入的测试。  </p>
<h4 id="Test-Fixture-为不同测试配置相同的数据"><a href="#Test-Fixture-为不同测试配置相同的数据" class="headerlink" title="Test Fixture 为不同测试配置相同的数据"></a>Test Fixture 为不同测试配置相同的数据</h4><p>写了多组测试，需要用到相似的数据，这时就需要 <em>test fexture</em> ，可以在不同测试中使用相同的对象配置。创建一个 <em>fixture</em> 的过程如下：  </p>
<ol>
<li>先从 <code>::testing::Test</code> 类中继承一个类，成员函数定义为 <code>public:</code> 或者 <code>protected:</code>，可以使子类访问；  </li>
<li>在类中定义你想用到的对象；  </li>
<li>如果有必要可以写一个默认构造函数或者 <code>SetUp()</code> 函数，来准备测试所需的对象；  </li>
<li>如果有必要写一个析构函数或者 <code>TearDown()</code> 函数，来释放申请的资源信息，与上一步配对使用；  </li>
<li>为测试写子程序。  </li>
</ol>
<p>同样，<code>TEST_F()</code> 取代了上面的 <code>TEST()</code> 宏，允许访问 <em>test fixture</em> 中的子程序和对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TEST_F(test_case_name, test_name) &#123;</div><div class="line"> <span class="comment">//测试</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <em>第一个参数</em> 为测试用例的名称，必须为 <em>test fixture</em> 类的名称（_F 代表了 fixture）。如何使用。<br> <strong>例子：</strong><br>需要测试的一个类 <code>Queue</code> 定义如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="comment">// E is the element type.</span></div><div class="line"><span class="keyword">class</span> Queue &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Queue();</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(<span class="keyword">const</span> E&amp; element)</span></span>;</div><div class="line">  <span class="function">E* <span class="title">Dequeue</span><span class="params">()</span></span>; <span class="comment">// Returns NULL if the queue is empty.</span></div><div class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义 fixture 类，命名规范如果待测试的类为 <code>Foo</code> 则 fixture 类命名为 <code>FooTest</code> 。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> QueueTest : <span class="keyword">public</span> ::testing::Test &#123;</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</div><div class="line">    q1_.Enqueue(<span class="number">1</span>);</div><div class="line">    q2_.Enqueue(<span class="number">2</span>);</div><div class="line">    q2_.Enqueue(<span class="number">3</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// virtual void TearDown() &#123;&#125;</span></div><div class="line"></div><div class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</div><div class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</div><div class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用 <code>TES_F()</code> 和 <code>fixture class</code> 创建测试
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">TEST_F(QueueTest, IsEmptyInitially) &#123;</div><div class="line">  EXPECT_EQ(<span class="number">0</span>, q0_.size());</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_F(QueueTest, DequeueWorks) &#123;</div><div class="line">  <span class="keyword">int</span>* n = q0_.Dequeue();</div><div class="line">  EXPECT_EQ(<span class="literal">NULL</span>, n);</div><div class="line"></div><div class="line">  n = q1_.Dequeue();</div><div class="line">  ASSERT_TRUE(n != <span class="literal">NULL</span>);</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, *n);</div><div class="line">  EXPECT_EQ(<span class="number">0</span>, q1_.size());</div><div class="line">  <span class="keyword">delete</span> n;</div><div class="line"></div><div class="line">  n = q2_.Dequeue();</div><div class="line">  ASSERT_TRUE(n != <span class="literal">NULL</span>);</div><div class="line">  EXPECT_EQ(<span class="number">2</span>, *n);</div><div class="line">  EXPECT_EQ(<span class="number">1</span>, q2_.size());</div><div class="line">  <span class="keyword">delete</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进行如上工作时，如何运作的呢？  </p>
<ol>
<li>构造一个 <code>QueueTest</code> 对象，如<code>t1</code>；  </li>
<li>调用 <code>t1.SetUp()</code> 来初始化 <code>t1</code> ；  </li>
<li>在 <code>t1</code> 上运行第一个测试 <code>IsEmptyInitially</code> ；</li>
<li>测试完成后，调用<code>t1.TearDown()</code> ；  </li>
<li>析构 <code>t1</code> ；  </li>
<li>重复上述测试。</li>
</ol>
<h3 id="调用测试"><a href="#调用测试" class="headerlink" title="调用测试"></a>调用测试</h3><p>初始化，运行所有测试，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line"></span>&#123;</div><div class="line">	testing::InitGoogleTest(&amp;argc, argv);</div><div class="line">	<span class="keyword">return</span> RUN_ALL_TESTS();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;googletest是Google的一个C++单元测试框架，&lt;a href=&quot;https://github.com/google/googletest&quot;&gt;Github地址&lt;/a&gt;。其中包括了googletest和googlemock。使测试具有良好的独立性和重用性，并可以跨平台使用。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="测试" scheme="http://abumaster.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-进程</title>
    <link href="http://abumaster.com/2017/05/19/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/05/19/UNIX环境高级编程-进程/</id>
    <published>2017-05-19T02:22:59.000Z</published>
    <updated>2017-05-20T10:10:09.644Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程，第7、8、9章有关进程的读书笔记。<br><a id="more"></a></p>
<h3 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h3><p>进程的启动和终止。一般c程序从入口函数<code>main</code>开始，调用一系列用户函数等；进程终止有正常终止和异常终止两种，其中，正常终止是程序从main函数返回(return)，或者正常调用退出函数<code>exit _exit _Exit</code>，或者线程的返回或退出，异常终止通常会调用<code>abort</code>或者信号中断。<br><strong>命令行参数和环境表</strong><br>它们都是有外界给程序的参数，就像标注的 ISO C 规定的主函数书写格式
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[]</span></span></div></pre></td></tr></table></figure></p>
<p>将命令行参数保存，而环境变量表则被取消了，仍可以通过函数访问环境表。 
查看和设置环境变量，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* envname)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;<span class="comment">//不会分配空间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;<span class="comment">//分配空间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>C 程序的存储空间分布</strong><br>如图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-19/39758826-file_1495161867318_14f4a.png" alt="">   </p>
<ul>
<li>正文段，存放程序运行所需的机器指令部分，具有只读属性；  </li>
<li>初始化数据段，明确初始化的变量；</li>
<li>未初始化的数据；  </li>
<li>栈，存放自动变量或者临时变量；  </li>
<li>堆，动态分配的空间。  </li>
</ul>
<p><strong>非局部goto</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;<span class="comment">//设置返回的位置</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;<span class="comment">//开始返回</span></div></pre></td></tr></table></figure></p>
<p>回滚一些变量的值，如果不想回滚到之前的值，可以将变量定义为：volatile，全局或静态变量的值也会保持不变。  </p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>进程标识符</strong><br>非负整型来表示唯一进程ID，但是可以重用，通常ID=0表示交换进程或者调度进程，ID=1表示init进程，ID=2表示页守护进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getpid();<span class="comment">//进程ID</span></div><div class="line"><span class="keyword">pid_t</span> getppid();<span class="comment">//父进程ID</span></div></pre></td></tr></table></figure></p>
<p><strong>fork函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure></p>
<p>两个返回，子进程返回0，通过getppid获得父进程id，ID为0，是交换进程使用，父进程返回子进程的ID，因为，这是父进程获得子进程ID的唯一方式。<br><strong>exec函数</strong><br>fork创建新进程，exec可以执行新程序，exit处理终止，wait等待终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *argv0, ..., <span class="comment">/*char *const envp[]*/</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv0, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</div></pre></td></tr></table></figure>
区别前四个函数取路径名，后两个取文件名作为参数。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-20/96247138-file_1495261874685_e1b6.png" alt="exec函数区别"><br><strong>system函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</div></pre></td></tr></table></figure></p>
<p>用于执行一个命令字符串，调用了<code>fork</code>函数，<code>exec</code>函数，<code>waitpid</code>函数。  </p>
<h3 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h3><p>终端登录和网络登录的进程关系图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-20/25743922-file_1495274895570_15325.png" alt="">
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-20/24107374-file_1495274948060_6d4e.png" alt="">  </p>
<p><strong>进程组</strong><br>进程组是一个或多个进程的集合，通常与一个作业关联。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);<span class="comment">//调用进程的进程组ID</span></div><div class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);<span class="comment">//pid的进程组ID</span></div><div class="line"><span class="comment">//getpgrp()等价于getpgid(0);</span></div></pre></td></tr></table></figure></p>
<p><strong>会话</strong><br>会话是一个或多个进程组的集合。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程，第7、8、9章有关进程的读书笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-标准IO库</title>
    <link href="http://abumaster.com/2017/05/18/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
    <id>http://abumaster.com/2017/05/18/UNIX环境高级编程-标准IO库/</id>
    <published>2017-05-18T00:39:42.000Z</published>
    <updated>2017-05-18T02:11:33.522Z</updated>
    
    <content type="html"><![CDATA[<p>Unix环境高级编程读书笔记，第5章 标准I/O库。引入流的概念，并引入缓冲，减少read和write的调用次数。<br><a id="more"></a></p>
<p><strong>1.文件I/O和标准I/O区别</strong><br>标准I/O使用了缓冲机制，文件I/O不使用，而是直接调用内核中的一个系统调用完成。操作的对象不同，文件io操作的是文件描述符，标准io操作的是流，流与磁盘等外围设备关联。他们的函数对比。  </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>标准I/O</th>
<th>文件I/O</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开</td>
<td>fopen, froen, fdopen</td>
<td>open</td>
</tr>
<tr>
<td>关闭</td>
<td>fclose</td>
<td>close</td>
</tr>
<tr>
<td>读</td>
<td>getc, fgetc, getchar,<br>fgets, gets,<br>fread</td>
<td>read</td>
</tr>
<tr>
<td>写</td>
<td>putc, fputc, putchar,<br>fputs, puts,<br>fwrite</td>
<td>write</td>
</tr>
</tbody>
</table>
<p><strong>2.缓冲</strong>  </p>
<blockquote>
<p>标准I/O提供的几种缓冲及其区别。  </p>
</blockquote>
<ul>
<li>全缓冲，填满缓冲区后再进行实际的I/O操作，磁盘文件通常使用全缓冲。填满缓冲区后，调用fflush来刷新缓冲区，flush(冲洗)用来将缓冲区的内容写到磁盘上；flush(刷清)丢弃已经存储在缓冲区中的数据，用在终端驱动程序方面。  </li>
<li>行缓冲，用在终端的输入输出，遇到换行符的时候，或者缓冲区满。  </li>
<li>无缓冲，标准出错流，stderr，错误信息及时显示出来。  </li>
</ul>
<p>对于一个打开的流，设置更改缓冲区。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="comment">/* 	mode 参数：</div><div class="line">	_IOFBF 全缓冲；_IOLBF 行缓冲；_IONBF 不带缓冲</div><div class="line"> */</span></div><div class="line"><span class="comment">//强制冲洗流</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>3.操作</strong><br><strong>打开关闭流</strong><br>打开关闭标准I/O流，如上表的函数所示。<br><strong>读写流</strong><br>打开了流，有三种类型的方式进行读写操作：  </p>
<ul>
<li>每次一个字符的I/O;  </li>
<li>每次一行的I/O;  </li>
<li>直接I/O。  </li>
</ul>
<p>每个流在FILE对象上维持了两个标志：出错标志，文件结束标志。<br><code>gets</code> 和<code>fgets</code>，不推荐使用前者，因为不能指定缓冲区大小，容易造成缓冲区溢出，另外，<code>gets</code>不保留换行符。<br><strong>4.临时文件</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;<span class="comment">//指向唯一路径的指针</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回文件指针</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix环境高级编程读书笔记，第5章 标准I/O库。引入流的概念，并引入缓冲，减少read和write的调用次数。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="c" scheme="http://abumaster.com/tags/c/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-文件和目录</title>
    <link href="http://abumaster.com/2017/05/16/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>http://abumaster.com/2017/05/16/UNIX环境高级编程-文件和目录/</id>
    <published>2017-05-16T11:39:00.000Z</published>
    <updated>2017-05-17T06:52:07.469Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX环境高级编程读书笔记，第4章 文件和目录。<br><a id="more"></a></p>
<blockquote>
<p>I/O操作描述的是普通文件的读写等操作，本章介绍文件系统的其他特征和文件的性质。  </p>
</blockquote>
<p><strong>1.三个stat函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div></pre></td></tr></table></figure></p>
<p>返回与此文件相关联的信息结构stat，关于stat的结构说明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stat &#123;</div><div class="line">	<span class="keyword">mode_t</span> st_mode;<span class="comment">//文件类型</span></div><div class="line">	<span class="keyword">ino_t</span> st_ino;<span class="comment">//i节点</span></div><div class="line">	<span class="keyword">dev_t</span> st_dev;<span class="comment">//设备号 文件系统</span></div><div class="line">	<span class="keyword">dev_t</span> st_rdev;</div><div class="line">	<span class="keyword">nlink_t</span> st_nlink;</div><div class="line">	<span class="keyword">uid_t</span> st_uid;</div><div class="line">	<span class="keyword">gid_t</span> st_gid;</div><div class="line">	<span class="keyword">off_t</span> st_size;<span class="comment">//大小</span></div><div class="line">	<span class="keyword">time_t</span> st_atime;<span class="comment">//访问时间</span></div><div class="line">	<span class="keyword">time_t</span> st_mtime;<span class="comment">//修改时间</span></div><div class="line">	<span class="keyword">time_t</span> st_ctime;<span class="comment">//改变时间</span></div><div class="line">	<span class="keyword">blksize_t</span> st_blksize;<span class="comment">//块大小</span></div><div class="line">	<span class="keyword">blkcnt_t</span> st_blocks;<span class="comment">//分配的磁盘块</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2.文件类型</strong>  </p>
<ul>
<li>普通文件；  </li>
<li>目录文件；  </li>
<li>块特殊文件；  </li>
<li>字符特殊文件；  </li>
<li>FIFO，进程间通信，命名管道；</li>
<li>套接字，网络间通信；  </li>
<li>符号链接<br>在<code>&lt;sys/stat.h&gt;</code>中定义了获取文件类型的宏，参数为<code>st_mode</code>成员。  </li>
</ul>
<table>
<thead>
<tr>
<th>宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_ISREG()</td>
<td>普通文件</td>
</tr>
<tr>
<td>S_ISDIR()</td>
<td>目录文件</td>
</tr>
<tr>
<td>S_ISCHR()</td>
<td>字符特殊文件</td>
</tr>
<tr>
<td>S_ISBLK()</td>
<td>块特殊文件</td>
</tr>
<tr>
<td>S_ISFIFO()</td>
<td>管道或FIFO</td>
</tr>
<tr>
<td>S_ISLNK()</td>
<td>符号链接</td>
</tr>
<tr>
<td>S_ISSOCK()</td>
<td>套接字</td>
</tr>
</tbody>
</table>
<p><strong>3.文件的访问权限</strong><br>分为三类：用户、组、其他，而每类对应的权限为：读、写、执行。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-16/90333911-file_1494936405039_f79a.png" alt=""><br><strong>4.文件系统</strong><br>i节点：固定长度的记录项，保存着文件的大部分信息。<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">理解inode</a>。内核中，以inode编号来标识文件，而不是以文件名标识文件。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX环境高级编程读书笔记，第4章 文件和目录。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程-文件IO</title>
    <link href="http://abumaster.com/2017/05/15/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/"/>
    <id>http://abumaster.com/2017/05/15/UNIX环境高级编程-文件IO/</id>
    <published>2017-05-15T12:29:43.000Z</published>
    <updated>2017-05-16T12:46:55.147Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX环境高级编程读书笔记，第3章 文件 I/O。
<a id="more"></a></p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>Linux一切皆文件，无论是设备还是文档都是一个文件，这种抽象显示了Linux系统的灵活和通用性。文件描述符一般是一个非负整数，当打开或者创建一个文件时，内核向进程返回一个文件描述符，此描述符用于其他操作的参数。<br>通常在<code>unistd.h</code>中定义了常量：<code>STDIN_FILENO STDOUT_FILENO STDERR_FILENO</code>分别代表数字0,1,2是标准输入输出错误输出三种基本的文件描述符。<br><strong>open函数</strong><br>描述：打开或者创建文件，返回文件描述符或者-1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">oepn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags,...<span class="comment">/*mode_t mode*/</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>creat函数</strong><br>描述：创建一个文件，只能只写的方式打开，成功返回文件描述符，失败-1<br><strong>close函数</strong><br>描述：关闭文件描述符<br><strong>lseek函数</strong><br>描述：为一个打开的文件描述符设置偏移量，成功返回新的文件偏移量，失败-1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div></pre></td></tr></table></figure></p>
<p>偏移量的方式取决于第三个参数。<code>SEEK_SET</code> 开始处设置偏移量，绝对偏移量；<code>SEEK_CUR</code> 当前位置设置偏移量，相对偏移量；<code>SEEK_END</code> 结束开始设置偏移量，相对于文件末端偏移量。<br><strong>read函数</strong><br>打开的文件中读取数据，返回读取的字节数，如果剩余文件不够要读的字节数。<br><strong>write函数</strong><br>向打开的文件中写数据，返回实际写入的数据字节数。  </p>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>不同进程之间共享打开的文件，内核使用三种数据结构表示打开的文件。<br><strong>1.进程表项</strong><br>描述一个打开的文件描述表，每个文件描述符表包含了两项：  </p>
<ul>
<li>文件描述符标志   </li>
<li>指向文件表项的指针<br><strong>2.文件表</strong><br>每个文件表包含如下信息：  </li>
<li>文件状态标志（读写…)  </li>
<li>当前文件偏移量  </li>
<li>指向文件v节点表项的指针<br><strong>3.v节点表</strong><br>v节点表表示文件类型，以及对文件进行各种操作的指针，也包含了i节点及文件长度等信息。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-15/62478241-file_1494854203087_11715.png" alt=""><br>不同进程打开同一个文件的各项状态。  </li>
</ul>
<p><strong>dup和dup2函数</strong><br>用来复制一个现存的文件描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> filedes2)</span></span>;</div></pre></td></tr></table></figure></p>
<p>dup返回的文件描述符是当前可用文件描述符的最小值；dup2可以用filedes来指定新的描述符，如果filedes2已经打开，则先将其关闭，如果相等，则返回filedes2，不必关闭。<br>执行dup后，文件表项和v节点表项不变。<br>作用：一般用于重定向和共享文件，如父进程处理了一些文件，现在需要子进程处理，可以dup一份；同样dup2的使用，可以看为<code>dup2(源, 目标)</code>，目标将会被源替换掉。具体<a href="http://blog.csdn.net/zhouhong1026/article/details/8151235">使用</a>。<br><strong>fcntl函数</strong><br>可以读取和改变打开文件的性质。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> cmd, ...<span class="comment">/*int arg*/</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>fnctl的功能：  </p>
<p><1>    复制一个现有的描述符，cmd=F_DUPFD</1>  </p>
<p><2>    获取/设置文件描述符标记(cmd=F_GETFD / F_SETFD)</2>  </p>
<p><3>    获得和设置文件状态标志<code>cmd=F_GETFL F_SETFL</code></3>  </p>
<p><4>    获取和设置异步I/O所有权<code>cmd=F_GETOWN F_SETOWN</code></4>  </p>
<p><5>    获得和设置记录锁<code>cmd = F_GETLK F_SETLK</code></5><br>同样，复制文件描述符函数：<code>dup(filedes)</code>等价于<code>fcntl(filedes, F_DUPFD, 0)</code>。调用<code>dup2(filedes1,filedes2)</code>相当于调用：<code>close(filedes2); fcntl(filedes1, F_DUPFD, filedes2)</code>。不同之处在于dup2函数是原子操作，而用fcntl是两个函数调用。<br>dup2的功能:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dup2(fd, <span class="number">0</span>);</div><div class="line">dup2(fd, <span class="number">1</span>);</div><div class="line">dup2(fd, <span class="number">2</span>);</div><div class="line"><span class="keyword">if</span>(fd &gt; <span class="number">2</span>)</div><div class="line">	close(fd);</div></pre></td></tr></table></figure></p>
<p>假设fd=1，则执行后的结果图如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-16/22619423-file_1494918444995_14a6d.png" alt=""><br>fd=3时，结果同，把3的文件复制到前3个上，删除以后的。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX环境高级编程读书笔记，第3章 文件 I/O。
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>High-performance Semantic Segmentation using VDFC</title>
    <link href="http://abumaster.com/2017/05/10/High-performance-Semantic-Segmentation-using-VDFC/"/>
    <id>http://abumaster.com/2017/05/10/High-performance-Semantic-Segmentation-using-VDFC/</id>
    <published>2017-05-10T07:37:56.000Z</published>
    <updated>2017-05-10T13:22:27.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>High-performance Semantic Segmentation Using Very Deep Fully Convolution [1] ，论文阅读笔记。</p>
</blockquote>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default">
</script>

<a id="more"></a>
<p>本文做的贡献：</p>
<ul>
<li>探索不同的<strong>全卷积残差网络</strong>找到更好的配置，诸如，网络的层数、特征图的分辨率、感受野的大小等，由于内存的限制等因素，提出了用低分辨率网络来模拟高分辨网络进行训练和测试；  </li>
<li>提出了<strong>在线引导（online booststrapping）</strong>的方法进行训练，已经论证可以达到更好的正确率；  </li>
<li>将传统的dropout应用到残差块中；  </li>
<li>达到了很好的结果。</li>
</ul>
<h4 id="1-低分辨率近似高分辨率的模型"><a href="#1-低分辨率近似高分辨率的模型" class="headerlink" title="1.低分辨率近似高分辨率的模型"></a>1.低分辨率近似高分辨率的模型</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-10/90074102-file_1494405779021_148f4.png" alt=""><br>由于内存的限制，网络不允许输入过大分辨率的图像，但是分辨率大的图像往往可以保存更多的细节信息，可以达到更好的分割效果，所以，提出了这个低分辨率来近似高分辨率的模型。基本的做法是：如果输入一个图像，经过了中间的若干层，图像的分辨率会下降，假设缩小为原始的1/8，（1）产生了一个1/8的特征图，这时，（2）可以在上一层池化层提取出剩下1/8的图像，（3）分别获得两个1/8的得分图，（4）组合，得到1/4的得分图或者是标签。</p>
<h4 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h4><p>$$ e = -\frac{1}{\sum_i^N \sum_j^K{1\{y_i=j\ and\ p_{ij}&lt;t\}}}(\sum_i^N\sum_j^K1\{y_i=j \ and\ p_{ij}&lt;t\}logp_{ij})$$   </p>
<p>[1] Wu Z, Shen C, Hengel A. High-performance semantic segmentation using very deep fully convolutional networks[J]. arXiv preprint arXiv:1604.04339, 2016.</p>
<p>K表示语义标签，N表示像素的个数，$p_{ij}$表示像素$a_i$分到标签$c_j$的概率，$y_i$表示$a_i$的正确标签。符号$1{.}$表示满足括号里的条件为1，不满足为0。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;High-performance Semantic Segmentation Using Very Deep Fully Convolution [1] ，论文阅读笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;
&lt;/script&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>宏定义</title>
    <link href="http://abumaster.com/2017/05/09/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://abumaster.com/2017/05/09/宏定义/</id>
    <published>2017-05-09T12:36:26.000Z</published>
    <updated>2017-05-09T13:35:49.257Z</updated>
    
    <content type="html"><![CDATA[<p>宏定义进入编译器之前展开替换。<br><a id="more"></a>
<strong>宏常量</strong><br><code>#define MAX 100</code>用100替换符号MAX，c++中一般不推荐使用，通常用常量const定义；<br><strong>用于条件编译的宏</strong><br>如避免包含重复头文件的宏：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifdefine XXX </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> XXX </span></div><div class="line"><span class="comment">//some include file</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">`</div></pre></td></tr></table></figure></p>
<p><strong>宏函数</strong><br>避免函数调用，提高执行效率，以空间换取时间。<br>对于一些重复的函数可以声明为宏函数，就像内联函数一样…<br>例子：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Onefunction)</span><span class="params">()</span></span>;<span class="comment">//定义函数指针</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, Onefunction&gt; OneMap;<span class="comment">//名称，函数指针相关联的map</span></div><div class="line">OneMap g_one_map;<span class="comment">//全局变量保存</span></div><div class="line"></div><div class="line"><span class="comment">//注册函数的宏，其中展开为一个按名定义的类，</span></div><div class="line"><span class="comment">//构造函数,将函数地址和函数名称放入全局的map中</span></div><div class="line"><span class="comment">//最后一个简单的类对象声明，可以保证构造函数的执行，</span></div><div class="line"><span class="comment">//作用域可以保证在执行完后对象的销毁，用过即销毁。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RegisterOneFunction(func) \</div><div class="line">&#123; \</div><div class="line">class __Register_##func &#123; \</div><div class="line">public: \</div><div class="line">__Register_##func() &#123; \</div><div class="line">g_one_map[#func] = &amp;func; \</div><div class="line">&#125; \</div><div class="line">&#125;; \</div><div class="line">__Register_##func g_register_##func; \</div><div class="line">&#125;</span></div><div class="line"><span class="comment">//自定义的函数，无参，返回int</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func1 out...\n"</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func2 out...222\n"</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用宏，注册函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">WrapperRegisterFunction</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	RegisterOneFunction(func1);</div><div class="line">	RegisterOneFunction(func2);</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据函数名称获得函数的指针</span></div><div class="line"><span class="function">Onefunction <span class="title">GetOneFunction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; fname)</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="keyword">if</span>(g_one_map.count(fname))</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> g_one_map[fname];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">for</span>(OneMap::iterator it=g_one_map.begin();</div><div class="line">			it!=g_one_map.end(); it++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span> &lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">	<span class="built_in">string</span> funNmae;</div><div class="line"></div><div class="line">	WrapperRegisterFunction();</div><div class="line"></div><div class="line">	<span class="built_in">cin</span> &gt;&gt; funNmae;</div><div class="line">	<span class="comment">//以名称来使用函数</span></div><div class="line">	GetOneFunction(funNmae)();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>  </p>
<p>1.普通宏定义  </p>
<ul>
<li>宏名一般用大写  </li>
<li>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改  </li>
<li>预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查  </li>
<li>宏定义末尾不加分号  </li>
<li>宏定义写在函数的花括号外边，作用域为其后的程序，通常在文件的最开头  </li>
<li>可以用#undef命令终止宏定义的作用域  </li>
<li>宏定义可以嵌套   </li>
<li>字符串””中永远不包含宏  </li>
<li>宏定义不分配内存，变量定义分配内存<br>2.带参宏定义  </li>
<li>实参如果是表达式容易出问题  </li>
<li>宏名和参数的括号间不能有空格  </li>
<li>宏替换只作替换，不做计算，不做表达式求解  </li>
<li>函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存  </li>
<li>宏的哑实结合不存在类型，也没有类型转换  </li>
<li>函数只有一个返回值，利用宏则可以设法得到多个值  </li>
<li>宏展开使源程序变长，函数调用不会  </li>
<li>宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;宏定义进入编译器之前展开替换。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>caffe学习-分类</title>
    <link href="http://abumaster.com/2017/05/07/caffe%E5%AD%A6%E4%B9%A0-%E5%88%86%E7%B1%BB/"/>
    <id>http://abumaster.com/2017/05/07/caffe学习-分类/</id>
    <published>2017-05-07T11:29:00.000Z</published>
    <updated>2017-05-08T12:39:47.386Z</updated>
    
    <content type="html"><![CDATA[<p>在用caffe的c++接口时，遇到了许多问题，学习源码中解决问题，熟悉一些细节。<br><a id="more"></a>
<strong>1.预测分类的流程图</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-5-8/16381803-file_1494210884331_288e.png" alt="预测流程图">  </p>
<p><strong>2.代码注释</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div></pre></td><td class="code"><pre><div class="line">//classification.cpp</div><div class="line">/*一些头文件*/</div><div class="line">#ifdef USE_OPENCV</div><div class="line">/* Pair (label, confidence) </div><div class="line"> * 代表一个预测结果，标签和概率的组合</div><div class="line"> */</div><div class="line">typedef std::pair&lt;string, float&gt; Prediction;</div><div class="line">//定义一个分类的类</div><div class="line">class Classifier &#123;</div><div class="line"> public:</div><div class="line">  Classifier(const string&amp; model_file,</div><div class="line">             const string&amp; trained_file,</div><div class="line">             const string&amp; mean_file,</div><div class="line">             const string&amp; label_file);</div><div class="line">//提供给外部的接口，返回一个预测。参数：需要预测的图像和概率最大的N个结果</div><div class="line">  std::vector&lt;Prediction&gt; Classify(const cv::Mat&amp; img, int N = 5);</div><div class="line"></div><div class="line"> private:</div><div class="line">  void SetMean(const string&amp; mean_file);//设置中值</div><div class="line">  std::vector&lt;float&gt; Predict(const cv::Mat&amp; img);</div><div class="line">  void WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels);</div><div class="line">  void Preprocess(const cv::Mat&amp; img,</div><div class="line">                  std::vector&lt;cv::Mat&gt;* input_channels);</div><div class="line"></div><div class="line"> private:</div><div class="line">  shared_ptr&lt;Net&lt;float&gt; &gt; net_;</div><div class="line">  cv::Size input_geometry_;</div><div class="line">  int num_channels_;</div><div class="line">  cv::Mat mean_;</div><div class="line">  std::vector&lt;string&gt; labels_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Classifier::Classifier(const string&amp; model_file,</div><div class="line">                       const string&amp; trained_file,</div><div class="line">                       const string&amp; mean_file,</div><div class="line">                       const string&amp; label_file) &#123;</div><div class="line">#ifdef CPU_ONLY</div><div class="line">  Caffe::set_mode(Caffe::CPU);</div><div class="line">#else</div><div class="line">  Caffe::set_mode(Caffe::GPU);</div><div class="line">#endif</div><div class="line">  //加载网络配置并初始化</div><div class="line">  net_.reset(new Net&lt;float&gt;(model_file, TEST));</div><div class="line">  net_-&gt;CopyTrainedLayersFrom(trained_file);</div><div class="line">  CHECK_EQ(net_-&gt;num_inputs(), 1) &lt;&lt; "Network should have exactly one input.";</div><div class="line">  CHECK_EQ(net_-&gt;num_outputs(), 1) &lt;&lt; "Network should have exactly one output.";</div><div class="line">  //取出输入层的blob结构，可以提取出通道和输入图像的高宽</div><div class="line">  Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];</div><div class="line">  num_channels_ = input_layer-&gt;channels();</div><div class="line">  CHECK(num_channels_ == 3 || num_channels_ == 1)</div><div class="line">    &lt;&lt; "Input layer should have 1 or 3 channels.";</div><div class="line">  input_geometry_ = cv::Size(input_layer-&gt;width(), input_layer-&gt;height());</div><div class="line"></div><div class="line">  //加载中值文件</div><div class="line">  SetMean(mean_file);</div><div class="line"></div><div class="line">  //加载标签文件</div><div class="line">  std::ifstream labels(label_file.c_str());</div><div class="line">  CHECK(labels) &lt;&lt; "Unable to open labels file " &lt;&lt; label_file;</div><div class="line">  string line;</div><div class="line">  while (std::getline(labels, line))</div><div class="line">    labels_.push_back(string(line));</div><div class="line">  //检查标签数目和输出维度是否匹配</div><div class="line">  Blob&lt;float&gt;* output_layer = net_-&gt;output_blobs()[0];</div><div class="line">  CHECK_EQ(labels_.size(), output_layer-&gt;channels())</div><div class="line">    &lt;&lt; "Number of labels is different from the output layer dimension.";</div><div class="line">&#125;</div><div class="line">//自定义比较函数，用于排序预测结果</div><div class="line">static bool PairCompare(const std::pair&lt;float, int&gt;&amp; lhs,</div><div class="line">                        const std::pair&lt;float, int&gt;&amp; rhs) &#123;</div><div class="line">  return lhs.first &gt; rhs.first;</div><div class="line">&#125;</div><div class="line">//返回v中元素最大的N个数的下标索引</div><div class="line">static std::vector&lt;int&gt; Argmax(const std::vector&lt;float&gt;&amp; v, int N) &#123;</div><div class="line">  std::vector&lt;std::pair&lt;float, int&gt; &gt; pairs;</div><div class="line">  for (size_t i = 0; i &lt; v.size(); ++i)</div><div class="line">    pairs.push_back(std::make_pair(v[i], static_cast&lt;int&gt;(i)));</div><div class="line">  std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; result;</div><div class="line">  for (int i = 0; i &lt; N; ++i)</div><div class="line">    result.push_back(pairs[i].second);</div><div class="line">  return result;</div><div class="line">&#125;</div><div class="line">//输入图像，返回前N个概率最大的预测(标签，概率)</div><div class="line">std::vector&lt;Prediction&gt; Classifier::Classify(const cv::Mat&amp; img, int N) &#123;</div><div class="line">  std::vector&lt;float&gt; output = Predict(img);</div><div class="line"></div><div class="line">  N = std::min&lt;int&gt;(labels_.size(), N);</div><div class="line">  std::vector&lt;int&gt; maxN = Argmax(output, N);</div><div class="line">  std::vector&lt;Prediction&gt; predictions;</div><div class="line">  for (int i = 0; i &lt; N; ++i) &#123;</div><div class="line">    int idx = maxN[i];</div><div class="line">    predictions.push_back(std::make_pair(labels_[idx], output[idx]));</div><div class="line">  &#125;</div><div class="line">  return predictions;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Load the mean file in binaryproto format. */</div><div class="line">void Classifier::SetMean(const string&amp; mean_file) &#123;</div><div class="line">  BlobProto blob_proto;</div><div class="line">  ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &amp;blob_proto);</div><div class="line"></div><div class="line">  /* Convert from BlobProto to Blob&lt;float&gt; */</div><div class="line">  Blob&lt;float&gt; mean_blob;</div><div class="line">  mean_blob.FromProto(blob_proto);</div><div class="line">  CHECK_EQ(mean_blob.channels(), num_channels_)</div><div class="line">    &lt;&lt; "Number of channels of mean file doesn't match input layer.";</div><div class="line"></div><div class="line">  /* The format of the mean file is planar 32-bit float BGR or grayscale. */</div><div class="line">  std::vector&lt;cv::Mat&gt; channels;</div><div class="line">  float* data = mean_blob.mutable_cpu_data();</div><div class="line">  for (int i = 0; i &lt; num_channels_; ++i) &#123;</div><div class="line">    /* Extract an individual channel. */</div><div class="line">    cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);</div><div class="line">    channels.push_back(channel);</div><div class="line">    data += mean_blob.height() * mean_blob.width();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /* Merge the separate channels into a single image. */</div><div class="line">  cv::Mat mean;</div><div class="line">  cv::merge(channels, mean);</div><div class="line"></div><div class="line">  /* Compute the global mean pixel value and create a mean image</div><div class="line">   * filled with this value. */</div><div class="line">  cv::Scalar channel_mean = cv::mean(mean);</div><div class="line">  mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);</div><div class="line">&#125;</div><div class="line">//预测函数，返回输出的概率</div><div class="line">std::vector&lt;float&gt; Classifier::Predict(const cv::Mat&amp; img) &#123;</div><div class="line">  Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];</div><div class="line">  input_layer-&gt;Reshape(1, num_channels_,</div><div class="line">                       input_geometry_.height, input_geometry_.width);</div><div class="line">  /* Forward dimension change to all layers. */</div><div class="line">  net_-&gt;Reshape();</div><div class="line"></div><div class="line">  std::vector&lt;cv::Mat&gt; input_channels;</div><div class="line">  WrapInputLayer(&amp;input_channels);</div><div class="line"></div><div class="line">  Preprocess(img, &amp;input_channels);</div><div class="line"></div><div class="line">  net_-&gt;Forward();</div><div class="line"></div><div class="line">  /* Copy the output layer to a std::vector */</div><div class="line">  Blob&lt;float&gt;* output_layer = net_-&gt;output_blobs()[0];</div><div class="line">  const float* begin = output_layer-&gt;cpu_data();</div><div class="line">  const float* end = begin + output_layer-&gt;channels();</div><div class="line">  return std::vector&lt;float&gt;(begin, end);</div><div class="line">&#125;</div><div class="line"> /* 包装网络的输入层，将每个通道保存为Mat对象，</div><div class="line">  * 最后直接将分割的通道写入到输入层中 */</div><div class="line">void Classifier::WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels) &#123;</div><div class="line">  Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];</div><div class="line"></div><div class="line">  int width = input_layer-&gt;width();</div><div class="line">  int height = input_layer-&gt;height();</div><div class="line">  //获取可更改的输入层数据指针</div><div class="line">  float* input_data = input_layer-&gt;mutable_cpu_data();</div><div class="line">  for (int i = 0; i &lt; input_layer-&gt;channels(); ++i) &#123;</div><div class="line">    cv::Mat channel(height, width, CV_32FC1, input_data);</div><div class="line">    input_channels-&gt;push_back(channel);</div><div class="line">    input_data += width * height;</div><div class="line">  &#125;//将各个通道变为Mat，依次放入vector中</div><div class="line">&#125;</div><div class="line">//图像拷贝入输入层中</div><div class="line">void Classifier::Preprocess(const cv::Mat&amp; img,</div><div class="line">                            std::vector&lt;cv::Mat&gt;* input_channels) &#123;</div><div class="line">  /* 将输入图像转换为网络要求的输入格式 */</div><div class="line">  //通道数</div><div class="line">  cv::Mat sample;</div><div class="line">  if (img.channels() == 3 &amp;&amp; num_channels_ == 1)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);</div><div class="line">  else if (img.channels() == 4 &amp;&amp; num_channels_ == 1)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);</div><div class="line">  else if (img.channels() == 4 &amp;&amp; num_channels_ == 3)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);</div><div class="line">  else if (img.channels() == 1 &amp;&amp; num_channels_ == 3)</div><div class="line">    cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);</div><div class="line">  else</div><div class="line">    sample = img;</div><div class="line">  //大小</div><div class="line">  cv::Mat sample_resized;</div><div class="line">  if (sample.size() != input_geometry_)</div><div class="line">    cv::resize(sample, sample_resized, input_geometry_);</div><div class="line">  else</div><div class="line">    sample_resized = sample;</div><div class="line">  //浮点数</div><div class="line">  cv::Mat sample_float;</div><div class="line">  if (num_channels_ == 3)</div><div class="line">    sample_resized.convertTo(sample_float, CV_32FC3);</div><div class="line">  else</div><div class="line">    sample_resized.convertTo(sample_float, CV_32FC1);</div><div class="line">  //归一化处理：减去中值</div><div class="line">  cv::Mat sample_normalized;</div><div class="line">  cv::subtract(sample_float, mean_, sample_normalized);</div><div class="line">  //直接将mat拷贝到输入层，已经处理过输入层为Mat对象了</div><div class="line">  cv::split(sample_normalized, *input_channels);</div><div class="line">  CHECK(reinterpret_cast&lt;float*&gt;(input_channels-&gt;at(0).data)</div><div class="line">        == net_-&gt;input_blobs()[0]-&gt;cpu_data())</div><div class="line">    &lt;&lt; "Input channels are not wrapping the input layer of the network.";</div><div class="line">&#125;</div><div class="line">//主函数命令行调用</div><div class="line">int main(int argc, char** argv) &#123;</div><div class="line">  if (argc != 6) &#123;</div><div class="line">    std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0]</div><div class="line">              &lt;&lt; " deploy.prototxt network.caffemodel"</div><div class="line">              &lt;&lt; " mean.binaryproto labels.txt img.jpg" &lt;&lt; std::endl;</div><div class="line">    return 1;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ::google::InitGoogleLogging(argv[0]);</div><div class="line"></div><div class="line">  string model_file   = argv[1];</div><div class="line">  string trained_file = argv[2];</div><div class="line">  string mean_file    = argv[3];</div><div class="line">  string label_file   = argv[4];</div><div class="line">  Classifier classifier(model_file, trained_file, mean_file, label_file);</div><div class="line"></div><div class="line">  string file = argv[5];</div><div class="line"></div><div class="line">  std::cout &lt;&lt; "---------- Prediction for "</div><div class="line">            &lt;&lt; file &lt;&lt; " ----------" &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  cv::Mat img = cv::imread(file, -1);</div><div class="line">  CHECK(!img.empty()) &lt;&lt; "Unable to decode image " &lt;&lt; file;</div><div class="line">  std::vector&lt;Prediction&gt; predictions = classifier.Classify(img);</div><div class="line"></div><div class="line">  /* Print the top N predictions. */</div><div class="line">  for (size_t i = 0; i &lt; predictions.size(); ++i) &#123;</div><div class="line">    Prediction p = predictions[i];</div><div class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; p.second &lt;&lt; " - \""</div><div class="line">              &lt;&lt; p.first &lt;&lt; "\"" &lt;&lt; std::endl;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">#else</div><div class="line">int main(int argc, char** argv) &#123;</div><div class="line">  LOG(FATAL) &lt;&lt; "This example requires OpenCV; compile with USE_OPENCV.";</div><div class="line">&#125;</div><div class="line">#endif  // USE_OPENCV</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用caffe的c++接口时，遇到了许多问题，学习源码中解决问题，熟悉一些细节。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
  </entry>
  
  <entry>
    <title>Caffe笔记</title>
    <link href="http://abumaster.com/2017/05/01/Caffe%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2017/05/01/Caffe笔记/</id>
    <published>2017-05-01T06:41:52.000Z</published>
    <updated>2017-05-01T12:02:51.565Z</updated>
    
    <content type="html"><![CDATA[<p>Caffe学习中的遇到的一些问题拾遗。<br><a id="more"></a>
<strong>1..solverstate的使用</strong><br>在网络训练过程中当保存一个快照时，会保存两个文件：<code>**.caffemodel</code> 和 <code>**.solverstate</code> 第一个文件是训练过程中，迭代了N次，保存的模型，第二个文件是训练过程意外暂停，如<code>ctrl+C</code> 或者电脑死机，保存的网络状态，下一次网络可以接着训练，参考<a href="https://github.com/BVLC/caffe/wiki/Training-and-Resuming">Caffe Wiki - Training and Resuming</a>。<br>使用：  </p>
<ul>
<li>命令行<br>训练：<code>caffe train -solver solver.prototxt</code><br>状态中恢复训练：<code>caffe train -solver solver.prototxt -snapshot train_190000.solverstate</code>  </li>
<li>Python 接口<br>从模型中copy参数：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">weights = <span class="string">'../ilsvrc-nets/vgg16-fcn.caffemodel'</span></div><div class="line"><span class="comment"># init</span></div><div class="line">solver = caffe.SGDSolver(<span class="string">'solver.prototxt'</span>)</div><div class="line">solver.net.copy_from(weights)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从状态中恢复训练：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">solver = caffe.SGDSolver(<span class="string">'solver.prototxt'</span>)</div><div class="line">solver.restore(<span class="string">'snapshot/train_iter_2000.solverstate'</span>)</div></pre></td></tr></table></figure></p>
<p>这时不需要copy参数了。  </p>
<p><strong>2.编写网络配置文件</strong><br>通常创建一个创建一个 solver 来表示网络的参数信息，包括：迭代次数，训练策略以及保存快照等。其中包含了一个训练网络模型定义和一个测试网络模型定义文件，也可以写在一个配置文件中，当写在一个文件中的时候，要在网络的不同之处加上：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">include &#123;</div><div class="line">    phase: TEST (TRAIN)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.网络运行过程</strong>  </p>
<ul>
<li>加载 solver 有两种方式（Python 接口）：<br><code>solver = caffe.get_solver(&#39;models/bvlc_reference_caffenet/solver.prototxt&#39;)</code> 和<br><code>solver = caffe.SGDSolver(&#39;models/bvlc_reference_caffenet/solver.prototxt&#39;)</code>  </li>
<li>开始训练：  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">solver.net.forward()  <span class="comment"># train net</span></div><div class="line">solver.test_nets[<span class="number">0</span>].forward()  <span class="comment"># test net (there can be more than one)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这是一次从输入层到损失层的计算过程，最后计算出loss，反向传播时，可以写为：<code>solver.net.backward()</code>，这是计算从损失层到输入层的梯度，并更新网络中各层的参数信息。前向传播和反向传播可以合并写，表示一次完整的计算：<code>solver.step(1)</code>。如果要按照配置文件中的最大迭代次数运行网络，则写为：<code>solver.solve()</code>。  </p>
<p><strong>4.验证模型正确率</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">accuracy = <span class="number">0</span></div><div class="line">batch_size = solver.test_nets[<span class="number">0</span>].blobs[<span class="string">'data'</span>].num <span class="comment">#训练批次</span></div><div class="line">test_iters = int(len(Xt) / batch_size) <span class="comment">#迭代次数</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_iters):</div><div class="line">    solver.test_nets[<span class="number">0</span>].forward() <span class="comment">#测试网络</span></div><div class="line">    accuracy += solver.test_nets[<span class="number">0</span>].blobs[<span class="string">'accuracy'</span>].data <span class="comment">#相加每次迭代的正确率</span></div><div class="line">accuracy /= test_iters <span class="comment">#平均正确率</span></div><div class="line">print(<span class="string">"Accuracy: &#123;:.3f&#125;"</span>.format(accuracy))</div></pre></td></tr></table></figure></p>
<p><strong>5.定义自己的Python层</strong><br>Python层通常用来对输入数据进行预处理，如在图像语义分割中，输入为Python层，用于读取训练图像和分割图像。<br>自定义Python层是，需在prototxt文件中指明层的类型为python并且指明需要的函数，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">layer &#123;</div><div class="line">  name: <span class="string">'MyPythonLayer'</span></div><div class="line">  type: <span class="string">'Python'</span></div><div class="line">  top: <span class="string">'output'</span></div><div class="line">  bottom: <span class="string">'conv'</span></div><div class="line">  python_param &#123;</div><div class="line">    module: <span class="string">'mypythonlayer'</span></div><div class="line">    layer: <span class="string">'MyLayer'</span></div><div class="line">    param_str: <span class="string">"'num': 21"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，需要按以下格式定义自己的Python文件，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> caffe</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> yaml</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLayer</span><span class="params">(caffe.Layer)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, bottom, top)</span>:</span></div><div class="line">        self.num = yaml.load(self.param_str)[<span class="string">"num"</span>]</div><div class="line">        <span class="keyword">print</span> <span class="string">"Parameter num : "</span>, self.num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reshape</span><span class="params">(self, bottom, top)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, bottom, top)</span>:</span> <span class="comment">#前传</span></div><div class="line">        top[<span class="number">0</span>].reshape(*bottom[<span class="number">0</span>].shape)</div><div class="line">        top[<span class="number">0</span>].data[...] = bottom[<span class="number">0</span>].data + self.num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, top, propagate_down, bottom)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>使用时还与普通网络调用一样进行，只是会直接用python定义的层完成输入数据的重新组织，再进行传递。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Caffe学习中的遇到的一些问题拾遗。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
  </entry>
  
</feed>
