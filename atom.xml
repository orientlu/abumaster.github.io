<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2017-11-06T14:16:34.625Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ACE学习笔记2：内存分配</title>
    <link href="http://abumaster.com/2017/11/06/ACE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://abumaster.com/2017/11/06/ACE学习笔记2：内存分配/</id>
    <published>2017-11-06T12:00:14.000Z</published>
    <updated>2017-11-06T14:16:34.625Z</updated>
    
    <content type="html"><![CDATA[<p>一个成熟的框架或软件，都会有一个丰富的内存管理类，用于方便高效地管理内存。如STL中的内存池、Nginx中的内存池，通过预先从堆中申请空间，使用的时候可以从空闲存储中取（只是移动指针），避免频繁调用api和操作符从堆中申请释放空间，更有效率。ACE 中提供了两种不同的类用于管理内存（从堆中申请的内存或进程间共享的内存）。根据不同的开发应用选择合适的内存管理方案。  </p>
<a id="more"></a>
<h4 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h4><p>ACE 提供了两组不同的类进行内存管理：  </p>
<ul>
<li>基于 <code>ACE_Allocator</code> 类，用于局部的动态内存分配，使用动态绑定和策略模式来提供灵活性和扩展性；  </li>
<li>基于 <code>ACE_Malloc</code> 模板类，用于局部动态内存管理类和共享内存类，通过C++模板和外部多态性为内存分配提供灵活性。   </li>
</ul>
<h4 id="分配器（ACE-Allocator）"><a href="#分配器（ACE-Allocator）" class="headerlink" title="分配器（ACE_Allocator）"></a>分配器（ACE_Allocator）</h4><p>分配器用于动态内存管理，提供了若干不同策略的分配器，提供相同的功能但是具有不同的特性。不同策略的分配器及其特性的描述：  </p>
<ul>
<li><code>ACE_Allocator</code> ACE 中的分配器类的接口类。这些类使用继承和动态绑定来提供灵活性。  </li>
<li><code>ACE_Static_Allocator</code> 该分配器管理固定大小的内存。每当收到分配内存的请求时，它就移动内部指针、以返回内存块。它还假定内存一旦被分配，就再也不会被释放。  </li>
<li><code>ACE_Cached_Allocator</code> 使用内存池预先分配一定大小的内存块，连成空闲链表，内存的申请和释放只是取和放内存块。  </li>
<li><code>ACE_New_Allocator</code> 封装了C++中的 <code>new</code> 和 <code>delete</code> 运算符。  </li>
</ul>
<p><strong>使用：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Log_Msg.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Thread_Mutex.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc_T.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//分配 1k 大小的内存块，内存块简单的为char</span></div><div class="line"><span class="comment">//也可以用合适的结构和类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> MEMORY_BLOCK[<span class="number">1024</span>];</div><div class="line"><span class="keyword">typedef</span> ACE_Cached_Allocator&lt;MEMORY_BLOCK, ACE_SYNCH_MUTEX&gt; Allocator;</div><div class="line"><span class="keyword">class</span> MessageManager</div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MessageManager(<span class="keyword">int</span> n_blocks) :allocator_(n_blocks), message_count_(<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        msg_array_ = <span class="keyword">new</span> <span class="keyword">char</span> *[n_blocks];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">allocate_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></div><div class="line">    </span>&#123;</div><div class="line">        msg_array_[message_count_] = (<span class="keyword">char</span>*)allocator_.<span class="built_in">malloc</span>(ACE_OS::<span class="built_in">strlen</span>(msg) + <span class="number">1</span>);</div><div class="line">        ACE_OS::<span class="built_in">strcpy</span>(msg_array_[message_count_], msg);</div><div class="line">        ++message_count_;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free_all_msg</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; message_count_; ++i)</div><div class="line">            allocator_.<span class="built_in">free</span>(msg_array_[i]);</div><div class="line"></div><div class="line">        message_count_ = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display_all_msg</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; message_count_; ++i)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"msg: %s\n"</span>, msg_array_[i]);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> **msg_array_;</div><div class="line">    Allocator allocator_;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> message_count_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">    <span class="keyword">char</span> *message = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</div><div class="line">    <span class="function">MessageManager <span class="title">manage</span><span class="params">(n)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">sprintf</span>(message, <span class="string">"msg id %d, hello"</span>, i);</div><div class="line">        manage.allocate_msg(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    manage.display_all_msg();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ACE-Malloc"><a href="#ACE-Malloc" class="headerlink" title="ACE_Malloc"></a>ACE_Malloc</h4><p>ACE_Malloc 模板类进行内存管理，有两个模板参数，一个是内存池，另一个是锁。应用有自己的空闲内存表，当内存不够用时，则向底层内存池申请，释放时不会释放给内存池，而是连接到自己的空闲链表中，所以内存只会增大不会减小，可以调用<code>remove()</code>方法将内存还给系统。<br>使用：<br>首先选定内存池和锁机制实例化一个<code>ACE_Malloc</code>模板，生成一个分配器。用该分配器实例化一个对象，这就是应用中可以使用的分配器。可用的内存池：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Local_Memory_Pool.h"</span> <span class="comment">//使用c++的new和delete创建的局部内存池，不可进程间共享</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/MMAP_Memory_Pool.h"</span> <span class="comment">//mmap创建的内存池，可以进程间共享</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Sbrk_Memory_Pool.h"</span> <span class="comment">//sbrk调用创建的内存池</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Shared_Memory_Pool.h"</span> <span class="comment">//shmget调用创建</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Pagefile_Memory_Pool.h"</span></span></div></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Shared_Memory_MM.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ace/Malloc_T.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_SIZE 100</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE1 <span class="meta-string">"Hiya over there client process"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE2 <span class="meta-string">"Did you hear me the first time?"</span></span></div><div class="line">LPCTSTR poolname=<span class="string">"My_Pool"</span>;</div><div class="line"><span class="keyword">typedef</span> ACE_Malloc&lt;ACE_SHARED_MEMORY_POOL,ACE_Null_Mutex&gt; Malloc_Allocator;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server</span> <span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">//Create the memory allocator passing it the shared memory</span></div><div class="line">    <span class="comment">//pool that you want to use</span></div><div class="line">    <span class="function">Malloc_Allocator <span class="title">shm_allocator</span><span class="params">(poolname)</span></span>;</div><div class="line">    <span class="comment">//Create a message, allocate memory for it and bind it with</span></div><div class="line">    <span class="comment">//a name so that the client can the find it in the memory</span></div><div class="line">    <span class="comment">//pool</span></div><div class="line">    <span class="keyword">char</span>* Message1=(<span class="keyword">char</span>*)shm_allocator.<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(MESSAGE1));</div><div class="line">    ACE_OS::<span class="built_in">strcpy</span>(Message1,MESSAGE1);</div><div class="line">    shm_allocator.bind(<span class="string">"FirstMessage"</span>,Message1);</div><div class="line">    ACE_DEBUG((LM_DEBUG,<span class="string">"&lt;&lt;%s\n"</span>,Message1));</div><div class="line">    <span class="comment">//How about a second message</span></div><div class="line">    <span class="keyword">char</span>* Message2=(<span class="keyword">char</span>*)shm_allocator.<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(MESSAGE2));</div><div class="line">    ACE_OS::<span class="built_in">strcpy</span>(Message2,MESSAGE2);</div><div class="line">    shm_allocator.bind(<span class="string">"SecondMessage"</span>,Message2);</div><div class="line">    ACE_DEBUG((LM_DEBUG,<span class="string">"&lt;&lt;%s\n"</span>,Message2));</div><div class="line">    <span class="comment">//Set the Server to go to sleep for a while so that the client has</span></div><div class="line">    <span class="comment">//a chance to do its stuff</span></div><div class="line">    ACE_DEBUG((LM_DEBUG,</div><div class="line">    <span class="string">"Server done writing.. going to sleep zzz..\n\n\n"</span>));</div><div class="line">    ACE_OS::sleep(<span class="number">2</span>);</div><div class="line">    <span class="comment">//Get rid of all resources allocated by the server. In other</span></div><div class="line">    <span class="comment">//words get rid of the shared memory pool that had been</span></div><div class="line">    <span class="comment">//previously allocated</span></div><div class="line">    shm_allocator.remove();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">//Create a memory allocator. Be sure that the client passes</span></div><div class="line">    <span class="comment">// in the "right" name here so that both the client and the</span></div><div class="line">    <span class="comment">//server use the same memory pool. We wouldn’t want them to</span></div><div class="line">    <span class="comment">// BOTH create different underlying pools.</span></div><div class="line">    <span class="function">Malloc_Allocator <span class="title">shm_allocator</span><span class="params">(poolname)</span></span>;</div><div class="line">    <span class="comment">//Get that first message. Notice that the find is looking up the</span></div><div class="line">    <span class="comment">//memory based on the "name" that was bound to it by the server.</span></div><div class="line">    <span class="keyword">void</span> *Message1;</div><div class="line">    <span class="keyword">if</span>(shm_allocator.find(<span class="string">"FirstMessage"</span>,Message1)==<span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        ACE_ERROR((LM_ERROR,</div><div class="line">                <span class="string">"Client: Problem cant find data that server has sent\n"</span>));</div><div class="line">        ACE_OS::<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    ACE_OS::<span class="built_in">printf</span>(<span class="string">"&gt;&gt;%s\n"</span>,(<span class="keyword">char</span>*) Message1);</div><div class="line">    ACE_OS::fflush(<span class="built_in">stdout</span>);</div><div class="line">    <span class="comment">//Lets get that second message now.</span></div><div class="line">    <span class="keyword">void</span> *Message2;</div><div class="line">    <span class="keyword">if</span>(shm_allocator.find(<span class="string">"SecondMessage"</span>,Message2)==<span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        ACE_ERROR((LM_ERROR,</div><div class="line">                <span class="string">"Client: Problem cant find data that server has sent\n"</span>));</div><div class="line">        ACE_OS::<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    ACE_OS::<span class="built_in">printf</span>(<span class="string">"&gt;&gt;%s\n"</span>,(<span class="keyword">char</span>*)Message2);</div><div class="line">    ACE_OS::fflush(<span class="built_in">stdout</span>);</div><div class="line">    ACE_DEBUG((LM_DEBUG,<span class="string">"Client done reading! BYE NOW\n"</span>));</div><div class="line">    ACE_OS::fflush(<span class="built_in">stdout</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">switch</span> (ACE_OS::fork ())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</div><div class="line">            ACE_ERROR_RETURN ((LM_ERROR, <span class="string">"%p\n"</span>, <span class="string">"fork"</span>), <span class="number">1</span>);</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="comment">// Make sure the server starts up first.</span></div><div class="line">            ACE_OS::sleep (<span class="number">1</span>);</div><div class="line">            client ();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            server ();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Windows　平台下将上述代码中改为<code>typedef ACE_Malloc&lt;ACE_MMAP_MEMORY_POOL, ACE_Null_Mutex&gt; Malloc_Allocator;</code> ，并且，不能用fork来创建子进程，需要分两个程序来测试。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个成熟的框架或软件，都会有一个丰富的内存管理类，用于方便高效地管理内存。如STL中的内存池、Nginx中的内存池，通过预先从堆中申请空间，使用的时候可以从空闲存储中取（只是移动指针），避免频繁调用api和操作符从堆中申请释放空间，更有效率。ACE 中提供了两种不同的类用于管理内存（从堆中申请的内存或进程间共享的内存）。根据不同的开发应用选择合适的内存管理方案。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="ACE" scheme="http://abumaster.com/tags/ACE/"/>
    
  </entry>
  
  <entry>
    <title>ACE学习笔记-1</title>
    <link href="http://abumaster.com/2017/11/04/ACE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://abumaster.com/2017/11/04/ACE学习笔记-1/</id>
    <published>2017-11-04T06:48:01.000Z</published>
    <updated>2017-11-04T07:11:37.308Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ACE</strong> (Adaptive Communication Environment) 自适配通信环境，一个高效的、跨平台的、稳定的C++网络 <em>中间件</em> 提供了众多功能和特性。第一章安装。<br><a id="more"></a></p>
<ul>
<li><p><strong>平台</strong><br>Windows 10 + vs2013 + ACE6.4.0  </p>
</li>
<li><p>下载  <a href="http://download.dre.vanderbilt.edu/">地址</a>。解压得到文件夹 <code>ACE_wrappers</code>，其中包含了源文件以及工程文件；  </p>
</li>
<li><p>目录下有 <code>ACE-INSTALL.html</code> 包含了安装指导，在ace文件夹下新建一个 <code>config.h</code> 文件，其中添加头文件和宏定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ACE_HAS_STANDARD_CPP_LIBRARY 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config-win32.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ACE_NO_INLINE</span></div></pre></td></tr></table></figure>
</li>
<li><p>打开 <code>ace_vc12.sln</code> 解决方案，根据情况编译 Debug 或者 Release 版本的ace库，编译完成后在 <code>ACE_wrappers/lib</code> 下生成了 <code>lib</code> 和 <code>dll</code> 。  </p>
</li>
<li>使用，新建工程可以将头文件目录以及库目录添加到工程中。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ACE&lt;/strong&gt; (Adaptive Communication Environment) 自适配通信环境，一个高效的、跨平台的、稳定的C++网络 &lt;em&gt;中间件&lt;/em&gt; 提供了众多功能和特性。第一章安装。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>秋招之路-反思</title>
    <link href="http://abumaster.com/2017/10/25/%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF-%E5%8F%8D%E6%80%9D/"/>
    <id>http://abumaster.com/2017/10/25/秋招之路-反思/</id>
    <published>2017-10-25T01:18:24.000Z</published>
    <updated>2017-10-25T12:24:13.534Z</updated>
    
    <content type="html"><![CDATA[<p>七八月开始准备找工作，期间看了几本书，做了不少的算法题。从八月底开始投递简历，开始做笔试。然后九月开始四处跑宣讲会，做笔试，面试，累。等到十月的中旬才找到了工作，算是比较垫底的薪资水准了，我的水平难道是不过如此了吗？第一份工作就不过如此了。<br><a id="more"></a></p>
<p><blockquote class="blockquote-center">
不乱于心，不困于情，不畏将来，不念过往，如此，安好。<br>–丰子恺 《不宠无惊过一生》
</blockquote>
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-10-25/34678281.jpg" alt="">  </p>
<p><center>
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-10-25/32122326.jpg" alt="">
</center>
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-10-25/36429024.jpg" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;七八月开始准备找工作，期间看了几本书，做了不少的算法题。从八月底开始投递简历，开始做笔试。然后九月开始四处跑宣讲会，做笔试，面试，累。等到十月的中旬才找到了工作，算是比较垫底的薪资水准了，我的水平难道是不过如此了吗？第一份工作就不过如此了。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://abumaster.com/categories/life/"/>
    
    
      <category term="其他" scheme="http://abumaster.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>curl库的使用</title>
    <link href="http://abumaster.com/2017/10/20/curl%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2017/10/20/curl库的使用/</id>
    <published>2017-10-20T10:28:11.000Z</published>
    <updated>2017-10-21T12:32:50.194Z</updated>
    
    <content type="html"><![CDATA[<p><em>curl</em>是利用URL语法在命令行下工作的一种文件传输工具。支持文件的上传和下载，可以应用到多个平台，支持各种传输协议。<em>libcurl</em>是一种开发库，支持多种协议多个平台的文件传输库。<a href="https://curl.haxx.se/libcurl/">libcurl</a>。方便网络应用的开发。  </p>
<a id="more"></a>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p>从上述的<a href="https://curl.haxx.se/libcurl/">官网</a>下载源码，Linux平台<code>configure</code>和<code>make</code>就行了。说一下在 Windows 平台下的编译使用。<br>打开源码目录下的<code>winbuild</code>文件夹，按照<code>BUILD.WINDOWS.txt</code>文档中提供的编译信息，然后利用vs提供的命令行工具进行编译生成<code>.lib</code>或<code>.dll</code>文件。<br>使用，将lib文件和头文件加入到自己的工程中，然后添加预编译定义<code>CURL_STATICLIB</code>，或者在<code>curl.h</code>文件中添加一行宏定义<code>#define CURL_STATICLIB</code>。然后就可以编译使用了。  </p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>1.<code>CURLcode curl_global_init(long flags);</code><br>描述：用于全局初始化，清理之前，只能被调用一次，如果在函数<code>curl_easy_init</code>前没有显示调用，则lcurl库会自动调用，所以多线程中应在主线程中显示调用此函数来初始化。初始化参数包括：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CURL_GLOBAL_ALL                      <span class="comment">//初始化所有的可能的调用。</span></div><div class="line">CURL_GLOBAL_SSL                      <span class="comment">//初始化支持 安全套接字层。</span></div><div class="line">CURL_GLOBAL_WIN32            <span class="comment">//初始化win32套接字库。</span></div><div class="line">CURL_GLOBAL_NOTHING         <span class="comment">//没有额外的初始化。</span></div></pre></td></tr></table></figure></p>
<p>2.<code>void curl_global_cleanup(void);</code><br>与上述初始化函数类似，在结束使用的时候，调用此函数进行清理工作，这个函数仍然不是线程安全的，因此多线程环境下保证在主线程中调用一次来完成清理工作。  </p>
<p>3.<code>CURL *curl_easy_init( );</code><br>初始化一个<code>CURL</code>指针，类似文件指针那样，意味着一个会话的开始。  </p>
<p>4.<code>void curl_easy_cleanup(CURL *handle);</code><br>调用此函数来释放初始化的指针，完成清理工作。  </p>
<p>5.<code>char *curl_version( );</code><br>描述当前库的版本信息。  </p>
<p>6.<code>CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</code><br>重要的一个函数，设置选项。告知程序要有何种行为。第一个参数表示初始化获得指针，第二个参数表示选项，第三个参数可以是函数指针、对象指针或者是一个long型变量，主要依赖第二个参数。<br>选项：<br><code>CURLOPT_URL</code> 设置访问URL；<br><code>CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</code> 写数据，<br>回调函数原型为：<code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code> 函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。 <code>CURLOPT_WRITEDATA</code>  用于表明 <code>CURLOPT_WRITEFUNCTION</code> 函数中的stream指针的来源。<br>如果你没有通过 <code>CURLOPT_WRITEFUNCTION</code> 属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 <code>CURLOPT_WRITEDATA</code> 属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。<br><code>CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</code> 回调函数原型为 <code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code> libcurl一旦接收到http 头部数据后将调用该函数。<code>CURLOPT_WRITEDATA</code>  传递指针给libcurl，该指针表明 <code>CURLOPT_HEADERFUNCTION</code> 函数的stream指针的来源。<br><code>CURLOPT_READFUNCTION CURLOPT_READDATA</code> libCurl需要读取数据传递给远程主机时将调用 <code>CURLOPT_READFUNCTION</code> 指定的函数，函数原型是：<code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)</code> 。<br><code>CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</code><br>跟数据传输进度相关的参数。<code>CURLOPT_PROGRESSFUNCTION</code> 指定的函数正常情况下每秒被libcurl调用一次，为了使 <code>CURLOPT_PROGRESSFUNCTION</code>被调用，<code>CURLOPT_NOPROGRESS</code> 必须被设置为false，<code>CURLOPT_PROGRESSDATA</code> 指定的参数将作为 <code>CURLOPT_PROGRESSFUNCTION</code> 指定函数的第一个参数。<br><code>CURLOPT_FOLLOWLOCATION</code> 设置重定位URL。<br><code>CURLOPT_RANGE: CURLOPT_RESUME_FROM:</code> 断点重传相关设置。<code>CURLOPT_RANGE</code> 指定<code>char *</code>参数传递给libcurl，用于指明http域的RANGE头域，例如：表示头500个字节：bytes=0-499。<code>CURLOPT_RESUME_FROM</code> 传递一个long参数给libcurl，指定你希望开始传递的偏移量。<br>7.<code>CURLcode curl_easy_perform(CURL *handle);</code><br>让前面设置过选型的程序运行起来。参数为指针。返回值为0表示成功，非零表示错误，可以调用<code>const char *curl_easy_strerror(CURLcode errornum )</code>函数来获取错误信息。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;curl&lt;/em&gt;是利用URL语法在命令行下工作的一种文件传输工具。支持文件的上传和下载，可以应用到多个平台，支持各种传输协议。&lt;em&gt;libcurl&lt;/em&gt;是一种开发库，支持多种协议多个平台的文件传输库。&lt;a href=&quot;https://curl.haxx.se/libcurl/&quot;&gt;libcurl&lt;/a&gt;。方便网络应用的开发。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="网络" scheme="http://abumaster.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>UML基础学习</title>
    <link href="http://abumaster.com/2017/10/11/UML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://abumaster.com/2017/10/11/UML基础学习/</id>
    <published>2017-10-11T02:03:05.000Z</published>
    <updated>2017-10-16T10:39:42.593Z</updated>
    
    <content type="html"><![CDATA[<p>UML，Unified Modeling Language，统一建模语言，一种有特殊用途的语言。从用途和分类，到简单应用做一个总结。其他学习<a href="http://blog.csdn.net/column/details/u-m-l.html">网站CSDN专栏</a>。在线 UML 工具 <a href="https://www.processon.com/">ProcessOn</a>。  </p>
<a id="more"></a>
<h4 id="UML-分类"><a href="#UML-分类" class="headerlink" title="UML 分类"></a>UML 分类</h4><p>UML 可分为两类：结构型、行为型。<br>结构性的UML有：  </p>
<ul>
<li>类图，显示了系统的静态结构，用于对系统中的各种概念建模，并描绘他们之间的关系，类是相同数据结构行为和关系的一组对象；  </li>
<li>对象图，类的实例化；  </li>
<li>构件图，将可重用的代码或模块封装成可替换的物理单元，称为构件，描述构件之间的关系；  </li>
<li>部署图  </li>
<li>包图<br>行为型的图有：  </li>
<li>活动图  </li>
<li>状态机图  </li>
<li>顺序图  </li>
<li>通信图  </li>
<li>用例图  </li>
<li>时间图  </li>
</ul>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p>参考C++中的类，具有类名称、类的属性以及操作。属性和操作对其他类的可见性通过三种方式进行控制，公有私有和保护。<br>类图之间的关系：<br>类与类之间的关系通常有4种，即依赖关系（Dependency）、泛化关系（Generalization）、关联关系（Association）、实现关系（Realization）。<br><a href="http://blog.csdn.net/jiuqiyuliang/article/details/8568303">参考</a>。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UML，Unified Modeling Language，统一建模语言，一种有特殊用途的语言。从用途和分类，到简单应用做一个总结。其他学习&lt;a href=&quot;http://blog.csdn.net/column/details/u-m-l.html&quot;&gt;网站CSDN专栏&lt;/a&gt;。在线 UML 工具 &lt;a href=&quot;https://www.processon.com/&quot;&gt;ProcessOn&lt;/a&gt;。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="uml" scheme="http://abumaster.com/tags/uml/"/>
    
      <category term="软件设计" scheme="http://abumaster.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>一面攒人品-趋势科技</title>
    <link href="http://abumaster.com/2017/09/19/%E4%B8%80%E9%9D%A2%E6%94%92%E4%BA%BA%E5%93%81-%E8%B6%8B%E5%8A%BF%E7%A7%91%E6%8A%80/"/>
    <id>http://abumaster.com/2017/09/19/一面攒人品-趋势科技/</id>
    <published>2017-09-19T11:16:01.000Z</published>
    <updated>2017-09-20T09:14:32.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>趋势科技面试题目汇总，不是太难，面试官人很好，基础还是很薄弱的，好多东西都忘了。</p>
</blockquote>
<a id="more"></a>
<p><strong>1.知道迭代器吗，迭代器失效</strong><br>我回答了迭代器是一个指针，vector在插入和删除会引起迭代器的失效，记得在stl源码剖析中看到过，但是没有系统的回答出来。<br>标准回答：<br>vector在进行插入和删除操作后会使部分或者全部的迭代器失效，因为vector是顺序存储的，当容量不够时会删除原有的旧空间，然后将元素拷贝到新的空间中，导致所有的原空间上的迭代器失败。删除操作后，指向删除点的迭代器和其后的迭代器全部失效。<br>deque容器在首部尾部插入迭代器不会失效，首部和尾部删除元素会使删除元素的迭代器失效，在中间删除元素会使所有的迭代器失效。<br>list很少失效，只有删除的元素的迭代器失效。  </p>
<p><strong>2.删除容器中值为2的元素</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.begin(); it != vec.end();)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (*it == <span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            it = vec.erase(it);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            ++it;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.进程同步，共享存储在一个进程失效后，会如何回收</strong><br><a href="http://blog.chinaunix.net/uid-26833883-id-3230564.html">共享内存</a><br>共享内存的介绍：共享内存是一种高效的进程间通信，直接读写内存是一种高效的数据拷贝；内核中专门开辟一块内存区，进程直接映射到自己的私有地址空间中，直接读取不需要拷贝，所以更加高效；多个进程共享这块内存，所以需要一种同步机制。<br>流程：  </p>
<ul>
<li>创建或者打开共享存储；  </li>
<li>映射共享内存，将指定的内存映射到进程地址空间便于访问；  </li>
<li>撤销共享内存的映射；  </li>
<li>删除共享内存对象。<br>控制共享内存：  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</div><div class="line"><span class="comment">//shmid 共享内存标识</span></div><div class="line"><span class="comment">//cmd :IPC_STAT 得到共享内存的状态；IPC_SET 改变共享内存的状态；IPC_RMID 删除共享内存</span></div><div class="line"><span class="comment">//buf  是一个结构体指针。IPC_STAT的时候，取得的状态放在这个结构体中。如果要改变共享内存的状态，用这个结构体指定；</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>IPC_RMID命令实际上不从内核删除一个段，而是仅仅把这个段标记为删除，实际的删除发生最后一个进程离开这个共享段时。<br>当cmd为IPC_RMID时，第三个参数应为NULL。呵呵，大部分我们都是这样做,用这个函数删除共享内存。  </p>
<p><strong>4.程序崩溃</strong><br>一种方法，程序崩溃一般通过COREDUMP文件进行调试，在windows下面这部分需要自己在程序中添加代码，网上有源代码，添加到程序中即可。程序崩溃是点击COREDUMP文件，运行VS2010即可快速定位。  </p>
<p>另外一种方法，没有COREDUMP时，先运行程序，然后在VS2010中，把工程附加到进程，注意工程中运行涉及的所有文件必须是VS2010最新代码编译的。这种情况下，VS2010工程中不需要打断点，当程序运行出现崩溃时，自动跳转VS2010的代码中。这种情况非常适合服务器程序，尤其是崩溃发生的条件不清楚，无法再现的情况。尤其服务器运行几天后，崩溃，这种情况非常有用。  </p>
<p><strong>5.sql数据库加锁</strong><br><a href="http://blog.csdn.net/gz2008gz/article/details/5398529">数据库加锁</a><br>处理多用户并发访问的方法是加锁。锁是防止其他事务访问指定的资源控制、实现并发控制的一种主要手段。当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象。加锁对并发访问的影响体现在锁的粒度上。为了控制锁定的资源，应该首先了解系统的空间管理。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;趋势科技面试题目汇总，不是太难，面试官人很好，基础还是很薄弱的，好多东西都忘了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>硬币找零问题—动态规划</title>
    <link href="http://abumaster.com/2017/09/15/%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://abumaster.com/2017/09/15/硬币找零问题—动态规划/</id>
    <published>2017-09-15T00:32:53.000Z</published>
    <updated>2017-09-15T04:00:01.663Z</updated>
    
    <content type="html"><![CDATA[<p>硬币找零问题主要分为求最少硬币找零和最多组合数找零，一个是求用最少的硬币来达到目标，一个是达到目标的组合数。<br><a id="more"></a></p>
<h4 id="最少硬币找零问题"><a href="#最少硬币找零问题" class="headerlink" title="最少硬币找零问题"></a>最少硬币找零问题</h4><p><strong>问题描述</strong><br>给不同面值的硬币若干种（每种硬币个数无限多），用这若干种硬币组合为某种面额的钱，使用的硬币的个数最少。<br><strong>分析</strong>
贪心策略往往不是最优的。这时用到动态规划，假设硬币面值为<code>{v1,v2,v3,...,vn}</code>，纸币金额为<code>sum</code>，可以假设<code>dp[i]</code>表示面值为i的纸币所需的最少硬币个数，然后对于每个i遍历所有的硬币数目，更新最小值。如何转移？对于第i面值的纸币，遍历每个硬币，如果当前硬币的值小于，则可以分解为子问题，+1，更新最小值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">coinsUsed[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cents = <span class="number">1</span>; cents &lt;= money; cents++) &#123;  </div><div class="line">    <span class="comment">// 当用最小币值的硬币找零时，所需硬币数量最多  </span></div><div class="line">    <span class="keyword">int</span> minCoins = cents;  </div><div class="line"></div><div class="line">    <span class="comment">// 遍历每一种面值的硬币，看是否可作为找零的其中之一  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kind = <span class="number">0</span>; kind &lt; valueKinds; kind++) &#123;               </div><div class="line">        <span class="comment">// 若当前面值的硬币小于当前的cents则分解问题并查表  </span></div><div class="line">        <span class="keyword">if</span> (values[kind] &lt;= cents) &#123;  </div><div class="line">            <span class="keyword">int</span> temp = coinsUsed[cents - values[kind]] + <span class="number">1</span>;  </div><div class="line">            <span class="keyword">if</span> (temp &lt; minCoins) &#123;  </div><div class="line">                minCoins = temp;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 保存最小硬币数  </span></div><div class="line">coinsUsed[cents] = minCoins;</div></pre></td></tr></table></figure></p>
<h4 id="硬币面值组合问题"><a href="#硬币面值组合问题" class="headerlink" title="硬币面值组合问题"></a>硬币面值组合问题</h4><p><strong>问题描述</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">假设我们有8种不同面值的硬币｛1，2，5，10，20，50，100，200｝，用这些硬币组合够成一个给定的数值n。例如n=200，那么一种可能的组合方式为 200 = 3 * 1 + 1＊2 + 1＊5 + 2＊20 + 1 * 50 + 1 * 100. 问总过有多少种可能的组合方式？</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/python27/archive/2013/09/05/3303721.html">参考</a><br>定义 <code>dp[i][m]</code>表示前i种硬币构成m的组合数，对于第i个硬币可以用<code>{0,1,...,m/coins[i]}</code>个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][sum] = dp[i-1][sum - 0*Vm] + dp[i-1][sum - 1*Vm]+ dp[i-1][sum - 2*Vm] + ... + dp[i-1][sum - K*Vm]; 其中K = sum / Vm</div></pre></td></tr></table></figure></p>
<p>关键代码
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncoins; ++i)<span class="comment">//硬币种类数</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)<span class="comment">//兑换的面值</span></div><div class="line">        &#123;</div><div class="line">            dp[i][j] = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j / arr[i - <span class="number">1</span>]; ++k)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - k*arr[i - <span class="number">1</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="限制级的找零"><a href="#限制级的找零" class="headerlink" title="限制级的找零"></a>限制级的找零</h4><p>找零问题，限制硬币的个数，硬币的面值，如腾讯2018秋招的笔试题大意为：拥有硬币面值为<code>2^k</code>，数量各为两个，求拼凑出num的硬币组合数，如拼凑出6的组合数为：<code>{4,2},{4,1,1},{2,2,1,1}</code>，拥有的硬币面值为1,2,4,8,16,…各位2个。<br>与第一个问题类似，只不过限定了硬币用的个数k，以及硬币的面值，所以根据给定的兑换金额可以确定硬币的面值序列，每个面值最多用2个，然后问题就简单了，代码如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//兑换sum元的组合数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LimitCoinsComb</span><span class="params">(<span class="keyword">int</span> sum)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">//硬币的面值为：1,2,4,8,16...2^k 各位2个</span></div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">log</span>(sum) / <span class="built_in">log</span>(<span class="number">2</span>);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = <span class="built_in">pow</span>(<span class="number">2</span>, i);</div><div class="line">        coins.push_back(temp);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        dp[i].resize(sum + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化，sum==0时只有一种组合，其它初始为0中组合</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j / coins[i - <span class="number">1</span>], <span class="number">2</span>); ++k)<span class="comment">//最多用2个或者j/coins[i]个，最小值</span></div><div class="line">            &#123;</div><div class="line">                dp[i][j] += dp[i<span class="number">-1</span>][j - k*coins[i - <span class="number">1</span>]];<span class="comment">//递推公式</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n+<span class="number">1</span>][sum];<span class="comment">//返回结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬币找零问题主要分为求最少硬币找零和最多组合数找零，一个是求用最少的硬币来达到目标，一个是达到目标的组合数。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="动态规划" scheme="http://abumaster.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>常见算法模板</title>
    <link href="http://abumaster.com/2017/09/06/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <id>http://abumaster.com/2017/09/06/常见算法模板/</id>
    <published>2017-09-06T13:12:25.000Z</published>
    <updated>2017-09-15T06:43:57.848Z</updated>
    
    <content type="html"><![CDATA[<p>常见的算法模板，如并查集、字典树等。
<a id="more"></a></p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p><strong>定义</strong>：并查集是一种树型结构，又叫“不相交集合”，保持了一组不相交的动态集合，每个集合有一个代表标识着集合，通常用根节点表示。<br><strong>三种基本操作</strong><br>1.初始化 <code>Make_Set(x)</code> ，建立一个新的集合，集合中只有一个元素x，因此x代表整个集合，要求集合不相交，因此x不会出现在其他集合中。<br>2.查找代表 <code>Find_Set(x)</code> 查找可以代表x的集合的代表，返回x所在集合的根节点；<br>3.合并集合 <code>Union(x, y)</code> 合并x和y代表的集合，查找两个集合的根节点，相同则不必合并，不同则需要合并。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立一个新的集合，每一个子节点就是一个数，本身就是他的根节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Make_Set</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    father[x] = x;</div><div class="line">    R[x] = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过递归向上查找根节点，回溯时改变当前节点的父节点，直接指向根节点。</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Set</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x != father[x])</div><div class="line">        father[x] = Find_set(father[x]);</div><div class="line">    <span class="keyword">return</span> father[x];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将根节点设置为-1的非递归方法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Set2</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> y = x;</div><div class="line">    <span class="keyword">while</span>(y!= <span class="number">-1</span>)</div><div class="line">        y = father[y];</div><div class="line">    <span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//两个集合的合并算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> GrandX = Find_set(x);</div><div class="line">    <span class="keyword">int</span> GrandY = Find_set(y);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(GrandX == GrandY)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(R[GrandX] &lt; R[GrandY])</div><div class="line">        father[GrandX] = GrandY;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(R[GrandX] == R[GrandY])</div><div class="line">            R[GrandX]++;</div><div class="line">        father[GrandY] = GrandX;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h4><p><a href="http://www.cnblogs.com/tanky_woo/archive/2010/09/24/1833717.html">字典树</a>又称 <em>单词查找树</em>，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br>类似于字典，将一个字符串对应到一棵树上，第一个字母为第一层，第二个字母为第二层，依次向下走。<br>数据结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Trie   </div><div class="line">&#123;   </div><div class="line">    Trie *next[MAX];<span class="comment">//元素的个数，小写字母26个</span></div><div class="line">    <span class="keyword">int</span> v;   <span class="comment">//根据需要变化</span></div><div class="line">&#125;;   </div><div class="line"> </div><div class="line">Trie *root;</div></pre></td></tr></table></figure></p>
<p>支持的操作：<br>创建字典树，动态分配空间，对于给定的字符串中的每一个字符，查找树对应的层，如果为空，那么申请一个新的节点，下一个指针为空，如果存在值加1，指向下一层。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTrie</span><span class="params">(<span class="keyword">char</span> *str)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</div><div class="line">    Trie *p = root, *q;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> id = str[i]-<span class="string">'0'</span>;</div><div class="line">        <span class="keyword">if</span>(p-&gt;next[id] == <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            q = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</div><div class="line">            q-&gt;v = <span class="number">1</span>;    <span class="comment">//初始v==1</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAX; ++j)</div><div class="line">                q-&gt;next[j] = <span class="literal">NULL</span>;</div><div class="line">            p-&gt;next[id] = q;</div><div class="line">            p = p-&gt;next[id];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            p-&gt;next[id]-&gt;v++;</div><div class="line">            p = p-&gt;next[id];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    p-&gt;v = <span class="number">-1</span>;   <span class="comment">//若为结尾，则将v改成-1表示</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查找一段字符串是否是其中的一个前缀字符串，按层次搜索，如果从中间的某一层没有查到，那么查找失败返回0，成功放回-1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTrie</span><span class="params">(<span class="keyword">char</span> *str)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</div><div class="line">    Trie *p = root;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> id = str[i]-<span class="string">'a'</span>;</div><div class="line">        p = p-&gt;next[id];</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)   <span class="comment">//若为空集，表示不存以此为前缀的串</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(p-&gt;v == <span class="number">-1</span>)   <span class="comment">//字符集中已有串是此串的前缀</span></div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//此串是字符集中某串的前缀</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的算法模板，如并查集、字典树等。
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>知识点</title>
    <link href="http://abumaster.com/2017/09/04/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://abumaster.com/2017/09/04/知识点/</id>
    <published>2017-09-04T05:54:29.000Z</published>
    <updated>2017-10-10T13:35:43.811Z</updated>
    
    <content type="html"><![CDATA[<p>总结前辈们面试知识点，备忘。<br><a id="more"></a></p>
<h4 id="C-语言特性"><a href="#C-语言特性" class="headerlink" title="C++语言特性"></a>C++语言特性</h4><h5 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h5><p>可以参考<a href="http://www.cnblogs.com/Azhu/p/4436531.html">博文</a>。<br>内存划分：<br>在C++中，内存分成5个区，他们分别是 <strong>堆</strong>、<strong>栈</strong>、<strong>自由存储区</strong>、<strong>全局/静态存储区</strong>和 <strong>常量存储区</strong>。<br><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br><strong>堆</strong>：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br><strong>自由存储区</strong>：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。<br><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。<br><strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。<br>分配和释放：<br>C++中使用<code>new</code>和<code>delete</code>运算符用于申请和释放内存块，要配对使用。对于对象来说，可以调用默认构造函数。栈是由编译器自动管理，堆由程序员控制；栈的空间小速度快，堆的空间大，速度相对慢；生长方向，堆是向地址增大的方向，栈是向地址减小的方向。  </p>
<p><strong>注意问题</strong><br>1.指向常量字符串的指针，不能修改，如果尝试修改，编译期间没毛病，会出现运行错误。如
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p=<span class="string">"hello"</span>;</div><div class="line">p[<span class="number">0</span>]=<span class="string">'H'</span>;<span class="comment">//编译器发现不了这个错误，p[0]='H';没毛病</span></div></pre></td></tr></table></figure></p>
<p>2.指针和数组，数组名不是指针，只是在一定的情况下退化为指针（数组名作为参数传递）。同样数组名也不可以直接赋值给一个指针，或者比较，要用标准函数<code>strcpy strcmp</code>。  </p>
<h5 id="C-多态或虚函数实现机制"><a href="#C-多态或虚函数实现机制" class="headerlink" title="C++多态或虚函数实现机制"></a>C++多态或虚函数实现机制</h5><p>C++多态是通过虚函数实现的。<a href="http://www.cnblogs.com/malecrab/p/5572730.html">C++虚函数的实现的基本原理</a>。<br><strong>虚函数</strong>的实现：虚函数表和虚表指针。<br>虚函数表，就是在一个类的内存分布上起始地址是一个虚表指针，指向虚函数的表。虚函数表是在构造函数时产生，所以构造函数不能为虚函数。例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funa</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funb</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**内存分布          虚表</div><div class="line">|   *pvtable |--&gt;| funa | funb |</div><div class="line">|      a     |</div><div class="line">***/</span></div></pre></td></tr></table></figure></p>
<p>如果实例一个Base类对象，<code>Base b</code>，然后，虚表指针为 <code>(int *)(&amp;b)</code> 将地址转换成4字节的地址就位虚指针，第一个虚函数的地址为<code>(int *)*(int *)(&amp;b)</code>。<br>当继承时，子类也继承了父类的虚表并在其中重写虚函数或增加虚函数。动态绑定 <code>Base *pb= new Derive();</code> ，然后调用虚函数，偏移地址是一定的，如果子类重写了虚函数，那么会调用子类的虚函数，完成动态绑定，实现了多态。<br><em>引用和指针都可以实现动态绑定，是实现多态的两种方式。</em><br>多继承的时候，会产生多个虚表，分别对应于各个父类。  </p>
<h5 id="虚构造函数和虚析构函数"><a href="#虚构造函数和虚析构函数" class="headerlink" title="虚构造函数和虚析构函数"></a>虚构造函数和虚析构函数</h5><p>构造函数和析构函数不能被继承。<br>构造函数不能声明为虚函数，构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数。构造函数后才会产生虚表。<br><strong>虚析构函数</strong>是为了使子类调用自己的析构函数来释放内存空间，而不是单纯调用父类的构造函数，造成内存泄漏。<br>如<code>Base *pb=new Derive(); delete pb;</code>，如果基类的析构函数不是虚函数的话，delete操作只调用了父类的析构函数，子类的构造函数没有调用，造成了内存泄漏。<br><em>析构函数的执行不应该抛出异常，如果有异常，最好不要抛出函数之外。</em><br>静态成员函数不能是虚函数，<em>虚函数</em>是一种特殊的成员函数，为了实现运行时多态，<em>静态函数</em>和类不相关，是一种限定了命名空间的特殊函数，所以。  </p>
<h5 id="构造函数和析构函数抛出异常"><a href="#构造函数和析构函数抛出异常" class="headerlink" title="构造函数和析构函数抛出异常"></a>构造函数和析构函数抛出异常</h5><p><em>构造函数抛出异常</em><br>不建议构造函数抛出异常；<br>构造函数抛出异常时，析构函数将不会被执行。<br><em>析构函数抛出异常</em><br>析构函数不应该抛出异常；<br>可能发生异常时，将异常封装到析构函数之内；<br>当处理另一个异常过程中，不要从析构函数抛出异常。  </p>
<h5 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h5><p>方法的重写（Overriding）和重载（overloading）是多态性的不同表现。<br>重写是父类和子类之间多态性的一种表现，重载是一个类中多态的表现。<br>如果父类定义了一个虚函数，子类定义了同名的函数，且函数参数以及返回值都相同，那么称为重写，父类中的定义被覆盖了；如果在一个类中定义了多个同名的方法，它们的区别在于参数的个数和类型，并且返回值也可以不同，那么这就是重载了。  </p>
<h5 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h5><p><code>auto_ptr</code> 废弃了。<code>shared_ptr</code> 类允许多个指针指向同一个对象，有一个引用计数；<code>unique_ptr</code> 则独占所指向的对象；<code>weak_ptr</code> 弱引用指向<code>shared_ptr</code> 指向的对象。  </p>
<h5 id="C-模板的作用"><a href="#C-模板的作用" class="headerlink" title="C++模板的作用"></a>C++模板的作用</h5><p><strong>优点：</strong>  </p>
<ul>
<li>编译时检查数据类型，而不是运行时检查，保证了类型安全；  </li>
<li>与平台无关，移植性好；  </li>
<li>与类型无关，代码复用性好；  </li>
<li>动态增长和减少的数据结构。<br><strong>缺点：</strong>  </li>
<li>易读性比较差，调试比较困难；  </li>
<li>模板的数据类型在编译期才能确定；  </li>
<li>模板的实现在整个头文件中，工程比较大的时候编译时间会比较长。  </li>
</ul>
<h5 id="动态链接库和静态链接库"><a href="#动态链接库和静态链接库" class="headerlink" title="动态链接库和静态链接库"></a>动态链接库和静态链接库</h5><p><strong>优缺点：</strong><br>动态链接库节省内存和减少页面的交换，dll与可执行文件相互独立，只有遵循接口定义则更换dll不会影响程序的运行；不同编程语言都可以调用，程序的契合度小模块化。缺点：动态加载时，如果不存在，程序终止出错，运行时加载，不存在，调用不存在的函数，出错。<br>静态链接库代码执行速度快，运行速度也略快，链接到到程序中，发行版本不再需要。但是程序的可执行文件大，代码重复多，可重用性低。<br><strong>使用方法：</strong><br>静态链接库的使用：使用静态链接库，需要包含<code>.h</code>文件和<code>#pragma comment(lib,&quot;**.lib&quot;)</code>编译开关，就可以直接用链接库中的文件了。<br>动态链接库的使用：一种静态连接，启动前加入<code>#pragmaa comment(lib,&quot;**.lib&quot;)</code>编译开关，声明链接库中的函数，可以直接用；动态加载，用时加载<code>LoadLibrary(&quot;.dll&quot;)</code>，然后声明导出函数指针并获得函数的指针，用完释放。  </p>
<h5 id="内联函数的优缺点"><a href="#内联函数的优缺点" class="headerlink" title="内联函数的优缺点"></a>内联函数的优缺点</h5><p>优点：  </p>
<ul>
<li>减少函数的进栈、出栈、跳转的开销；  </li>
<li>像宏一样展开，在调用处展开，省去了调用开销，提高了函数执行效率；  </li>
<li>编译器在调用内联函数时会检查参数，消除错误和局限性引用。<br>缺点：  </li>
<li>如果函数代码太长，使用内联会造成耗费内存过多；  </li>
<li>如果内联函数中有循环，开销比普通的函数调用还打；  </li>
<li>调用处复制代码，使得代码的量增大，耗费更多的内存。  </li>
</ul>
<h4 id="STL相关和数据结构"><a href="#STL相关和数据结构" class="headerlink" title="STL相关和数据结构"></a>STL相关和数据结构</h4><h5 id="红黑树的特性及其应用"><a href="#红黑树的特性及其应用" class="headerlink" title="红黑树的特性及其应用"></a>红黑树的特性及其应用</h5><p>满足下列条件的二叉搜索树是红黑树<br>性质1. 节点是红色或黑色<br>性质2. 根是黑色<br>性质3. 所有叶子都是黑色（叶子是Null节点）<br>性质4. 如果一个节点是红的，则它的两个儿子都是黑的<br>性质5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。<br><a href="http://abumaster.com/2017/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91/">调整详细</a>。<br>STL中<code>set、multiset、map、multimap</code>底层是红黑树实现的，而<code>unordered_map</code>、<code>unordered_set</code> 底层是哈希表实现的。  </p>
<h5 id="手写实现智能指针"><a href="#手写实现智能指针" class="headerlink" title="手写实现智能指针"></a>手写实现智能指针</h5><p>智能指针不用显示调用delete来清理内存。
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">class auto_ptr &#123;</div><div class="line">public:</div><div class="line">    explicit auto_ptr(T *p=0):pointer(p)&#123;&#125;</div><div class="line">    ~auto_ptr()&#123;delete pointer;&#125;//析构函数自动调用用来清理内存</div><div class="line">    T&amp; operator*() const &#123;return *pointer;&#125;//解指针</div><div class="line">    T* operator-&gt;() const &#123;return pointer;&#125;</div><div class="line">private:</div><div class="line">    T* pointer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="Bloom过滤器"><a href="#Bloom过滤器" class="headerlink" title="Bloom过滤器"></a>Bloom过滤器</h5><p><a href="https://segmentfault.com/a/1190000002729689">Bloom布隆过滤器</a>是一种空间效率很高的数据结构。<br>相当于一个哈希表，将一个大的数据集通过hash函数映射到小的集合上，比hash表更节省空间，但是也带来了一定的错误率。通常用于实现数据字典，快速查询，数据的去重，集合求交集等。<br>如何实现？m位数的数组，全置为0，和k个hash函数，当有一个数字，经过每一个hash函数，映射到对应位数的数组中，置为1。查询时，如果通过hash函数计算的每一位都为1，则认为这个数字使存在的，否则不存在。问题：一个数不存在，可能会被认为存在。<br>可以快速识别一个元素是否为一个集合中的元素，如将url映射为1bit，用来识别恶意链接，检测辣鸡邮箱。<br><div class="note info"><p>A,B 两个文件，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4G，让你找出 A,B 文件共同的 URL。如果是三个乃至 n 个文件呢？<br>分析 ：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿 bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。  </p>
</div>  </p>
<h5 id="B树家族"><a href="#B树家族" class="headerlink" title="B树家族"></a>B树家族</h5><p><a href="http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html">参考</a>。<br><strong>B树</strong> 二叉搜索树，非叶子节点至多拥有两个儿子，所有节点存放着一个关键字，左子树比父节点小，右子树比父节点元素大。搜索类似二分查找，若树不平衡则退化为顺序查找。所以有时加一个平衡条件，称为平衡二叉树。<br><strong>B-树</strong>  多路搜索树，通常用于数据库索引的底层实现。<br><strong>B+树</strong><br><strong>B*树</strong>   </p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h5 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h5><p><a href="http://www.tuicool.com/articles/IvyQry">卡特兰数</a>，<a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin">百度百科</a><br>用来解决常见的问题，一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?<br>将问题转化为：入栈的数的个数总是要大于或者等于出栈数的个数。 <code>C(2n，n)-C(2n，n-1)</code><br>在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？<br>将问题转化为：还书的人总是要大于或等于借书的人，即<code>C(6，3)-C(6，2)</code>  </p>
<h5 id="贪心算法及其弊端"><a href="#贪心算法及其弊端" class="headerlink" title="贪心算法及其弊端"></a>贪心算法及其弊端</h5><p>在对问题求解时总是做出在当前看来是最好的选择，不是从整体上考虑而是从局部达到最优解。<br>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。  </p>
<h5 id="01背包问题的详细解释"><a href="#01背包问题的详细解释" class="headerlink" title="01背包问题的详细解释"></a>01背包问题的详细解释</h5><p><a href="http://blog.csdn.net/ling_du/article/details/41594767">参看背包九讲</a>  </p>
<h4 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h4><h5 id="Linux下的程序编译命令"><a href="#Linux下的程序编译命令" class="headerlink" title="Linux下的程序编译命令"></a>Linux下的程序编译命令</h5><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-25/70062040.jpg" alt=""><br><strong>gcc的编译过程</strong>分为四个部分：预处理、编译、汇编、链接。  </p>
<ul>
<li>预处理，命令<code>gcc -E -o test.i test.c</code>，生成了预处理后的文件；  </li>
<li>编译，命令 <code>gcc -S test.i -o test.s</code> ，生成了汇编程序；  </li>
<li>汇编，命令 <code>gcc -c test.s -o test.o</code> ，生成了目标文件；  </li>
<li>链接，将目标文件和所需的外部文件（动态链接库和静态链接库）一块链接成可执行文件。    </li>
</ul>
<h5 id="Linux下的IO模型"><a href="#Linux下的IO模型" class="headerlink" title="Linux下的IO模型"></a>Linux下的IO模型</h5><p><a href="http://www.cnblogs.com/chy2055/p/5220793.html">IO模型</a>。<br>　IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：<br>（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。<br>（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。<br>（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。<br>（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。<br>（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。<br>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。  </p>
<h5 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h5><p>进程间通信主要分为以下几种：匿名管道、命名管道、共享内存、消息队列、信号量、套接字。  </p>
<ul>
<li>匿名管道：是一种半双工的，有读写端，用于有亲缘关系的进程之间通信（父子、兄弟），相当于一个文件可以直接调用<code>write</code>和<code>read</code>进行读写，只存在于内存中；  </li>
<li>命名管道：FIFO，无亲缘关系的进程之间可以相互通信；  </li>
<li>消息队列：存放在内核中的一个消息链，一个消息队列由一个标识符来标识，独立于发送和接收进程，可以实现消息的随机读取或者按消息的类型进行读取；  </li>
<li>信号量用于进程之间的同步，而不是用于存储进程之间的通信数据，基于操作系统的PV操作；  </li>
<li>共享内存：多个进程共享一块内存区，速度最快的IPC，多个进程共享一块，因此需要借助信号量来同步；  </li>
<li>套接字：不同机器进程可以进行通信。  </li>
</ul>
<h5 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h5><p><strong>线程池</strong>就是一堆事先创建好的线程，数量固定，一开始这一堆线程都处于空闲状态，当有一个任务到来的时候，线程池管理函数会为任务分一个空闲的线程来执行这个任务，当这个任务完成后，会把线程从新放入到线程池中。充分利用了线程的可重用性，并且避免了频繁的线程的创建和销毁开销。<br>线程池的构成：  </p>
<ul>
<li>线程池管理器：用于创建和管理线程池；  </li>
<li>工作线程：线程池中实际执行任务的线程，固定数目，一开始空闲状态；  </li>
<li>任务接口：每个任务必须实现的接口，当线程池的任务队列中有可执行任务时，被空闲的工作线程调去执行（线程的闲与忙是通过互斥量实现的，跟前面文章中的设置标志位差不多），把任务抽象出来形成接口，可以做到线程池与具体的任务无关。  </li>
<li>任务队列：用来存放没有处理的任务，提供一种缓冲机制，实现这种结构有好几种方法，常用的是队列，主要运用先进先出原理，另外一种是链表之类的数据结构，可以动态的为它分配内存空间，应用中比较灵活。<br>具体代码。  </li>
</ul>
<h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>线程同步的几种方式：互斥锁、条件变量、信号量：  </p>
<ul>
<li>互斥锁mutex，在c++11标准中提供了mutex头文件，其中定义为<code>mutex mtx;</code>加锁和释放锁的操作为<code>mtx.lock(); mtx.unlock()</code>。另外还提供了一个尝试获取锁，但是不阻塞的操作<code>mtx.try_lock();</code>。  </li>
<li>条件变量，用来等待而不是加锁。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。  </li>
<li>临界区对象，多个线程访问独享一块临界区资源，用完后释放，如互斥锁一样的存在。  </li>
<li>事件机制，允许一个线程完成任务后去通知另一个线程，如网络应用中，一个线程负责监听端口，另一个线程负责更新数据，这个时候则可以使监听完成后直接通知另一个线程更新数据。  </li>
</ul>
<h5 id="epoll-和-select"><a href="#epoll-和-select" class="headerlink" title="epoll 和 select"></a>epoll 和 select</h5><p>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024<br>epoll避免了这些缺点，进行一次拷贝，不需要重复拷贝，另外没有描述符数量的限制，另外将已经就绪的描述符加入到描述符链表中。  </p>
<h5 id="awk和sed命令"><a href="#awk和sed命令" class="headerlink" title="awk和sed命令"></a>awk和sed命令</h5><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。  </p>
<h4 id="网络和数据库"><a href="#网络和数据库" class="headerlink" title="网络和数据库"></a>网络和数据库</h4><p><a href="https://zhuanlan.zhihu.com/p/24001696">网络常考知识点</a>  </p>
<h5 id="TCP连接和断开的握手"><a href="#TCP连接和断开的握手" class="headerlink" title="TCP连接和断开的握手"></a>TCP连接和断开的握手</h5><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-17/13917292.jpg" alt=""><br>状态描述：<br>CLOSED：没有任何连接请求终止或开始状态；<br>LISTEN：被动打开，侦听来自远端的TCP连接请求；<br>SYN_SEND：在发送连接请求后等待匹配的连接请求；<br>SYN_RCVD：在收到和发送一个连接请求后等待确认；<br>ESTABLISH：代表一个连接已经建立进入数据传送状态；<br>FIN_WAIT_1：主动关闭连接后，等待对方连接中断；<br>FIN_WAIT_2：从远程TCP等待连接中断请求；<br>CLOSE_WAIT：等待从本地用户发起的连接中断请求；<br>CLOSING：等待远程TCP对连接中断请求；<br>LAST_ACK：等待原来发向远程TCP的连接中断请求的确认；
TIME_WAIT：等待足够的时间确保远程TCP接收到连接中断请求的确认。<br><strong>TCP连接的三次握手：</strong><br>连接前服务器已经做好接收外界连接的准备，<code>socket,bind,listen</code>函数等待。<br>客户端主动打开，导致tcp发送一个syn分节，告诉服务器在将建立连接中发送数据的初始序列号；服务器必须确认客户的syn，并且发送一个自己的syn；客户必须再一次确认服务器的syn。<br>为什么要三次握手，<em>为了防止一个失效的报文段再一次传送到了服务器，服务器以为一个新的连接请求，那么发送确认，两次握手的话，服务器会直接进入阻塞等待客户端数据，但是客户并没有发送连接请求，当然不会发送数据，这样就造成了服务器一直等待，资源的浪费。所以三次握手，保证连接是客户端想要创建的</em>。<br><strong>TCP断开的四次握手</strong><br>某个应用进程先调用closed主动关闭连接，发送一个FIN表示没有数据想要发送了；接收到fin的那一端，执行被动关闭，表明再无额外的数据可以接收，发送一个ack给对方，说我知道了；等一段时间，接收到fin的这一端关闭自己的套接字，导致tcp又向对方发送一个fin；接收到fin的原发送端的tcp确认这个fin。tcp连接终止完成。  </p>
<h5 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h5><p>主要区别如下：  </p>
<ul>
<li>TCP面向连接的字节流可靠的传输；UDP是面向无连接的报文不可靠的传输；  </li>
<li>TCP的传输速度慢，UDP的传输速度快；  </li>
</ul>
<h5 id="常用的端口号"><a href="#常用的端口号" class="headerlink" title="常用的端口号"></a>常用的端口号</h5><p>图片来源知乎<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-23/16087893.jpg" alt="">  </p>
<h5 id="浏览器输入网址后发生的情况"><a href="#浏览器输入网址后发生的情况" class="headerlink" title="浏览器输入网址后发生的情况"></a>浏览器输入网址后发生的情况</h5><ul>
<li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器</li>
<li>浏览器向IP对应的web服务器发送一个HTTP请求</li>
<li>服务器响应请求，发回网页内容</li>
<li>浏览器解析网页内容</li>
</ul>
<h5 id="服务器并发是如何实现的？"><a href="#服务器并发是如何实现的？" class="headerlink" title="服务器并发是如何实现的？"></a>服务器并发是如何实现的？</h5><p>服务器是可以同时执行多个进程的，并发服务器在同一时刻可以处理多个客户的连接，实现主要分三种方式：多进程并发服务器，多线程并发服务器，I/O复用并发服务器。</p>
<h5 id="MySQL数据库复制关系"><a href="#MySQL数据库复制关系" class="headerlink" title="MySQL数据库复制关系"></a>MySQL数据库复制关系</h5><p>master将改变记录到二进制日志文件中；slave将master的二进制日志拷贝到它的中继日志中；slave重做中继日志中的事件，将改变反映它自己的数据。<br>MySQL Binlog 有三种格式，分别是Statement(语句)、Row(行)、Mixd(混合)。<br>Statement记录了用户执行的原始SQL，而Row则是记录了行的修改情况，在MySQL 5.6以上的版本默认是Mixd格式，但为了保证复制数据的完整性，建议生产环境都使用Row格式，就前面所说的Row记录的是行数据的修改情况，而不是原始SQL。<br><a href="http://blog.csdn.net/nanamasuda/article/details/52089499">详细</a>  </p>
<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><p>提高数据库表的数据访问速度。特点：<br>避免对数据库进行全表扫描，只需扫描少量的索引页就能得出数据；<br>聚集索引可以避免数据插入操作，集中于表的最后一个数据页面；<br>在某些情况下，索引可以避免排序操作。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结前辈们面试知识点，备忘。&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="知识点" scheme="http://abumaster.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>最后一年</title>
    <link href="http://abumaster.com/2017/09/01/%E6%9C%80%E5%90%8E%E4%B8%80%E5%B9%B4/"/>
    <id>http://abumaster.com/2017/09/01/最后一年/</id>
    <published>2017-09-01T11:45:13.000Z</published>
    <updated>2017-09-01T12:51:28.528Z</updated>
    
    <content type="html"><![CDATA[<div class="note sucess"><p>春未老， 风细柳斜斜。 试上超然台上望， 半壕春水一城花。 烟雨暗千家。<br>寒食后， 酒醒却咨嗟。 休对故人思故国， 且将新火试新茶。 诗酒趁年华。  </p>
</div>  
<a id="more"></a>
<blockquote class="blockquote-center"><p><strong>愿你出走半生，归来仍是少年</strong></p>
</blockquote>  
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-9-1/12545054.jpg" alt=""><br>时间在指尖匆匆流逝，人也变得愈加手足无措，烦躁不安了。焦虑着毕业，焦虑着工作，焦虑着未来的何去何从…再无当年的淡定自若，宠辱不惊了。<br><strong>懒惰</strong>是何时成为了我的习惯，我是何时变得如此懒惰，无论是身体上还是心理上，似乎早已经适应了懒惰，懒得动，懒得想，懒得只想宅在凳子上。这也带来了身体上的变化，体重增加，眼睛近视加深，动不动生病。以前的早睡早起，现在的经常熬夜睡懒觉，这个变化仿佛是不知不觉地形成的。而我也尝到了坏习惯的苦果。我是真的很忙？忙的没有时间锻炼？忙的没有时间睡觉？这一切不过是借口罢了。睡得晚是因为在玩游戏、在看电视，牺牲的大把时间不过是放在娱乐上面罢了，而这种娱乐能让我休息？能活跃我的思维？当然只是来腐蚀着我的思考能力。看所谓的新闻等等，完全是看着新鲜，真的从中收获了多少，思考了多少，不过是看看别人的评论，人云亦云而已；玩游戏，用太多时间，也不过是过眼云烟，就算玩的再好又能如何。<br>所谓的忙，不过是自己找的借口罢了，学海无涯，确实如此，但是学习的过程中离不了 <strong>思考总结</strong>，耗费太多的时间只去学，不去思考是完全没有用的。在过去的一两年时间里，我暴露了太多的缺点。多了几本书，却没能完全消化掉这些知识，其根本原因是很少总结，很少思考，不问为什么，只顾着不断学进去，然后忘掉。这就是为什么花费了大把的时间，却没有成效的原因吧。<br>从小学开始记的日记，到现在也渐渐落下了。记得高三的时候，是那么的忙，每天还要抽出放学后的几分钟记一下今天的心路历程，学习感悟。不曾想，现在有太多的时间可以用，却不写了。那是记日记成了一种繁忙，压力生活的一种放松时间，现在反而成了一种负担，自己想着就是搞笑。可能敲键盘多了，你会忘记自己写字的技能吧。可恨！可恶至极！<br><strong>我已不在是少年</strong>，我已无梦想，甘愿做一平凡人。但愿<code>一席一茶观明月，一花一湖澈是非。今生的一切努力是要朝着花开的方向。</code>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note sucess&quot;&gt;&lt;p&gt;春未老， 风细柳斜斜。 试上超然台上望， 半壕春水一城花。 烟雨暗千家。&lt;br&gt;寒食后， 酒醒却咨嗟。 休对故人思故国， 且将新火试新茶。 诗酒趁年华。  &lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://abumaster.com/categories/life/"/>
    
    
      <category term="随笔" scheme="http://abumaster.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2018秋招-360</title>
    <link href="http://abumaster.com/2017/08/27/2018%E7%A7%8B%E6%8B%9B-360/"/>
    <id>http://abumaster.com/2017/08/27/2018秋招-360/</id>
    <published>2017-08-27T09:09:54.000Z</published>
    <updated>2017-08-28T09:15:22.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>360 2018秋招笔试编程题目解析。</p>
</blockquote>
<a id="more"></a>
<h4 id="卖粉笔问题"><a href="#卖粉笔问题" class="headerlink" title="卖粉笔问题"></a>卖粉笔问题</h4><p>有彩色粉笔<code>n</code>个，白色粉笔<code>m</code>个，<code>a</code>个彩色粉笔和<code>b</code>个白色粉笔打包可以卖<code>x</code>元，<code>c</code>个白色粉笔可以卖<code>y</code>元，<code>d</code>个彩色粉笔可以卖<code>z</code>元，问可以获得的最大收益。  </p>
<p><strong>解题思路1：</strong><br>首先想到的是动态规划问题，对于有<code>i</code>个彩色粉笔和<code>j</code>个白色粉笔，<code>dp[i][j]</code>表示可以卖到的最大值，那么这个最大值是如何求出的呢？<br>状态转移有以下几种情况：  </p>
<ul>
<li>只卖白色，<code>dp[i][j] = dp[i][j-c] + y</code>；  </li>
<li>只卖彩色，<code>dp[i][j] = dp[i-d][j] + z</code>；  </li>
<li>组合卖，<code>dp[i][j] = dp[i-a][j-b] + x</code>。<br>取三种情况的最大值，最后<code>dp[n][m]</code>就是所求的结果。<br>分析，双层循环，复杂度的<code>O(N*M)</code>。  </li>
</ul>
<p><strong>解题思路2：</strong><br>相对于动态规划要简单许多，要获得最大利润，最终的粉笔肯定有一个组合，假设为<code>x</code>对组合卖掉，那么白色粉笔还剩余<code>m-b*x</code>个，白色粉笔可以最多卖的钱数为<code>(m-b*x)/c * y</code>，同理可以得到彩色的所卖钱数。对于最终组合，其他的组合都不是最优的结果，所以，可以用组合卖的粉笔组数来进行最优解选择。<br>代码如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//最大收益</span></div><div class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//组合卖的盒数</span></div><div class="line"><span class="keyword">while</span> (index*a &lt;= n &amp;&amp; index*b &lt;= m)<span class="comment">//可以组合来卖</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp = index*x;<span class="comment">//组合卖的收益</span></div><div class="line">    temp += ((m - index*b) / c)*y;<span class="comment">//白色粉笔单独卖的收益</span></div><div class="line">    temp += ((n - index*a) / d)*z;<span class="comment">//彩色粉笔单独卖的收益</span></div><div class="line">    ans = (ans &gt; temp) ? ans : temp;<span class="comment">//更新收益最大值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>复杂度仅为<code>O(n)</code>性能得到了很大的提升。启示：想到最终状态，然后再步步推。  </p>
<h4 id="统计数组中前面比自己小的数字个数"><a href="#统计数组中前面比自己小的数字个数" class="headerlink" title="统计数组中前面比自己小的数字个数"></a>统计数组中前面比自己小的数字个数</h4><p>类似于这样的题：给定一个整数数组（下标由 <code>0</code> 到 <code>n-1</code>， <code>n</code> 表示数组的规模，取值范围由 0 到10000）。对于数组中的每个 <code>ai</code> 元素，请计算 <code>ai</code> 前的数中比它小的元素的数量。    </p>
<p><strong>思路1：</strong><br>暴力求解，复杂度太高，无法完全通过。  </p>
<p><strong>思路2：</strong><br><div class="note info"><p>分析：求ai前的数中比他小的元素数量，即，在<code>ai</code>之前的元素中区间<code>[0, ai-1]</code>的元素数量<br>构建线段树，节点中包含元素出现的次数，所有<code>count&gt;0</code> 的叶子结点表示元素存在；依次更新结点计数，所以后面的元素不影响前面的元素计数。</p>
</div><br><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5%E6%A0%91/10983506?fr=aladdin">线段树</a>是一种数据结构，是一种二叉搜索树，每个叶节点表示一个单元区间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> XianDuanTree</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> Node<span class="comment">//线段树的节点</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">int</span> start, end, count;</div><div class="line">        Node *left, *right;</div><div class="line">        Node(<span class="keyword">int</span> start, <span class="keyword">int</span> end) :start(start), end(end), count(<span class="number">0</span>), right(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//创建线段树，返回根节点</span></div><div class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="comment">//递归创建，返回条件</span></div><div class="line">        <span class="keyword">if</span> (start &gt; end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</div><div class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">            root-&gt;left = build(start, mid);</div><div class="line">            root-&gt;right = build(mid + <span class="number">1</span>, end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在线段树中查找区间</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (start &gt; end || root-&gt;start &gt; end || root-&gt;end &lt; start) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end) <span class="keyword">return</span> root-&gt;count;<span class="comment">//查找的区间包含root所指区间</span></div><div class="line">        <span class="keyword">int</span> mid = (root-&gt;start + root-&gt;end) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> leftCount = query(root-&gt;left, start, min(mid, end));</div><div class="line">        <span class="keyword">int</span> rightCount = query(root-&gt;right, max(mid, start), end);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> leftCount + rightCount;<span class="comment">//返回左右子树的查找数量</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//像线段树中插入value</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inset</span><span class="params">(Node *root, <span class="keyword">int</span> value)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (root-&gt;left == root-&gt;right &amp;&amp; root-&gt;start == value)</div><div class="line">        &#123;</div><div class="line">            root-&gt;count += <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//递归查找合适的插入位置</span></div><div class="line">        <span class="keyword">int</span> mid = (root-&gt;start + root-&gt;end) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (value &lt;= mid)</div><div class="line">        &#123;</div><div class="line">            inset(root-&gt;left, value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            inset(root-&gt;right, value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//回溯自下而上更新count//右子树不一定存在所以进行判断</span></div><div class="line">        root-&gt;count = root-&gt;left-&gt;count + (root-&gt;right ? root-&gt;right-&gt;count : <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSamllerNum()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">        Node *root = build(<span class="number">0</span>, <span class="number">10005</span>);</div><div class="line">        <span class="keyword">int</span> n,temp;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</div><div class="line">            <span class="keyword">int</span> cnt = query(root, temp+<span class="number">1</span>, <span class="number">10005</span>);<span class="comment">//前面比他大的数，区间为[temp+1,maxn]，的数的数量</span></div><div class="line">            vec.push_back(cnt);</div><div class="line">            inset(root, temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> vec;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="简单数列"><a href="#简单数列" class="headerlink" title="简单数列"></a>简单数列</h4><p>题目描述见图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-28/45707399.jpg" alt=""><br><a href="http://www.cnblogs.com/qscqesze/p/5217014.html">类似的题目地址</a><br>思路：<br>交换0次和交换一次，显然可以直接暴力出来<br>现在考虑交换两次的情况，交换两次之后，答案为<code>s-2*a[i]-2*a[j]+2*b[i]+2*b[j]</code>（s为原来未交换的时候，两个数组的差值。我们把所有的<code>(a[i],a[j])</code>都存起来，为了使两数组之差最小，显然<code>2*(b[i]+b[j])</code>应该找到大于等于<code>(2*(a[i]+a[j])-s)</code>的第一个数然后这个东西直接二分就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2050</span>;</div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"><span class="keyword">int</span> b[maxn];</div><div class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span> ,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;two[maxn*maxn+<span class="number">5</span>];</div><div class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),s+=a[i];</div><div class="line">    <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]),s-=b[i];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s2 = <span class="number">1e18</span>;</div><div class="line">    <span class="comment">//交换一次后的结果</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="built_in">abs</span>(s + <span class="number">2</span>*b[j] - <span class="number">2</span>*a[i]);</div><div class="line">            <span class="keyword">if</span>(cur&lt;s2)</div><div class="line">            &#123;</div><div class="line">                s2 = cur;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">            two[++tot]=make_pair(<span class="number">2l</span>l*b[i]+<span class="number">2l</span>l*b[j],make_pair(i,j));</div><div class="line">    sort(two+<span class="number">1</span>,two+<span class="number">1</span>+tot);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s3 = <span class="number">1e18</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">2l</span>l*a[i]+<span class="number">2l</span>l*a[j]-s;</div><div class="line">            <span class="keyword">int</span> p = lower_bound(two+<span class="number">1</span>,two+<span class="number">1</span>+tot,make_pair(tmp,make_pair(<span class="number">0</span>,<span class="number">0</span>)))-two;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=max(<span class="number">1</span>,p<span class="number">-2</span>);t&lt;=min(tot,p+<span class="number">2</span>);t++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="built_in">abs</span>(s+two[t].first<span class="number">-2</span>ll*a[i]<span class="number">-2</span>ll*a[j]);</div><div class="line">                <span class="keyword">if</span>(cur&lt;s3)</div><div class="line">                &#123;</div><div class="line">                    s3 = cur;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = min(min(<span class="built_in">abs</span>(s),<span class="built_in">abs</span>(s2)),<span class="built_in">abs</span>(s3));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;360 2018秋招笔试编程题目解析。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="笔试" scheme="http://abumaster.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2018秋招-今日头条</title>
    <link href="http://abumaster.com/2017/08/27/2018%E7%A7%8B%E6%8B%9B-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    <id>http://abumaster.com/2017/08/27/2018秋招-今日头条/</id>
    <published>2017-08-27T09:09:22.000Z</published>
    <updated>2017-08-30T07:31:54.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今日头条2018秋招笔试，编程题目笔记。</p>
</blockquote>
<a id="more"></a>
<h4 id="第二题，求区间内最小值和区间元素和之间的乘积最大值"><a href="#第二题，求区间内最小值和区间元素和之间的乘积最大值" class="headerlink" title="第二题，求区间内最小值和区间元素和之间的乘积最大值"></a>第二题，求区间内最小值和区间元素和之间的乘积最大值</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/36221200.jpg" alt="">  </p>
<p>暴力解法，不可行。看了网上大神的分析，用 <strong>单调栈</strong> 的方法。<br><strong>单调栈</strong><br>单调栈是一个特殊的栈，栈中的元素大小按照其在栈中的位置，满足一定的单调性。<br>基本思想：<br><a href="http://blog.csdn.net/u013616945/article/details/77508372">参考</a>  </p>
<ul>
<li>将数组的每个值作为最小值，找到以此最小值的区间，统计区间和与此值的乘积，假设当前最小值 <code>num[k]</code> ，那么找到最左边小于该值的下标 <code>i</code> ，找到最右边小于该值的值的下标 <code>j</code> ，那么 <code>[i+1, j-1]</code> 是以 <code>num[k]</code> 为最小值所能达到的最大区间，那么计算 <code>Sum(i+1, j-1) * num[k]</code> 。  </li>
<li>按照上述遍历数组中的每一个值，（单调栈实现），维护一个最大值 <code>maxSum</code> 遍历完数组后，可解。  </li>
</ul>
<p>单调栈的实现：栈s<br>数组中元素入栈和出栈的规则如下：  </p>
<ol>
<li>s为空，或者当前元素 <code>num[i]</code> 的值大于等于当前栈顶元素，直接将 <code>num[i]</code> 的下标 <code>i</code> 压入栈；</li>
<li>当s不为空，且当前元素 <code>num[i]</code> 的值小于等于栈顶元素，那么依次从栈中弹出元素，直到 <code>num[i]</code> 大于栈顶元素，并在弹出过程中计算每一个数作为最小值区间的计算结果；  </li>
<li>如果数组遍历完成，但是栈非空，重复步骤2，直到栈空。  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">incr_stack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</div><div class="line">    <span class="keyword">int</span> n = num.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s.empty() || num[i] &gt;=num[s.top()]) &#123;<span class="comment">//规则1</span></div><div class="line">            s.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; num[s.top()] &gt;=num[i]) &#123;<span class="comment">//规则2</span></div><div class="line">                <span class="keyword">int</span> top = s.top();</div><div class="line">                s.pop();</div><div class="line">                <span class="keyword">int</span> tmp=s.empty()? vecSum(num, <span class="number">0</span>, i<span class="number">-1</span>) : vecSum(num, s.top()+ <span class="number">1</span>, i - <span class="number">1</span>);</div><div class="line">                <span class="keyword">int</span> curSum = num[top]*tmp;</div><div class="line">                maxSum = max(curSum, maxSum);</div><div class="line">            &#125;</div><div class="line">            s.push(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;<span class="comment">//规则3</span></div><div class="line">        <span class="keyword">int</span> top = s.top();</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">int</span> tmp=s.empty()? vecSum(num, <span class="number">0</span>, n<span class="number">-1</span>): vecSum(num, s.top()+ <span class="number">1</span>, n - <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> curSum =  num[top]*tmp;</div><div class="line">        maxSum = max(curSum, maxSum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/26465701">扩展题</a><br><div class="note info"><p>给一个数组，返回一个大小相同的数组。返回的数组的第i个位置的值应当是，对于原数组中的第i个元素，至少往右走多少步，才能遇到一个比自己大的元素（如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上-1）。<br><strong>简单的例子：</strong><br>input: 5,3,1,2,4<br>return: -1 3 1 1 -1<br><em>explaination:</em> 对于第0个数字5，之后没有比它更大的数字，因此是-1，对于第1个数字3，需要走3步才能达到4（第一个比3大的元素），对于第2和第3个数字，都只需要走1步，就可以遇到比自己大的元素。对于最后一个数字4，因为之后没有更多的元素，所以是-1。  </p>
</div></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextExceed(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result (input.size(), <span class="number">-1</span>);<span class="comment">//保存结果</span></div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; monoStack;<span class="comment">//单调栈</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); ++i) &#123;</div><div class="line">        <span class="comment">//如果栈不空，并且当前元素大于栈顶元素</span></div><div class="line">        <span class="keyword">while</span>(!monoStack.empty() &amp;&amp; input[monoStack.top()] &lt; input[i]) &#123;</div><div class="line">            result[monoStack.top()] = i - monoStack.top();<span class="comment">//求栈顶元素的结果</span></div><div class="line">            monoStack.pop();<span class="comment">//出栈</span></div><div class="line">        &#125;</div><div class="line">        monoStack.push(i);<span class="comment">//当前比栈顶小，压入栈</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="note warning"><p>给定n个非负数，代表直方图的高度，直方图的宽度为1，找到直方图所组成的矩形的最大面积。<br><em>input：</em> 2,1,5,6,2,3<br><em>output:</em> 10<br><em>explaination:</em> 5和6组成的矩形面积为10，返回10。   </p>
</div>  
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">            height.push_back(<span class="number">0</span>);</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</div><div class="line">                <span class="keyword">while</span>(index.size() &gt; <span class="number">0</span> &amp;&amp; height[index.back()] &gt;= height[i]) &#123;</div><div class="line">                    <span class="keyword">int</span> h = height[index.back()];</div><div class="line">                    index.pop_back();</div><div class="line">                    <span class="keyword">int</span> sidx = index.size() &gt; <span class="number">0</span> ? index.back() : <span class="number">-1</span>;</div><div class="line">                    ret = max(ret, h * (i-sidx<span class="number">-1</span>));</div><div class="line">                &#125;</div><div class="line">                index.push_back(i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h4 id="第三题，调度"><a href="#第三题，调度" class="headerlink" title="第三题，调度"></a>第三题，调度</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/66252799.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/54465329.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-8-30/34202462.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今日头条2018秋招笔试，编程题目笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="笔试" scheme="http://abumaster.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>牛客网校招模拟编程题(1-5)笔记</title>
    <link href="http://abumaster.com/2017/08/18/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%A0%A1%E6%8B%9B%E6%A8%A1%E6%8B%9F%E7%BC%96%E7%A8%8B%E9%A2%98-1-5-%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2017/08/18/牛客网校招模拟编程题-1-5-笔记/</id>
    <published>2017-08-18T06:43:17.000Z</published>
    <updated>2017-08-22T06:07:25.469Z</updated>
    
    <content type="html"><![CDATA[<p>牛客网上的2017年校招全国统一模拟试题的编程题目，比较难的一些题目汇总，做下记录。  </p>
<a id="more"></a>
<p><strong>1.猜数字游戏</strong><br><div class="note primary"><p>题目描述：<a href="https://www.nowcoder.com/test/5986669/summary">题目链接</a><br>牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中,牛牛玩家选择一个正整数,羊羊根据已给的提示猜这个数字。第i个提示是”Y”或者”N”,表示牛牛选择的数是否是i的倍数。<br>例如,如果提示是”YYNYY”,它表示这个数使1,2,4,5的倍数,但不是3的倍数。<br>注意到一些提示会出现错误。例如: 提示”NYYY”是错误的,因为所有的整数都是1的倍数,所以起始元素肯定不会是”N”。此外,例如”YNNY”的提示也是错误的,因为结果不可能是4的倍数但不是2的倍数。<br>现在给出一个整数n,表示已给的提示的长度。请计算出长度为n的合法的提示的个数。<br>例如 n = 5:<br>合法的提示有:<br>YNNNN YNNNY YNYNN YNYNY YYNNN YYNNY<br>YYNYN YYNYY YYYNN YYYNY YYYYN YYYYY<br>所以输出12  </p>
</div>  </p>
<p>合法的条件是存在倍数依赖的数字要么是全为Y要么全为N，分析：  </p>
<ul>
<li>第 i 个数是素数（如2,3,5,7…），那么在这一位上是Y或N与前面没有依赖，因此当前位的可能数目sum(i)是前面数目sum(i-1)的2倍；  </li>
<li>第 i 个数是偶数，但是却不是素数的幂，（如6,10…），那么这一位是Y或N完全取决于它的两个因子，如6取决于2和3,2和3是Y，6一定是Y。因此，sum(i)为sum(i-1)；  </li>
<li>第 i 个数是素数的幂，（如4,9,8…），它是不能唯一确定的，2取Y，4可以取Y也可以取N，所以对于4，将2,4加入集合取值的组合为NN，YN，YY三种情况，对于8来说，由2,4,8组成，共有NNN，YNN，YYN，YYY四种情况，依次类推就行了，相乘。  </li>
</ul>
<p>关键代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (vis[i])<span class="comment">//是倍数直接可以忽略掉不要重复计算</span></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)<span class="comment">//倍数</span></div><div class="line">    &#123;</div><div class="line">        vis[j] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求i的幂次</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mi = i;</div><div class="line">    <span class="keyword">while</span> (mi &lt;= n)</div><div class="line">    &#123;</div><div class="line">        cnt++;<span class="comment">//记录幂的数目</span></div><div class="line">        mi *= i;</div><div class="line">    &#125;</div><div class="line">    ans = ans * (cnt + <span class="number">1</span>) % MOD;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p><strong>2.庆祝六一</strong><br>题目描述：<br>牛家庄幼儿园为庆祝61儿童节举办庆祝活动,庆祝活动中有一个节目是小朋友们围成一个圆圈跳舞。牛老师挑选出n个小朋友参与跳舞节目,已知每个小朋友的身高h_i。为了让舞蹈看起来和谐，牛老师需要让跳舞的圆圈队形中相邻小朋友的身高差的最大值最小，牛老师犯了难，希望你能帮帮他。<br>如样例所示:<br>当圆圈队伍按照100,98,103,105顺时针排列的时候最大身高差为5，其他排列不会得到更优的解。  </p>
<p><a href="https://www.nowcoder.com/test/question/done?tid=10037688&amp;qid=104799#summary">分析</a><br>身高差最小，将两个差不多的身高的站一块。
如 9 8 7 6 6 7 8 9然后9和9再拉手不就可以了吗 ！所以将数据输入一个数组如【8 9 7 6 5 4 3 2】然后排序【2 3 4 5 6 7 8 9】然后遍历数组进入一个队列一个栈 现规定，索引为0,2,4，，，的依次进入队列Q1，索引为1,3,5，，，，的依次进入//栈S1，就形成一个队列2 4 6 8 （队列尾为8）和一个栈3 5 7 9（栈顶为9） 。然后出栈9 7 5 3依次进入队列尾 形成 2 4 6 8 9 7 5 3 就排队成功，2和3拉手就成圈，求每个元素与挨着的距离就可以了。<br>分析2：<br>动态规划，先将所有的小朋友按低到高排序，dp[i] 表示前i个小朋友最优排列的最大身高差，递推公式为： dp[i+1]=max(dp[i],arr[i+1]-arr[i-1])。  </p>
<p><strong>3.逃离农场</strong><br>题目描述：<br>牛牛在农场饲养了n只奶牛,依次编号为0到n-1, 牛牛的好朋友羊羊帮牛牛照看着农场.有一天羊羊看到农场中逃走了k只奶牛,但是他只会告诉牛牛逃走的k只奶牛的编号之和能被n整除。你现在需要帮牛牛计算有多少种不同的逃走的奶牛群。因为结果可能很大,输出结果对1,000,000,007取模。<br>例如n = 7 k = 4:<br>7只奶牛依次编号为0到6, 逃走了4只<br>编号和为7的有:{0, 1, 2, 4}<br>编号和为14的有:{0, 3, 5, 6}, {1, 2, 5, 6}, {1, 3, 4, 6},{2, 3, 4, 5}<br>4只牛的编号和不会大于18,所以输出5。<br>分析：<br>动态规划，令<code>dp[i][j][s]</code>表示从区间[0,i]中取j个数字，使它们的和与n取模后余数为s，满足这样条件的集合的个数。<br>状态转移方程如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j][s] = (dp[i<span class="number">-1</span>][j][s] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>][(n+s-i)%n]);</div></pre></td></tr></table></figure></p>
<p>转移的过程就是第i个数取还是不取，如果不取，那么就和方法i-1的个数相同；<br>如果取第i个数的话，那么就需要分两种情况，因为第i个数可能大于s，也有可能小于等于s。<br><em>情况1：</em>若<code>i&lt;=s</code>,此时我们需要从前i-1个数中取j-1个数，使他们的和与n的模为s-i。这样就能保证在加入i时，和模n等于s。<br><em>情况2：</em>如果i&gt;s,那么i-s为负数，注意本题的要求是组成和为n的倍数，因此这种情况下需要将<code>(s-i)%n</code>表示为<code>（s-i+n）%n</code>，因为<code>((s-i+n)%n+i)%n=s</code>。<br>可以压缩空间，减少空间复杂度。代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> modMin=<span class="number">1e9</span>+<span class="number">7</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line">  </span>&#123;</div><div class="line">    <span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">1005</span>];</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> n,k;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">      &#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">           &#123;</div><div class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;=<span class="number">1</span>;j--)</div><div class="line">               &#123;</div><div class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;n;s++)</div><div class="line">                    &#123;</div><div class="line">                       dp[j][s]=(dp[j][s]+dp[j<span class="number">-1</span>][(n+s-i)%n])%modMin;</div><div class="line">                    &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">         <span class="built_in">cout</span>&lt;&lt;dp[k][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.牛牛的数列</strong><br>题目描述：<br>牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。<br>输入描述:<br>输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;<br>第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。<br>输出描述:<br>输出一个整数,表示最长的长度。<br>输入例子:<br>6<br>7 2 3 1 5 6<br>输出例子:<br>5<br>分析：<br>动态规划问题，题目中改变一个数字所能达到的严格上升子序列的最大长度，可以假设有两段上升子序列，它们中间可以改变一个数字，使他们连接起来，找到它们之间最长的就行了。<br>因此，设<code>dp1[i]</code>表示i结尾的最长上升子序列的长度，<code>dp2[i]</code>表示以i开始的最长上升子序列长度。分别从前或从后扫描计算即可。<br>然后，扫描数列，对于第i个数，i是第一个数，那么长度为<code>dp2[i+1]+1</code>，如果i为最后一个数，那么长度为<code>dp1[i-1]+1</code>，其他情况，如果i+1的值与i-1之间差值大于1，那么长度为<code>dp2[i+1]+dp1[i-1]+1</code>，如果不大于1只能在前或者在后取一个值了，长度为<code>max(dp2[i+1]+1,dp1[i-1]+1)</code>。<br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> dp[maxn], dp1[maxn];</div><div class="line"><span class="keyword">int</span> data[maxn];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; data[i];</div><div class="line">    &#125;</div><div class="line">    dp[n - <span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//以i开始的上升子序列的长度</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (data[i] &lt; data[i + <span class="number">1</span>])</div><div class="line">            dp[i] = dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            dp[i] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    dp1[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)<span class="comment">//以i结尾的上升子序列的长度</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (data[i]&gt;data[i - <span class="number">1</span>])</div><div class="line">            dp1[i] = dp1[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            dp1[i] = <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>, m = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            m = dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            m = dp1[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data[i - <span class="number">1</span>] + <span class="number">1</span> &lt; data[i + <span class="number">1</span>])</div><div class="line">        &#123;</div><div class="line">            m = dp1[i - <span class="number">1</span>] + dp[i + <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            m = max(dp[i + <span class="number">1</span>] + <span class="number">1</span>, dp1[i - <span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (m &gt; ret)</div><div class="line">            ret = m;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>5.创造新世界</strong><br><div class="note default"><p>众所周知计算机代码底层计算都是0和1的计算，牛牛知道这点之后就想使用0和1创造一个新世界！牛牛现在手里有n个0和m个1，给出牛牛可以创造的x种物品，每种物品都由一个01串表示。牛牛想知道当前手中的0和1可以最多创造出多少种物品。<br><em>输入描述</em><br>输入数据包括x+1行：<br>第一行包括三个整数x(2 ≤ x ≤ 20)，n(0 ≤ n ≤ 500)，m(0 ≤ m ≤ 500)，以空格分隔<br>接下来的x行，每行一个01串item[i]，表示第i个物品。每个物品的长度length(1 ≤ length ≤ 50)<br><em>输出描述</em><br>输出一个整数，表示牛牛最多能创造多少种物品  </p>
</div><br>分析：<br>典型的二维背包问题：<br>对于每件物品,当选择这件物品必须同时付出两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。<br>设第i件物品所需的两种代价分别为<code>a[i]</code>和<code>b[i]</code>，两种代价可付出的最大值（两种背包容量）分别为u和v。物品的价值为<code>w[i]</code>。状态转移方程：<br><code>dp[i][u][v] = max(dp[i-1][u][v] , w[i] + dp[i-1][u-a[i]][v-b[i]])</code><br>同样的进行空间压缩，我们可以得到二维数组的状态转移方程，u，v采用倒序，如下：
<code>dp[u][v] = max(dp[u-a[i]][v-b[i]]+w[i],dp[u][v])</code><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s_item</div><div class="line">&#123;</div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    <span class="keyword">int</span> _zero;</div><div class="line">    <span class="keyword">int</span> _one;</div><div class="line">    s_item()&#123; _zero = <span class="number">0</span>; _one = <span class="number">0</span>; str = <span class="string">""</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution_CreateWorld</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    s_item item[<span class="number">25</span>];</div><div class="line">    <span class="keyword">int</span> x, n, m;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; n &gt;&gt; m;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; item[i].str;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; item[i].str.size(); ++j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (item[i].str[j] == <span class="string">'0'</span>)</div><div class="line">                ++item[i]._zero;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item[i].str[j] == <span class="string">'1'</span>)</div><div class="line">                ++item[i]._one;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</div><div class="line">        &#123;</div><div class="line">            dp[i][j] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= item[i]._zero; --j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = m; k &gt;= item[i]._one; --k)</div><div class="line">            &#123;</div><div class="line">                dp[j][k] = max(dp[j - item[i]._zero][k - item[i]._one] + <span class="number">1</span>, dp[j][k]);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>6.优美的回文串</strong><br><div class="note info"><p>牛牛在书上看到一种字符串叫做回文串,当一个字符串从左到右和从右到左读都是一样的,就称这个字符串为回文串。牛牛又从好朋友羊羊那里了解到一种被称为优美的回文串的字符串,考虑一个长度为N只包含大写字母的字符串,写出它所有长度为M的连续子串(包含所有可能的起始位置的子串,相同的子串也要计入),如果这个字符串至少有K个子串都是回文串,我们就叫这个字符串为优美的回文串。现在给出一个N,牛牛希望你能帮他计算出长度为N的字符串有多少个是优美的回文串(每个位置都可以是’A’~’Z’的一个。)<br><em>输入描述:</em><br>输入数据包括三个整数N, M, K(2 ≤ N ≤ 11, 2 ≤ M ≤ N, 0 ≤ K ≤ 11).<br><em>输出描述:</em><br>输出一个整数,表示所求的字符串个数.<br><em>输入例子:</em><br>2 2 1<br><em>输出例子:</em><br>26 长度为2的字符串,它长度为2的子串只有它自身。长度为2的回文串有”AA”,”BB”,”CC”…”ZZ”,一共26种。  </p>
</div>
<a href="http://blog.csdn.net/scruelt/article/details/65940130?locationNum=1&amp;fps=1">参考</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客网上的2017年校招全国统一模拟试题的编程题目，比较难的一些题目汇总，做下记录。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="算法" scheme="http://abumaster.com/tags/algorithm/"/>
    
      <category term="编程" scheme="http://abumaster.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="面试" scheme="http://abumaster.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读3：定时器</title>
    <link href="http://abumaster.com/2017/08/01/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://abumaster.com/2017/08/01/libev源码阅读3：定时器/</id>
    <published>2017-08-01T06:51:24.000Z</published>
    <updated>2017-08-01T13:12:55.814Z</updated>
    
    <content type="html"><![CDATA[<p>定时器作为libev的一个重要监测器，用于超时处理和周期执行任务，通过4叉最小堆管理定时器，据说高效利用CPU缓存。  </p>
<a id="more"></a>
<h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><p>堆是一种树形结构，分为最大堆和最小堆，分别是根节点是最大元素或最小元素，stl中利用二叉大顶堆实现优先级队列以及堆算法。<br>堆的节点一般存放在数组中，在数组的排列有一定的规律，堆没有节点漏洞，按层依次排列的，如堆是从数组array的索引为1的位置开始排列，那么某个节点位于i的位置，其左孩子位于2i处，右孩子位于2i+1处，父节点位于i/2处（/ 为取整）。从0开始排列，节点i的左右孩子节点的索引分别为2i+1，2i+2，父节点为(i-1)/2 。n叉堆的孩子[ni+1,…,ni+n]<br>对于堆的调整，一般用到向上调整和向下调整两种方式，下面结合代码详细注释。  </p>
<h4 id="四叉堆"><a href="#四叉堆" class="headerlink" title="四叉堆"></a>四叉堆</h4><p>libev中的四叉堆的根节点索引是3，从3开始依次向后排列，那么i节点的孩子的范围为[4(i-3)+1+3,…,4(i-3)+4+3]，父节点为(i-3-1)/4+3 。<br>堆元素的结构
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用缓存的情况下</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    ev_tstamp at;</div><div class="line">    WT w;</div><div class="line">  &#125; ANHE;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_w(he)        (he).w     <span class="comment">/* access watcher, read-write */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_at(he)       (he).at    <span class="comment">/* access cached at, read-only */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ANHE_at_cache(he) (he).at = (he).w-&gt;at <span class="comment">/* update at from watcher */</span></span></div></pre></td></tr></table></figure></p>
<p>堆算法实现如下：<br><strong>downheap 函数：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_4HEAP <span class="comment">//如果定义了4叉堆</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DHEAP 4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP0 (DHEAP - 1) <span class="comment">/* index of first element in heap */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HPARENT(k) ((((k) - HEAP0 - 1) / DHEAP) + HEAP0) <span class="comment">//获得k的父节点</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UPHEAP_DONE(p,k) ((p) == (k)) <span class="comment">//是否更新完成</span></span></div><div class="line"></div><div class="line"><span class="comment">//从根向下调整，N为堆的元素个数，k表示要调整元素的索引</span></div><div class="line"><span class="function">inline_speed <span class="keyword">void</span></div><div class="line"><span class="title">downheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">    ANHE he = heap [k];<span class="comment">//先获得调整</span></div><div class="line">    ANHE *E = heap + N + HEAP0;<span class="comment">//结束的指针</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">        ev_tstamp minat; <span class="comment">//最小的元素</span></div><div class="line">        ANHE *minpos; <span class="comment">//最小元素的指针</span></div><div class="line">        ANHE *pos = heap + DHEAP * (k - HEAP0) + HEAP0 + <span class="number">1</span>;<span class="comment">//k的第一个孩子的指针</span></div><div class="line"></div><div class="line">        <span class="comment">//查找k的最小孩子</span></div><div class="line">        <span class="keyword">if</span> (expect_true (pos + DHEAP - <span class="number">1</span> &lt; E))<span class="comment">//最后一个孩子没有越界，有四个孩子</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在四个孩子中找最小的</span></div><div class="line">            (minpos = pos + <span class="number">0</span>), (minat = ANHE_at (*minpos));<span class="comment">//设置初值</span></div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">1</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">1</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">2</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">2</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (ANHE_at (pos [<span class="number">3</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">3</span>), (minat = ANHE_at (*minpos));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; E)<span class="comment">//有孩子，但是不是4个孩子</span></div><div class="line">        &#123;</div><div class="line">            (minpos = pos + <span class="number">0</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">1</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">1</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">1</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">2</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">2</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">2</span>), (minat = ANHE_at (*minpos));</div><div class="line">            <span class="keyword">if</span> (pos + <span class="number">3</span> &lt; E &amp;&amp; ANHE_at (pos [<span class="number">3</span>]) &lt; minat) </div><div class="line">                (minpos = pos + <span class="number">3</span>), (minat = ANHE_at (*minpos));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="comment">//其他情况，没孩子，不用调整退出循环</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//当前节点小于最小孩子，已经是最小堆，不用调整退出</span></div><div class="line">        <span class="keyword">if</span> (ANHE_at (he) &lt;= minat)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//否则将最小元素调到k的位置</span></div><div class="line">        heap [k] = *minpos;</div><div class="line">        ev_active (ANHE_w (*minpos)) = k;<span class="comment">//将时间监测器设置为索引k</span></div><div class="line"></div><div class="line">        k = minpos - heap;<span class="comment">//设置下一次调整的根节点</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    heap [k] = he;<span class="comment">//将元素填充到k中</span></div><div class="line">    ev_active (ANHE_w (he)) = k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有定义四叉堆的宏，那么就是简单的二叉堆的定义和调整。<br><strong>upheap 函数：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从k向根调整</span></div><div class="line"><span class="function">inline_speed <span class="keyword">void</span></div><div class="line"><span class="title">upheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">    ANHE he = heap [k];<span class="comment">//先记录k位置的元素</span></div><div class="line">    <span class="comment">//循环调整</span></div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> p = HPARENT (k);<span class="comment">//获得k的父节点</span></div><div class="line">        <span class="comment">//是否等于父节点（调整完成）或者父节点的元素小于当前的</span></div><div class="line">        <span class="keyword">if</span> (UPHEAP_DONE (p, k) || ANHE_at (heap [p]) &lt;= ANHE_at (he))</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        heap [k] = heap [p];<span class="comment">//</span></div><div class="line">        ev_active (ANHE_w (heap [k])) = k;</div><div class="line">        k = p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  heap [k] = he;</div><div class="line">  ev_active (ANHE_w (he)) = k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>adjust 和 reheap 函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* move an element suitably so it is in a correct place */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span></div><div class="line"><span class="title">adjustheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (k &gt; HEAP0 &amp;&amp; ANHE_at (heap [k]) &lt;= ANHE_at (heap [HPARENT (k)]))</div><div class="line">    upheap (heap, k);<span class="comment">//k的元素小于父节点的元素，向上调整</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    downheap (heap, N, k);<span class="comment">//向下调整</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* rebuild the heap: this function is used only once and executed rarely */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span></div><div class="line"><span class="title">reheap</span> <span class="params">(ANHE *heap, <span class="keyword">int</span> N)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">  <span class="comment">/* we don't use floyds algorithm, upheap is simpler and is more cache-efficient */</span></div><div class="line">  <span class="comment">/* also, this is easy to implement and correct for both 2-heaps and 4-heaps */</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i)<span class="comment">//直接向上调整，简单高效</span></div><div class="line">    upheap (heap, i + HEAP0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="超时监视器"><a href="#超时监视器" class="headerlink" title="超时监视器"></a>超时监视器</h4><p><strong>基本数据结构</strong><br>相对时间。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_timer</div><div class="line">&#123;</div><div class="line">    <span class="comment">//EV_WATCHER_TIME (ev_timer)</span></div><div class="line">    <span class="keyword">int</span> active;   </div><div class="line">    <span class="keyword">int</span> pending;  </div><div class="line">    <span class="keyword">int</span> priority;  </div><div class="line">    <span class="keyword">void</span> *data;  </div><div class="line">    <span class="keyword">void</span> (*cb)(<span class="keyword">struct</span> ev_loop *loop, <span class="keyword">struct</span> ev_timer *w, <span class="keyword">int</span> revents);    </div><div class="line">  </div><div class="line">    ev_tstamp at; <span class="comment">//定时器第一次触发的时间点</span></div><div class="line">    ev_tstamp repeat; <span class="comment">/* rw */</span> <span class="comment">//每隔几秒触发一次，0表示只触发一次</span></div><div class="line">&#125; ev_timer;</div></pre></td></tr></table></figure></p>
<p><strong>初始化超时监视器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化，调用两个宏来初始化成员</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_timer_init(ev,cb,after,repeat) \</div><div class="line">do &#123; ev_init ((ev), (cb)); \</div><div class="line">    ev_timer_set ((ev),(after),(repeat)); \</div><div class="line">    &#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_init(ev,cb_) do &#123;            \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;active  =   \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;pending = 0;    \</div><div class="line">  ev_set_priority ((ev), 0);            \</div><div class="line">  ev_set_cb ((ev), cb_);            \</div><div class="line">&#125; while (0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_timer_set(ev,after_,repeat_)      \</div><div class="line">do &#123; ((ev_watcher_time *)(ev))-&gt;at = (after_); \</div><div class="line">    (ev)-&gt;repeat = (repeat_); &#125; while (0)</span></div></pre></td></tr></table></figure></p>
<p><strong>启动超时器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">noinline</div><div class="line"><span class="keyword">void</span></div><div class="line"><span class="title">ev_timer_start</span> <span class="params">(EV_P_ ev_timer *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (expect_false (ev_is_active (w)))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    ev_at (w) += mn_now;<span class="comment">//设置at时间点，此时间点触发，相对于mn_now，当前日历时间</span></div><div class="line"></div><div class="line">    assert ((<span class="string">"libev: ev_timer_start called with negative timer repeat value"</span>, w-&gt;repeat &gt;= <span class="number">0.</span>));</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">    <span class="comment">//将timer加入到堆中并向上调整，active表示的是堆数组中的下标</span></div><div class="line">    ++timercnt;</div><div class="line">    ev_start (EV_A_ (W)w, timercnt + HEAP0 - <span class="number">1</span>);</div><div class="line">    array_needsize (ANHE, timers, timermax, ev_active (w) + <span class="number">1</span>, EMPTY2);</div><div class="line">    ANHE_w (timers [ev_active (w)]) = (WT)w;</div><div class="line">    ANHE_at_cache (timers [ev_active (w)]);</div><div class="line">    upheap (timers, ev_active (w));</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">    <span class="comment">/*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>停止计时器</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">noinline</div><div class="line"><span class="keyword">void</span></div><div class="line"><span class="title">ev_timer_stop</span> <span class="params">(EV_P_ ev_timer *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    clear_pending (EV_A_ (W)w);<span class="comment">//从pending中移除</span></div><div class="line">    <span class="keyword">if</span> (expect_false (!ev_is_active (w)))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> active = ev_active (w);<span class="comment">//获得定时器在堆中的索引</span></div><div class="line">        assert ((<span class="string">"libev: internal timer heap corruption"</span>, ANHE_w (timers [active]) == (WT)w));</div><div class="line">        --timercnt;<span class="comment">//数量减一</span></div><div class="line">        <span class="keyword">if</span> (expect_true (active &lt; timercnt + HEAP0))</div><div class="line">        &#123;</div><div class="line">            timers [active] = timers [timercnt + HEAP0];<span class="comment">//最后一个元素补充上来</span></div><div class="line">            adjustheap (timers, timercnt, active);<span class="comment">//调整</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ev_at (w) -= mn_now;</div><div class="line">    ev_stop (EV_A_ (W)w);</div><div class="line">    EV_FREQUENT_CHECK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="周期定时器"><a href="#周期定时器" class="headerlink" title="周期定时器"></a>周期定时器</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时器作为libev的一个重要监测器，用于超时处理和周期执行任务，通过4叉最小堆管理定时器，据说高效利用CPU缓存。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读2：运行流程</title>
    <link href="http://abumaster.com/2017/07/31/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://abumaster.com/2017/07/31/libev源码阅读2：运行流程/</id>
    <published>2017-07-31T10:39:49.000Z</published>
    <updated>2017-07-31T13:38:14.246Z</updated>
    
    <content type="html"><![CDATA[<p>一般的流程：创建默认的事件循环，创建一个事件监测器和回调函数并初始化（init），将监测器放入事件循环（start）中，循环开始等待事件（run）的到来。<br><a id="more"></a></p>
<p><strong>1.主要流程</strong><br>如果在libev中创建一个IO监测器，主循环等待IO事件的触发，触发后调用回调函数，执行相关操作。其主要流程如下：  </p>
<ul>
<li>首先调用<code>ev_default_loop</code>初始化<code>struct  ev_loop</code>结构；  </li>
<li>然后调用<code>ev_io_init</code>初始化监视器中的属性，该宏主要就是调用<code>ev_init</code>和<code>ev_io_set</code>；  </li>
<li>然后调用<code>ev_io_start</code>启动该监视器，该函数主要是将监视器添加到<code>loop-&gt;anfds</code>结构中，将监视的描述符添加到<code>((loop)-&gt;fdchanges)</code>中；</li>
<li>调用<code>ev_run</code>开始等待事件的触发。</li>
</ul>
<p>使用，官方提供的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a single header file is required</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ev.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // for puts</span></span></div><div class="line"><span class="comment">// every watcher type has its own typedef'd struct</span></div><div class="line"><span class="comment">// with the name ev_TYPE</span></div><div class="line">ev_io stdin_watcher;</div><div class="line">ev_timer timeout_watcher;</div><div class="line"><span class="comment">// all watcher callbacks have a similar signature</span></div><div class="line"><span class="comment">// this callback is called when data is readable on stdin</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">stdin_cb</span> <span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="built_in">puts</span> (<span class="string">"stdin ready"</span>);</div><div class="line">  <span class="comment">// for one-shot events, one must manually stop the watcher</span></div><div class="line">  <span class="comment">// with its corresponding stop function.</span></div><div class="line">  ev_io_stop (EV_A_ w);</div><div class="line">  <span class="comment">// this causes all nested ev_run's to stop iterating</span></div><div class="line">  ev_break (EV_A_ EVBREAK_ALL);</div><div class="line">&#125;</div><div class="line"><span class="comment">// another callback, this time for a time-out</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">timeout_cb</span> <span class="params">(EV_P_ ev_timer *w, <span class="keyword">int</span> revents)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="built_in">puts</span> (<span class="string">"timeout"</span>);</div><div class="line">  <span class="comment">// this causes the innermost ev_run to stop iterating</span></div><div class="line">  ev_break (EV_A_ EVBREAK_ONE);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="comment">// use the default event loop unless you have special needs</span></div><div class="line">  <span class="keyword">struct</span> ev_loop *loop = EV_DEFAULT;</div><div class="line">  <span class="comment">// initialise an io watcher, then start it</span></div><div class="line">  <span class="comment">// this one will watch for stdin to become readable</span></div><div class="line">  ev_io_init (&amp;stdin_watcher, stdin_cb, <span class="comment">/*STDIN_FILENO*/</span> <span class="number">0</span>, EV_READ);</div><div class="line">  ev_io_start (loop, &amp;stdin_watcher);</div><div class="line">  <span class="comment">// initialise a timer watcher, then start it</span></div><div class="line">  <span class="comment">// simple non-repeating 5.5 second timeout</span></div><div class="line">  ev_timer_init (&amp;timeout_watcher, timeout_cb, <span class="number">5.5</span>, <span class="number">0.</span>);</div><div class="line">  ev_timer_start (loop, &amp;timeout_watcher);</div><div class="line">  <span class="comment">// now wait for events to arrive</span></div><div class="line">  ev_run (loop, <span class="number">0</span>);</div><div class="line">  <span class="comment">// break was called, so exit</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中有几个奇怪的宏<code>EV_P EV_P_ EV_A EV_A_</code>，它们代表了：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EV_P  == <span class="keyword">struct</span> ev_loop* loop <span class="comment">//event parameter</span></div><div class="line">EV_P_ == EV_P, == <span class="keyword">struct</span> ev_loop* loop, </div><div class="line">EV_A  == loop <span class="comment">//event argument</span></div><div class="line">EV_A_ == EV_A, == loop,</div></pre></td></tr></table></figure></p>
<p><strong>2.ev_default_loop 函数</strong><br>假设定义了EV_MULTIPLICITY，多循环支持，返回一个ev_loop结构指针，否则返回一个整数。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> ev_loop * <span class="title">ev_default_loop</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (!ev_default_loop_ptr)</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_MULTIPLICITY</span></div><div class="line">      EV_P = ev_default_loop_ptr = &amp;default_loop_struct;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">      ev_default_loop_ptr = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//调用此函数初始化</span></div><div class="line">    loop_init (EV_A_ flags);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ev_backend (EV_A))</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_CHILD_ENABLE</span></div><div class="line">          ev_signal_init (&amp;childev, childcb, SIGCHLD);</div><div class="line">          ev_set_priority (&amp;childev, EV_MAXPRI);</div><div class="line">          ev_signal_start (EV_A_ &amp;childev);</div><div class="line">          ev_unref (EV_A); <span class="comment">/* child watcher should not keep loop alive */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ev_default_loop_ptr = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> ev_default_loop_ptr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以下是loop_init函数，初始化loop中的各个成员</span></div><div class="line"><span class="comment">/* initialise a loop structure, must be zero-initialised */</span></div><div class="line"><span class="function">noinline ecb_cold</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line"><span class="title">loop_init</span> <span class="params">(EV_P_ <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (!backend)</div><div class="line">    &#123;</div><div class="line">        origflags = flags;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_REALTIME</span></div><div class="line">        <span class="keyword">if</span> (!have_realtime)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">struct</span> timespec ts;</div><div class="line">            <span class="keyword">if</span> (!clock_gettime (CLOCK_REALTIME, &amp;ts))</div><div class="line">                have_realtime = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_MONOTONIC</span></div><div class="line">        <span class="keyword">if</span> (!have_monotonic)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">struct</span> timespec ts;</div><div class="line">            <span class="keyword">if</span> (!clock_gettime (CLOCK_MONOTONIC, &amp;ts))</div><div class="line">                have_monotonic = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></div><div class="line">        <span class="keyword">if</span> (flags &amp; EVFLAG_FORKCHECK)</div><div class="line">            curpid = getpid ();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(flags &amp; EVFLAG_NOENV)</div><div class="line">          &amp;&amp; !enable_secure ()</div><div class="line">          &amp;&amp; getenv (<span class="string">"LIBEV_FLAGS"</span>))</div><div class="line">            flags = atoi (getenv (<span class="string">"LIBEV_FLAGS"</span>));</div><div class="line"></div><div class="line">        ev_rt_now          = ev_time ();</div><div class="line">        mn_now             = get_clock ();</div><div class="line">        now_floor          = mn_now;</div><div class="line">        rtmn_diff          = ev_rt_now - mn_now;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">        invoke_cb          = ev_invoke_pending;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        io_blocktime       = <span class="number">0.</span>;</div><div class="line">        timeout_blocktime  = <span class="number">0.</span>;</div><div class="line">        backend            = <span class="number">0</span>;</div><div class="line">        backend_fd         = <span class="number">-1</span>;</div><div class="line">        sig_pending        = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_ASYNC_ENABLE</span></div><div class="line">        async_pending      = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        pipe_write_skipped = <span class="number">0</span>;</div><div class="line">        pipe_write_wanted  = <span class="number">0</span>;</div><div class="line">        evpipe [<span class="number">0</span>]         = <span class="number">-1</span>;</div><div class="line">        evpipe [<span class="number">1</span>]         = <span class="number">-1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_INOTIFY</span></div><div class="line">        fs_fd              = flags &amp; EVFLAG_NOINOTIFY ? <span class="number">-1</span> : <span class="number">-2</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_SIGNALFD</span></div><div class="line">        sigfd              = flags &amp; EVFLAG_SIGNALFD  ? <span class="number">-2</span> : <span class="number">-1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(flags &amp; EVBACKEND_MASK))</div><div class="line">            flags |= ev_recommended_backends ();</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_IOCP</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_IOCP  )) backend = iocp_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_PORT</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_PORT  )) backend = port_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_KQUEUE</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_KQUEUE)) backend = kqueue_init (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_EPOLL</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_EPOLL )) backend = epoll_init  (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_POLL</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_POLL  )) backend = poll_init   (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_USE_SELECT</span></div><div class="line">        <span class="keyword">if</span> (!backend &amp;&amp; (flags &amp; EVBACKEND_SELECT)) backend = select_init (EV_A_ flags);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="comment">//如上一章介绍的函数，初始化调用前事件，准备好了，其实什么也没做</span></div><div class="line">        <span class="comment">//表示在此期间等待监测器到来</span></div><div class="line">        ev_prepare_init (&amp;pending_w, pendingcb);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE</span></div><div class="line">        ev_init (&amp;pipe_w, pipecb);<span class="comment">//初始化监测器的pipe</span></div><div class="line">        ev_set_priority (&amp;pipe_w, EV_MAXPRI);<span class="comment">//设置为最大优先级</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.ev_io_init 函数</strong><br>初始化io监测器，初始化结构中的成员，上一节中介绍了。<br><strong>4.ev_io_start 函数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_io_start</span> <span class="params">(EV_P_ ev_io *w)</span> EV_THROW</div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">int</span> fd = w-&gt;fd;<span class="comment">//获得监视器的描述符</span></div><div class="line">  <span class="comment">//监视器没开始</span></div><div class="line">  <span class="keyword">if</span> (expect_false (ev_is_active (w)))</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with negative fd"</span>, fd &gt;= <span class="number">0</span>));</div><div class="line">  <span class="comment">//屏蔽其他的</span></div><div class="line">  <span class="comment">//0x80 0x01 0x02 events的取值</span></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with illegal event mask"</span>, !(w-&gt;events &amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));</div><div class="line"></div><div class="line">  EV_FREQUENT_CHECK;</div><div class="line">  <span class="comment">//调整优先级并设置为活动状态，</span></div><div class="line">  ev_start (EV_A_ (W)w, <span class="number">1</span>);</div><div class="line">  <span class="comment">//调整loop-&gt;anfds数组的大小，并将监测器加入到[fd]的链表中</span></div><div class="line">  array_needsize (ANFD, anfds, anfdmax, fd + <span class="number">1</span>, array_init_zero);</div><div class="line">  wlist_add (&amp;anfds[fd].head, (WL)w);</div><div class="line"></div><div class="line">  <span class="comment">/* common bug, apparently */</span></div><div class="line">  assert ((<span class="string">"libev: ev_io_start called with corrupted watcher"</span>, ((WL)w)-&gt;next != (WL)w));</div><div class="line"></div><div class="line">  fd_change (EV_A_ fd, w-&gt;events &amp; EV__IOFDSET | EV_ANFD_REIFY);</div><div class="line">  w-&gt;events &amp;= ~EV__IOFDSET;<span class="comment">//掩码消除</span></div><div class="line">  EV_FREQUENT_CHECK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//fd_change函数</span></div><div class="line"><span class="comment">/* something about the given fd changed */</span></div><div class="line"><span class="function">inline_size <span class="keyword">void</span> <span class="title">fd_change</span> <span class="params">(EV_P_ <span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span></div><div class="line"></span>&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> reify = anfds [fd].reify;</div><div class="line">  anfds [fd].reify |= flags;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (expect_true (!reify))<span class="comment">//以前不存在，调整大小加入变化数组中</span></div><div class="line">    &#123;</div><div class="line">      ++fdchangecnt;</div><div class="line">      array_needsize (<span class="keyword">int</span>, fdchanges, fdchangemax, fdchangecnt, EMPTY2);</div><div class="line">      fdchanges [fdchangecnt - <span class="number">1</span>] = fd;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.ev_run 函数</strong><br>主要功能循环等待事件的到来。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ev_run</span> <span class="params">(EV_P_ <span class="keyword">int</span> flags)</span></div><div class="line"></span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">  ++loop_depth;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  assert ((<span class="string">"libev: ev_loop recursion during release detected"</span>, loop_done != EVBREAK_RECURSE));</div><div class="line">  loop_done = EVBREAK_CANCEL;</div><div class="line"></div><div class="line">  EV_INVOKE_PENDING; <span class="comment">/* in case we recurse, ensure ordering stays nice and clean */</span></div><div class="line"></div><div class="line">  <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_VERIFY &gt;= 2</span></div><div class="line">      ev_verify (EV_A);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></div><div class="line">      <span class="keyword">if</span> (expect_false (curpid)) <span class="comment">/* penalise the forking check even more */</span></div><div class="line">        <span class="keyword">if</span> (expect_false (getpid () != curpid))</div><div class="line">          &#123;</div><div class="line">            curpid = getpid ();</div><div class="line">            postfork = <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FORK_ENABLE</span></div><div class="line">      <span class="comment">/* we might have forked, so queue fork handlers */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (postfork))</div><div class="line">        <span class="keyword">if</span> (forkcnt)</div><div class="line">          &#123;</div><div class="line">            queue_events (EV_A_ (W *)forks, forkcnt, EV_FORK);</div><div class="line">            EV_INVOKE_PENDING;</div><div class="line">          &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PREPARE_ENABLE</span></div><div class="line">      <span class="comment">/* queue prepare watchers (and execute them) */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (preparecnt))</div><div class="line">        &#123;</div><div class="line">          queue_events (EV_A_ (W *)prepares, preparecnt, EV_PREPARE);</div><div class="line">          EV_INVOKE_PENDING;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (expect_false (loop_done))</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* we might have forked, so reify kernel state if necessary */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (postfork))</div><div class="line">        loop_fork (EV_A);</div><div class="line"></div><div class="line">      <span class="comment">//检测fd</span></div><div class="line">      fd_reify (EV_A);</div><div class="line"></div><div class="line">      <span class="comment">/* 计算阻塞的时间 */</span></div><div class="line">      &#123;</div><div class="line">        ev_tstamp waittime  = <span class="number">0.</span>;</div><div class="line">        ev_tstamp sleeptime = <span class="number">0.</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* remember old timestamp for io_blocktime calculation */</span></div><div class="line">        ev_tstamp prev_mn_now = mn_now;</div><div class="line"></div><div class="line">        <span class="comment">/* update time to cancel out callback processing overhead */</span></div><div class="line">        time_update (EV_A_ <span class="number">1e100</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* from now on, we want a pipe-wake-up */</span></div><div class="line">        pipe_write_wanted = <span class="number">1</span>;</div><div class="line"></div><div class="line">        ECB_MEMORY_FENCE; <span class="comment">/* make sure pipe_write_wanted is visible before we check for potential skips */</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (expect_true (!(flags &amp; EVRUN_NOWAIT || idleall || !activecnt || pipe_write_skipped)))</div><div class="line">          &#123;</div><div class="line">            waittime = MAX_BLOCKTIME;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timercnt)</div><div class="line">              &#123;</div><div class="line">                ev_tstamp to = ANHE_at (timers [HEAP0]) - mn_now;</div><div class="line">                <span class="keyword">if</span> (waittime &gt; to) waittime = to;</div><div class="line">              &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PERIODIC_ENABLE</span></div><div class="line">            <span class="keyword">if</span> (periodiccnt)</div><div class="line">              &#123;</div><div class="line">                ev_tstamp to = ANHE_at (periodics [HEAP0]) - ev_rt_now;</div><div class="line">                <span class="keyword">if</span> (waittime &gt; to) waittime = to;</div><div class="line">              &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">            <span class="comment">/* don't let timeouts decrease the waittime below timeout_blocktime */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (waittime &lt; timeout_blocktime))</div><div class="line">              waittime = timeout_blocktime;</div><div class="line"></div><div class="line">            <span class="comment">/* at this point, we NEED to wait, so we have to ensure */</span></div><div class="line">            <span class="comment">/* to pass a minimum nonzero value to the backend */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (waittime &lt; backend_mintime))</div><div class="line">              waittime = backend_mintime;</div><div class="line"></div><div class="line">            <span class="comment">/* extra check because io_blocktime is commonly 0 */</span></div><div class="line">            <span class="keyword">if</span> (expect_false (io_blocktime))</div><div class="line">              &#123;</div><div class="line">                sleeptime = io_blocktime - (mn_now - prev_mn_now);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (sleeptime &gt; waittime - backend_mintime)</div><div class="line">                  sleeptime = waittime - backend_mintime;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (expect_true (sleeptime &gt; <span class="number">0.</span>))</div><div class="line">                  &#123;</div><div class="line">                    ev_sleep (sleeptime);</div><div class="line">                    waittime -= sleeptime;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">        ++loop_count;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        assert ((loop_done = EVBREAK_RECURSE, <span class="number">1</span>)); <span class="comment">/* assert for side effect */</span></div><div class="line">        backend_poll (EV_A_ waittime);</div><div class="line">        assert ((loop_done = EVBREAK_CANCEL, <span class="number">1</span>)); <span class="comment">/* assert for side effect */</span></div><div class="line"></div><div class="line">        pipe_write_wanted = <span class="number">0</span>; <span class="comment">/* just an optimisation, no fence needed */</span></div><div class="line"></div><div class="line">        ECB_MEMORY_FENCE_ACQUIRE;</div><div class="line">        <span class="keyword">if</span> (pipe_write_skipped)</div><div class="line">          &#123;</div><div class="line">            assert ((<span class="string">"libev: pipe_w not active, but pipe not written"</span>, ev_is_active (&amp;pipe_w)));</div><div class="line">            ev_feed_event (EV_A_ &amp;pipe_w, EV_CUSTOM);</div><div class="line">          &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* update ev_rt_now, do magic */</span></div><div class="line">        time_update (EV_A_ waittime + sleeptime);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* queue pending timers and reschedule them */</span></div><div class="line">      timers_reify (EV_A); <span class="comment">/* relative timers called last */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_PERIODIC_ENABLE</span></div><div class="line">      periodics_reify (EV_A); <span class="comment">/* absolute timers called first */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_IDLE_ENABLE</span></div><div class="line">      <span class="comment">/* queue idle watchers unless other events are pending */</span></div><div class="line">      idle_reify (EV_A);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_CHECK_ENABLE</span></div><div class="line">      <span class="comment">/* queue check watchers, to be executed first */</span></div><div class="line">      <span class="keyword">if</span> (expect_false (checkcnt))</div><div class="line">        queue_events (EV_A_ (W *)checks, checkcnt, EV_CHECK);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">      EV_INVOKE_PENDING;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">while</span> (expect_true (</div><div class="line">    activecnt</div><div class="line">    &amp;&amp; !loop_done</div><div class="line">    &amp;&amp; !(flags &amp; (EVRUN_ONCE | EVRUN_NOWAIT))</div><div class="line">  ));</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (loop_done == EVBREAK_ONE)</div><div class="line">    loop_done = EVBREAK_CANCEL;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> EV_FEATURE_API</span></div><div class="line">  --loop_depth;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> activecnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的流程：创建默认的事件循环，创建一个事件监测器和回调函数并初始化（init），将监测器放入事件循环（start）中，循环开始等待事件（run）的到来。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>libev源码阅读1：数据结构</title>
    <link href="http://abumaster.com/2017/07/31/libev%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://abumaster.com/2017/07/31/libev源码阅读1：数据结构/</id>
    <published>2017-07-31T02:08:24.000Z</published>
    <updated>2017-07-31T07:32:55.837Z</updated>
    
    <content type="html"><![CDATA[<p>libev 是一个高性能事件循环网络库，用于开发高性能网络应用。  </p>
<a id="more"></a>
<p><strong>1.基础宏定义</strong><br>libev中的监视器数据结构的实现是用宏定义以及结构体来实现继承关系，基本的宏定义，展开。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 所有的监视器共有的数据 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER(type)            \</div><div class="line">  int active; <span class="comment">/* private */</span>         \</div><div class="line">  int pending; <span class="comment">/* private */</span>            \</div><div class="line">  <span class="comment">//EV_DECL_PRIORITY /* private */        \</span></span></div><div class="line">  <span class="keyword">int</span> priority; \</div><div class="line">  <span class="comment">//EV_COMMON /* rw */                \</span></div><div class="line">  <span class="keyword">void</span> *data; \</div><div class="line">  <span class="comment">//EV_CB_DECLARE (type) /* private */</span></div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER_LIST(type)           \</div><div class="line">  EV_WATCHER (type)             \</div><div class="line">  struct ev_watcher_list *next; <span class="comment">/* private */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WATCHER_TIME(type)           \</div><div class="line">  EV_WATCHER (type)             \</div><div class="line">  ev_tstamp at;     <span class="comment">/* private */</span></span></div></pre></td></tr></table></figure></p>
<p><strong>2.监视器基类</strong><br>由上面的宏定义可以推断，libev的监视器的实现是从watcher，watcher_list和watcher_time三类中派生出去，分为这三个大类，三个基类。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本监视器 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">&#125; ev_watcher;</div><div class="line"><span class="comment">//监视器链表 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher_list</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="comment">//list的下一个节点</span></div><div class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</div><div class="line">&#125; ev_watcher_list;</div><div class="line"><span class="comment">//时间监视器 基类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_watcher_time</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="comment">//计时器时间</span></div><div class="line">  ev_tstamp at;</div><div class="line">&#125; ev_watcher_time;</div></pre></td></tr></table></figure></p>
<p><strong>3.监视的事件</strong><br>libev从三个监视器基类中派生出以下几种类，用于监视事件的变化，主要的分类和作用如下：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ev_io</code></td>
<td>IO 可读可写</td>
</tr>
<tr>
<td><code>ev_singnal</code></td>
<td>信号处理</td>
</tr>
<tr>
<td><code>ev_timer</code></td>
<td>定时器</td>
</tr>
<tr>
<td><code>ev_periodic</code></td>
<td>周期任务</td>
</tr>
<tr>
<td><code>ev_child</code></td>
<td>子进程状态变化</td>
</tr>
<tr>
<td><code>ev_fork</code></td>
<td>开辟子进程</td>
</tr>
<tr>
<td><code>ev_stat</code></td>
<td>文件属性变化</td>
</tr>
<tr>
<td><code>ev_async</code></td>
<td>激活线程</td>
</tr>
<tr>
<td><code>ev_cleanup</code></td>
<td>退出触发</td>
</tr>
<tr>
<td><code>ev_idle</code></td>
<td>空闲时执行</td>
</tr>
<tr>
<td><code>ev_embed</code></td>
<td>嵌入其他事件循环</td>
</tr>
<tr>
<td><code>ev_prepare</code></td>
<td>eventloop之前</td>
</tr>
<tr>
<td><code>ev_check</code></td>
<td>eventloop之后</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//io监视器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_io</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER_LIST (ev_io) //展开宏</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> fd;     <span class="comment">/* ro */</span></div><div class="line">  <span class="keyword">int</span> events; <span class="comment">/* ro */</span></div><div class="line">&#125; ev_io;</div><div class="line"><span class="comment">//定时器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_timer</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER_TIME (ev_timer) //展开</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line">  ev_tstamp at;</div><div class="line"></div><div class="line">  ev_tstamp repeat; <span class="comment">/* rw */</span></div><div class="line">&#125; ev_timer;</div><div class="line"><span class="comment">//空闲时触发</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ev_idle</div><div class="line">&#123;</div><div class="line">  <span class="comment">//EV_WATCHER (ev_idle) 展开</span></div><div class="line">  <span class="keyword">int</span> active;</div><div class="line">  <span class="keyword">int</span> pending;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">void</span> *data;</div><div class="line">  <span class="keyword">void</span> (*cb)(EV_P_ <span class="keyword">struct</span> type *w, <span class="keyword">int</span> revents);</div><div class="line"></div><div class="line">&#125; ev_idle;</div></pre></td></tr></table></figure>
<p>关系图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-31/44673487.jpg" alt=""><br>这种继承关系，可以用指针进行类型自由转换。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-31/72453924.jpg" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//激活监测器，不管是何类型</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_start</span> <span class="params">(<span class="keyword">struct</span> ev_loop *loop, ev_watcher* w, <span class="keyword">int</span> active)</span>  </div><div class="line"></span>&#123;  </div><div class="line">  <span class="comment">//...  </span></div><div class="line">  w-&gt;active = active;  </div><div class="line">  <span class="comment">//...  </span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">wlist_add</span> <span class="params">(ev_watcher_list **head, ev_watcher_list *elem)</span>  </div><div class="line"></span>&#123;  </div><div class="line">  elem-&gt;next = *head;  </div><div class="line">  *head = elem;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_io_start</span> <span class="params">(<span class="keyword">struct</span> ev_loop *loop, ev_io *w)</span>  </div><div class="line"></span>&#123;   </div><div class="line">  <span class="comment">//将ev_io退化为ev_watcher使用这个ev_start函数</span></div><div class="line">  ev_start (loop, (ev_watcher*)w, <span class="number">1</span>);  </div><div class="line">  <span class="comment">//转换成ev_watcher_list指针插入到list中</span></div><div class="line">  wlist_add (&amp;anfds[fd].head, (ev_watcher_list *)w);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.监视事件的初始化和设置</strong><br>ev的设置也被定义为宏macro，提供了两种方式：  </p>
<ul>
<li><code>ev_init</code> 和 <code>ev_TYPE_set</code> 一起使用；  </li>
<li>使用 <code>ev_TYPE_init</code> 进行初始化。  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_init(ev,cb_) do &#123;            \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;active  =   \</div><div class="line">  ((ev_watcher *)(void *)(ev))-&gt;pending = 0;    \</div><div class="line">  ev_set_priority ((ev), 0);            \</div><div class="line">  ev_set_cb ((ev), cb_);            \</div><div class="line">&#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_io_set(ev,fd_,events_)  \</div><div class="line"> do &#123; (ev)-&gt;fd = (fd_); (ev)-&gt;events = (events_) | EV__IOFDSET; &#125; while (0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_io_init(ev,cb,fd,events)   \</div><div class="line"> do &#123; ev_init ((ev), (cb)); \</div><div class="line">    ev_io_set ((ev),(fd),(events)); &#125; while (0)</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;libev 是一个高性能事件循环网络库，用于开发高性能网络应用。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="libev" scheme="http://abumaster.com/tags/libev/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析-容器</title>
    <link href="http://abumaster.com/2017/07/19/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8/"/>
    <id>http://abumaster.com/2017/07/19/STL源码剖析-容器/</id>
    <published>2017-07-19T07:04:58.000Z</published>
    <updated>2017-09-15T00:31:35.960Z</updated>
    
    <content type="html"><![CDATA[<h4 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h4><p><em>容器</em> 用于存放数据，数据在其中的排列具有一定的规律。STL中根据数据的排列方式将容器分为了 <strong>序列式容器</strong> 和 <strong>关联式容器</strong> 两种。其中的分类关系如下图所示：<br><a id="more"></a>
<img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/20670842.jpg" alt="">  </p>
<h4 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h4><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>vector连续线性空间存储，支持随机访问，类似数组。<br>vector的迭代器是一个T类型的原生指针；<br>vector的空间不是按需分配而是按照多分配的原则，比实际需要的空间要大，也就是说会保留一部分的备用空间用于插入元素，分别定义了三个迭代器指向了目前使用空间的头和尾，可用空间的尾。<code>start finish end_of_storage</code> 定义了函数 <code>size() 和 capacity</code> 分别表示使用空间的大小，以及最大容纳的大小；<br>vector的空间扩充，当没有足够的备用空间用于插入新的元素的时候，这时vecto需要进行空间的扩展，会申请一块原始大小二倍的新空间然后将旧的空间中的元素拷贝入新的空间，也就是说原始的迭代器在执行插入操作后会失效；<br>vector存在的缺点，就是可能浪费一部分空间。  </p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>list 在stl中的实现是一个双向链表，节点结构是有一个指向后一个节点和前一个节点的指针以及节点中的数据，每次插入和删除元素都要重新配置和释放节点，空间按需分配，插入操作不会改变迭代器。<br>list迭代器设计，内部依然是一个指针，指向了list的节点，内部定义了stl迭代器标准的接口，并实现了双向迭代器具有的操作，自增，自减，取值，比较等；<br>list数据结构，双向循环链表，一些操作就是链表的指针的移动；<br>一个内部函数<code>transfer(position, first, last)</code>将[first,last)内的元素移动到position之前。为splice、merge、sort提供基础。操作见图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/87239144.jpg" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (position != last) </div><div class="line">    &#123;</div><div class="line">        (*(link_type((*last.node).prev))).next = position.node; <span class="comment">// (1)</span></div><div class="line">        (*(link_type((*first.node).prev))).next = last.node; <span class="comment">// (2)</span></div><div class="line">        (*(link_type((*position.node).prev))).next = first.node; <span class="comment">// (3)</span></div><div class="line">        link_type tmp = link_type((*position.node).prev); <span class="comment">// (4)</span></div><div class="line">        (*position.node).prev = (*last.node).prev; <span class="comment">// (5)</span></div><div class="line">        (*last.node).prev = (*first.node).prev;  <span class="comment">// (6)</span></div><div class="line">        (*first.node).prev = tmp; <span class="comment">// (7)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>list 本身提供了排序的成员函数，不用stl算法（接受随机迭代器）。  </p>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>deque由一些列连续的空间组成，可以分别在头尾扩展插入。有一个中控器map指向连续的一段段的缓冲区。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-29/26926563.jpg" alt=""><br>deque的迭代器，包括了
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</div><div class="line">-----------------------------</div><div class="line">| cur | first | last | node |</div><div class="line">-----------------------------</div><div class="line">当前指向，缓冲区的开始和结束</div><div class="line">在map中的位置</div><div class="line">***/</span></div></pre></td></tr></table></figure></p>
<p>deque的数据结构，迭代器start指向第一个节点，finish指向最后一个节点，map指向中控器，是连续的空间，每个元素都是一个指针，指向了一个节点（缓冲区）。<br>在deque上进行元素操作时，考虑在中控器的移动。  </p>
<h5 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h5><p>stack先进后出，没有迭代器，queue先进先出，它们都是以deque为底部数据结构（默认），进行一定的限制保证它们各自的特性，不被称为容器，而是被称为配接器。  </p>
<h5 id="heap算法和优先级队列"><a href="#heap算法和优先级队列" class="headerlink" title="heap算法和优先级队列"></a>heap算法和优先级队列</h5><p>堆不是stl容器组件，但是却是优先级队列的底层实现。<br>它是一棵二叉树，根节点元素是最大或者最小元素，每次插入和取出根节点后都会重新排列保持它的这个特性。  </p>
<h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>主要有set集合和map映射表两种，底部以红黑二叉树实现。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;容器概述&quot;&gt;&lt;a href=&quot;#容器概述&quot; class=&quot;headerlink&quot; title=&quot;容器概述&quot;&gt;&lt;/a&gt;容器概述&lt;/h4&gt;&lt;p&gt;&lt;em&gt;容器&lt;/em&gt; 用于存放数据，数据在其中的排列具有一定的规律。STL中根据数据的排列方式将容器分为了 &lt;strong&gt;序列式容器&lt;/strong&gt; 和 &lt;strong&gt;关联式容器&lt;/strong&gt; 两种。其中的分类关系如下图所示：&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>像素反卷积网络</title>
    <link href="http://abumaster.com/2017/07/11/%E5%83%8F%E7%B4%A0%E5%8F%8D%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://abumaster.com/2017/07/11/像素反卷积网络/</id>
    <published>2017-07-11T07:30:10.000Z</published>
    <updated>2017-07-25T09:07:16.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Pixel Deconvolutional Networks Hongyang Gao etc. 2017.1.7 主要介绍了对于传统反卷积操作的新解读。读此论文，做如下笔记。  </p>
</blockquote>
<a id="more"></a>
<p><strong>1.引子</strong><br>反卷积层被广泛地应用在各种各样的深度模型中用于上采样，其中包括了用于语义分割的编码-解码网络、用于无监督学习的深度生成模型。反卷积层容易造成棋盘问题，使得输出的特征图的临近像素没有直接的关系。为了解决这个问题，提出了一种像素反卷积层，在输出特征图的临近像素之间建立一个直接的关系。是对反卷积操作的新的解读，因此可以取代任何的使用反卷积层的网络模型中的反卷积层。效率有所下降但是可以通过实现来解决。实验结果比较良好。  </p>
<p><strong>2.像素反卷积层</strong><br>新的层中的中间特征图是按照顺序生成，后面的特征图的生成依赖前面的。如此。<br>反卷积网络中的棋盘问题。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-24/77481511.jpg" alt=""><br>卷积层对输入特征图进行不同的卷积核卷积生成了中间特征图，然后上采样生成了输出特征图，其相邻的像素是没有直接联系的，因为是不同的卷积核操作生成的。<br>输入特征图Fin，输出特征图Fout，中间特征图的计算：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/57088763.jpg" alt=""><br>像素反卷积层，PixelDCL，改用了一种中间特征图的关联生成形式，生成了序列化的特征图，彼此依赖，如图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-24/26503601.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/92585659.jpg" alt=""><br>移除中间特征图和输入特征图之间的关联，因为，中间特征已经包含了输入特征图的信息，去掉不但可以提高计算效率，还能减小模型的参数。计算时只需第一个中间特征图依赖输入特征图，其他的中间特征图依赖前面计算过的特征图：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/42661592.jpg" alt=""><br><strong>分析（ 4*4 的输入特征图，上采样为 8*8 的特征图）：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/85425689.jpg" alt=""><br>第一步：2*2的卷积核对输入特征进行卷积操作生成第一个中间特征图，紫色的；<br>第二步：对第一个中间特征进行卷积操作生成第二个中间特征；<br>第三步：扩展和组合前两个特征图，生成8*8的特征图；<br>第四步：对此特征图进行marked卷积，卷积核大小改为3，保持8的大小；<br>第五步：组合两个大小为8的特征图，生成最终的大小为8的输出特征图。  </p>
<p><a href="https://github.com/divelab/PixelDCN">源码地址</a>  </p>
<p><strong>3.结果</strong><br>在图像语义分割上的结果：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-25/55128940.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Pixel Deconvolutional Networks Hongyang Gao etc. 2017.1.7 主要介绍了对于传统反卷积操作的新解读。读此论文，做如下笔记。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>使用深度学习技术的图像语义分割最新综述</title>
    <link href="http://abumaster.com/2017/07/10/%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9B%BE%E5%83%8F%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E6%9C%80%E6%96%B0%E7%BB%BC%E8%BF%B0/"/>
    <id>http://abumaster.com/2017/07/10/使用深度学习技术的图像语义分割最新综述/</id>
    <published>2017-07-10T08:32:14.000Z</published>
    <updated>2017-07-29T06:58:05.506Z</updated>
    
    <content type="html"><![CDATA[<p>A Review on Deep Learning Techniques Applied to Semantic Segmentation [A. Garcia-Garcia, S. Orts-Escolano, S.O. Oprea, V. Villena-Martinez, and J. Garcia-Rodriguez] 2017年4月22  </p>
<a id="more"></a>
<div class="note sucess"><p>文章的主要贡献：  </p>
<ul>
<li>对现有用于图像语义分割的数据集的研究；  </li>
<li>深度有组织地对使用深度学习的图像语义分割重要算法它们的起源和贡献进行回顾；  </li>
<li>对它们的性能进行粗略的评估；  </li>
<li>对上述结果进行讨论，并对未来的研究方向进行探讨。  </li>
</ul>
</div>
<h4 id="术语和背景概念"><a href="#术语和背景概念" class="headerlink" title="术语和背景概念"></a>术语和背景概念</h4><p>图像语义分割不是一个孤立的领域，而是一个从粗略到精细的自然的推理过程：预测输入图像中物体的类别，如果多类物体则预测多个类别；定位不同类别物体的位置；为图像中的每一个像素分类（图像语义分割）；对同一类物体的不同物体进行区分（实例分割）。  </p>
<p><strong>数据预处理和增强</strong> 对于小的数据集，可以相应作出改变来增大数据集，往往会带来更好的效果。比如1500张图像的数据集可以缩放成不同的尺度，进行不同的旋转，进行不同的伽马变换，生成大数据集。  </p>
<h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-10/64022244.jpg" alt=""><br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-10/39234174.jpg" alt="">  </p>
<p>当前，大多数优秀的深度学习技术用于图像语义分割都来自一个共同的先导者：全卷积网络（Long），这种方法的优势就是利用当前存在的CNNs作为有力的视觉模型，可以学习分层特征。通过改变一些著名的分类网络：改变最后的全连接层为全卷积层，输出特征图来取代分类得分。这些特征图（空域图）通过分数阶卷积（也被称为反卷积）来产生稠密像素级标记的输出图。反卷积网络的工作是一个里程碑式的工作，因为它展示了如何用CNNs训练端对端来解决视觉问题，是深度学习用于图像语义分割的基石。<br><strong>缺陷</strong>：缺少不同特征的感知，阻碍了在具体问题和场景中的应用。固有的空间不变性，使它不能将全局的上下文信息考虑进去，默认不能感知实例，在高分辨率上不能达到实时的处理速度，不能适应无结构的数据，例如3-D点云和模型。<br>对于它的种种缺陷，不同的方法提供不同的改善方向和效果，主要分为以下几个方向。  </p>
<h5 id="解码变种"><a href="#解码变种" class="headerlink" title="解码变种"></a>解码变种</h5><p>这是一种具有两个组件的网络，分别包含了编码器（卷积网络）和解码器（反卷积网络）。与普通的全卷积网络不同之处在于对低分辨率的特征图的处理，通过一个解码网络的东西。<br>SegNet，解码阶段是由一系列的上采样和卷积层组成的，上采样对应了编码过程的最大池化。上采样过的特征图通过一组可以训练的卷积核进行卷积生成了稠密特征图。经过解码后的图像与原始输入图像具有了相同的分辨率，然后经过一层softmax层分类器产生最终的分割图。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-26/13339329.jpg" alt="">  </p>
<h5 id="整合上下文信息"><a href="#整合上下文信息" class="headerlink" title="整合上下文信息"></a>整合上下文信息</h5><p><em>图像语义分割的一个问题就是需要整合不同空间尺度的信息</em>。这意味着局部信息和全局信息的平衡，一方面，细粒度或者局部信息对于获得良好的像素级预测精度是非常重要的，另一方面，整合全局上下文信息，可以解决分割图局部模糊性。传统的CNNs网络因为池化层的存在是不能感知全局信息的，有许多方法可以使CNNs感知全局信息，比如，使用条件随机场作为后续的处理，膨胀卷积，多尺度聚合，甚至将上下文模型推广到另一种深度网络中如RNNs。<br><strong>条件随机场</strong><br>解决上述的问题，一种可能的方法优化输出图，提高捕捉细节的能力，是用条件随机场作为后期处理。条件随机场（CRF）可以组合低层次的像素级别的信息，这些是CNN无法做到的，其中DeepLab应用了全连接的条件随机场作为分割图的后续处理，像素作为图的节点，建立全连接充分考虑了短程和远程的连接。另一个CRFasRNN，将条件随机场作为网络的一部分进行端对端的训练。  </p>
<blockquote>
<p>[1] Semantic image segmentation with deep convolutional nets and fully connected crfs<br>[2] Conditional random fields as recurrent neural networks</p>
</blockquote>
<p><strong>膨胀卷积</strong><br>也叫阿托斯卷积，通过增大卷积核的步伐来进行卷积操作，获得更宽的接受域。<br><strong>多尺度聚合</strong><br>首先[1]提出了将全卷积网络分为两个路径，图像分为原图和二倍图，分别放入浅层网络和全卷积网络，将全卷积网络的输出上采样结合浅层输出经过一系列的卷积的到最终的输出图。对尺度感知非常敏感？<br>[2]用了不同的思路，四个相同的网络，感知由粗糙到精细的尺度信息，如图，序列进行处理得到最终的输出。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/17-7-26/27217990.jpg" alt=""><br>[4]提出了n个全卷积网络的结构，分别对应处理不同的尺度，分为两个阶段学习：第一个分别独立训练，第二融合各网络的输出，得到最终的输出图。  </p>
<blockquote>
<p>[1] Multi-scale convolutional architecture for semantic segmentation<br>[2] A multi-scale cnn for affordance segmentation in rgb images<br>[3] Predicting depth, surface normals and semantic labels with a common multi-scale convolutional architecture<br>[4] Multiscale fully convolutional network with application to industrial inspection  </p>
</blockquote>
<p><strong>特征融合</strong><br>提取不同层的特征，包含了不同的局部上下文信息，将之融合。<br><strong>递归神经网络</strong>  </p>
<h5 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h5><p>实例分割是语义分割之后的一步，同时也是与其他低级像素分割技术相比最具有挑战性的问题。主要是将同类物品的不同实例区别开。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A Review on Deep Learning Techniques Applied to Semantic Segmentation [A. Garcia-Garcia, S. Orts-Escolano, S.O. Oprea, V. Villena-Martinez, and J. Garcia-Rodriguez] 2017年4月22  &lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="计算机视觉" scheme="http://abumaster.com/tags/computerversion/"/>
    
  </entry>
  
  <entry>
    <title>多线程库c++11</title>
    <link href="http://abumaster.com/2017/07/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%93c-11/"/>
    <id>http://abumaster.com/2017/07/09/多线程库c-11/</id>
    <published>2017-07-09T10:32:25.000Z</published>
    <updated>2017-07-10T13:48:30.784Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11 标准中的多线程库，包含了封装的thread类以及用于同步的mutex、atomic和条件变量。<br><a id="more"></a></p>
<h4 id="thread类"><a href="#thread类" class="headerlink" title="thread类"></a>thread类</h4><p>使用包含头文件<thread>，std::thread。<br><strong>构造函数</strong><br>常用的构造函数：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn, <span class="keyword">class</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span> <span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了线程执行函数，第二个可选的线程函数所需的参数。<br>为了控制线程同步，可以设置原子变量atomic类型的全局变量；或者传入一个原子变量参数的引用；或者使用一个成员变量。<a href="http://www.cplusplus.com/reference/thread/thread/thread/">例子</a>，参见cplusplus网站。<br>赋值运算符，可以直接移动分配，不拷贝。<br><strong>等待和独立运行</strong><br>创建线程后可以调用<code>join</code>来阻塞等待线程的结束，同样也提供了一个函数<code>joinable</code>来测试线程是否可以被join，如果想让线程独立于主线程后台运行可以调用<code>detach</code>，使线程分离出去在后台运行，这是测试能否被join则返回的是false，同样主线程也不能调用join来等待线程的结束。<br><strong>this_thread 类</strong><br>表示当前进程，提供了一组函数。  </p>
<ul>
<li><code>get_id</code> 返回一个<code>thread::id</code>类型，标识了当前线程的id。  </li>
<li><code>yield</code> 让步，为其他线程提供调用的机会。  </li>
<li><code>sleep_until</code> 阻塞直到设置的时间到了，绝对的时间。  </li>
<li><code>sleep_for</code> 阻塞到指定的时间，相对时间。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 11 标准中的多线程库，包含了封装的thread类以及用于同步的mutex、atomic和条件变量。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
</feed>
