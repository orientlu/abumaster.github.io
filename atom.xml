<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张国丰</title>
  <subtitle>张国丰的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abumaster.com/"/>
  <updated>2018-07-01T13:48:17.807Z</updated>
  <id>http://abumaster.com/</id>
  
  <author>
    <name>abumaster</name>
    <email>1902819397@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安装 Ubuntu server 版本</title>
    <link href="http://abumaster.com/2018/06/26/%E5%AE%89%E8%A3%85Ubuntu-server%E7%89%88%E6%9C%AC/"/>
    <id>http://abumaster.com/2018/06/26/安装Ubuntu-server版本/</id>
    <published>2018-06-26T13:17:45.000Z</published>
    <updated>2018-07-01T13:48:17.807Z</updated>
    
    <content type="html"><![CDATA[<p>从同学那里得到了一个免费的显卡坏掉的戴尔笔记本，所以装一个 Ubuntu server 玩一下。安装 Ubuntu server 版本与安装桌面版的有一些不同，同样在物理机上安装与在虚拟机中安装也不同，记录一些在安装过程中出现的问题。</p>
<a id="more"></a>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><p>1.从 <a href="https://www.ubuntu.com/download/alternative-downloads">Ubuntu 官网</a> 上下载对应的服务器版本。<br>2.制作U盘启动器，用 UltraISO 将ISO刻录到U盘中，作为启动盘。<br>3.开机boot用U盘启动。<br>4.一路选择安装。  </p>
<p><strong>事情当然不会这么容易了，安装过程中出现了很多问题。</strong>  </p>
<h1 id="问题出现和解决"><a href="#问题出现和解决" class="headerlink" title="问题出现和解决"></a>问题出现和解决</h1><h2 id="光盘无法读取"><a href="#光盘无法读取" class="headerlink" title="光盘无法读取"></a>光盘无法读取</h2><p>安装过程出现 CD-ROM 读取失败，这种情况。首先，我们制作好了 U盘启动盘，也要把Ubuntu的iso镜像拷贝到U盘的根目录下。然后，再一次重新开始安装。出现错误，退出打开命令行工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ls /dev/sd* #显示出所有的硬件设备，一般u盘就是dev/sdb 那么u盘上的分区就是dev/sdb1</div><div class="line">#创建一个空目录，将U盘分区挂载到这个空目录上</div><div class="line">mkdir ubt</div><div class="line">mount /dev/sdb1 /ubt</div><div class="line"># 然后将其中的Ubuntu ISO镜像挂载到cdrom上</div><div class="line">mount /ubt/ubuntu-xxx.iso /cdrom</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<h2 id="无线网络设置"><a href="#无线网络设置" class="headerlink" title="无线网络设置"></a>无线网络设置</h2><p>使用到的工具 <code>wpasupplicant</code> ，一般高版本的Linux集成了这个工具。<br>生成无线路由密钥。这一步就是根据你无线网络的SSID和密码，来生成WLAN需要的配置文件。命令如下：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#wpa_passphrase 无线网络SSID 无线网络密码 &gt; 配置文件名</span></div><div class="line"><span class="comment">#wpa_passphraseTP-LINK 123456 &gt; /etc/wpa_config.conf</span></div></pre></td></tr></table></figure></p>
<p>设置无线网络。编辑 <code>/etc/network/interfaces</code> 文件，将wlan添加到其中：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto wlan0</div><div class="line">iface wlan0 inet dhcp</div><div class="line">wpa-conf /etc/wpa_config.conf</div></pre></td></tr></table></figure></p>
<p>一般人的都是<code>eth0</code>，和<code>wlan0</code>，但在Ubuntu Server 16.04里面变成了<code>enp4s0</code> 和 <code>wlp5s0</code>，所以还需要查看网卡的名称，有时 <code>wlan0</code>这个名称是不对的，所以使用 <code>ip addr</code> 查看网卡的名称，进行替换。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从同学那里得到了一个免费的显卡坏掉的戴尔笔记本，所以装一个 Ubuntu server 玩一下。安装 Ubuntu server 版本与安装桌面版的有一些不同，同样在物理机上安装与在虚拟机中安装也不同，记录一些在安装过程中出现的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="Linux" scheme="http://abumaster.com/tags/linux/"/>
    
      <category term="其他" scheme="http://abumaster.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行练习</title>
    <link href="http://abumaster.com/2018/06/15/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%83%E4%B9%A0/"/>
    <id>http://abumaster.com/2018/06/15/Linux命令行练习/</id>
    <published>2018-06-15T08:29:33.000Z</published>
    <updated>2018-06-26T14:59:59.065Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下命令行练习，旨在熟悉Linux下的命令，以及常用的工具。题目来源一个好玩的网站，<a href="https://cmdchallenge.com/">cmdchallenge</a>，以挑战的形式对各种命令进行练习。  </p>
<a id="more"></a>
<h1 id="主要界面"><a href="#主要界面" class="headerlink" title="主要界面"></a>主要界面</h1><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-15/99270386.jpg" alt=""><br>当在题目下，输入正确的命令，并得出正确的结果时，会进入下一条命令，根据要求，用相关的命令，得到符合要求的结果。  </p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p><strong>grep</strong> 是一个全面按照正则表达式，搜索匹配文本的工具，把匹配的行打印出来。<br>使用：<code>grep [opetion]... pattern [FILE]...</code>，options如下：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 上下文显示控制：</span></div><div class="line">-A &lt;显示行数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</div><div class="line">-B &lt;显示的行数&gt; 除了显示符合要求的样式那一行外，并显示该行之前的内容。</div><div class="line">-C &lt;显示上下文行数&gt;  除了显示符合范本样式的那一列之外，并显示该行之前后的几行内容。</div><div class="line">--color 用颜色标记符合条件的匹配项</div><div class="line"></div><div class="line"><span class="comment"># 输出控制：</span></div><div class="line">-c 输出匹配的行数。</div><div class="line">-m &lt;NUM&gt; 输出匹配的NUM个结果。</div><div class="line">-b 在结果前加上，匹配项所在的字符偏移量。</div><div class="line">-n 在输出结果上加上行号。</div><div class="line">-H 输出结果前面加上文件名。</div><div class="line">-h 不输出文件名。</div><div class="line">-o 只输出完全匹配的内容。</div><div class="line"><span class="_">-a</span> 将二进制文件当做文本文件处理。</div><div class="line">-I 忽略二进制文件。</div><div class="line"><span class="_">-d</span>, --directories=ACTION  how to handle directories;ACTION is <span class="string">'read'</span>, <span class="string">'recurse'</span>, or <span class="string">'skip'</span></div><div class="line">-r -R 递归文件夹。</div><div class="line">-L 输出不匹配的文件名。</div><div class="line"><span class="_">-l</span> 只输出包含匹配的文件名。</div><div class="line">-q 不显示任何信息。</div><div class="line">-Z 输出的文件名后加上 0 bytes。</div><div class="line"></div><div class="line"><span class="comment"># 正则表达式</span></div><div class="line"><span class="_">-e</span>&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。</div><div class="line">-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</div><div class="line"><span class="_">-f</span>&lt;范本文件&gt; 从文件中获得匹配样式，其中每一行为一个样式</div><div class="line">-F 将范本样式视为固定字符串的列表。</div><div class="line">-G 将范本样式视为普通的表示法来使用。</div><div class="line">-i 忽略字符大小写的差别。</div><div class="line">-v 反转查找。</div><div class="line">-w 只显示全字符合的匹配项。</div><div class="line">-x 只显示全行符合的匹配项。</div></pre></td></tr></table></figure></p>
<p><strong>举个栗子：</strong><br>Windows 下使用 <code>tasklist</code> 命令，将进程信息保存到一个文件中，以此来测试 <code>grep</code> 的各个命令。<br><strong>1.简单的输出上下文相关的行</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/44782426.jpg" alt=""><br><strong>2.输出控制</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/41090895.jpg" alt=""><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#   -m5   表示输出匹配结果的5行</span></div><div class="line"><span class="comment">#   -b    表示输出匹配结果的偏移量</span></div><div class="line"><span class="comment">#   -n    输出匹配结果所在的行号</span></div><div class="line"><span class="comment">#   -H    输出结果前加上文件名</span></div><div class="line"><span class="comment">#   -o    输出完全匹配的信息，而不是整行内容</span></div><div class="line"><span class="comment">#   -a    将二进制文件当做文本来处理</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/96928073.jpg" alt=""><br>正则表达式的应用。正则表达式的基本标识符。  </p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$</code></td>
<td>匹配输入字符结束的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td>匹配单个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[</code></td>
<td>标识一个中括号表达式的开始</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td>匹配前面的字表达式零次或一次</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td>转义字符，如果要匹配有特殊含义的字符，需要加上进行转义</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td>匹配输入字符的开始位置，当出现在中括号中时，则表示不接受任何表达式</td>
</tr>
<tr>
<td style="text-align:center"><code>{</code></td>
<td>标记限定表达式的开始</td>
</tr>
<tr>
<td style="text-align:center"><code>这是竖线</code></td>
<td>指定在两项之中进行一个选择</td>
</tr>
<tr>
<td style="text-align:center"><code>\&lt;</code></td>
<td>表示词首</td>
</tr>
<tr>
<td style="text-align:center"><code>\&gt;</code></td>
<td>表示词尾</td>
</tr>
</tbody>
</table>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><strong>1.extract_ip_address</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Extract all IP addresses from files</span></div><div class="line"><span class="comment"># that start with "access.log" printing one</span></div><div class="line"><span class="comment"># IP address per line.</span></div><div class="line">grep -r -o ^[0-9.]*</div></pre></td></tr></table></figure></p>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p><strong>sed</strong> 是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。<br><strong>sed 命令格式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed [options] &apos;command&apos; file(s)</div><div class="line">sed [options] -f scripfile file(s)</div></pre></td></tr></table></figure></p>
<p><strong>sed 的选项</strong>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="_">-e</span> &lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的script来处理输入的文本文件；</div><div class="line"><span class="_">-f</span> &lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script文件来处理输入的文本文件；</div><div class="line">-h 或 --help：显示帮助；</div><div class="line">-n 或 --quiet或--silent：仅显示script处理后的结果；</div><div class="line">-V 或--version：显示版本信息；</div><div class="line">-b 二进制模式打开文件；</div><div class="line">-E 或 -r 在脚本中使用扩展的正则表达式</div><div class="line">-u 或 --unbuffered </div><div class="line">-i 在原文件中编辑</div></pre></td></tr></table></figure></p>
<p><strong>sed 命令：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">a\  在当前行下面插入文本</div><div class="line">i\  在当前行上面插入文本</div><div class="line">c\  把选定的行改为新的文本</div><div class="line"></div><div class="line">d   删除，删除选择的行</div><div class="line">D   删除模块的第一行</div><div class="line">s   替换指定的字符</div><div class="line">h   拷贝模板块的内容到内存中的缓冲区。</div><div class="line">H   追加模板块的内容到内存中的缓冲区。</div><div class="line">g   替换一行中的所有匹配到的内容。</div><div class="line">G   获得内存缓冲区的内容，并追加到当前模板块文本的后面。</div><div class="line">l   列表不能打印字符的清单。</div><div class="line">n   读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</div><div class="line">N   追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。</div><div class="line">p   打印模板块的行。</div><div class="line">P   打印模板块的第一行。</div><div class="line">q   退出Sed。</div><div class="line">b   lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。</div><div class="line">r   file 从file中读行。</div><div class="line">t   label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</div><div class="line">T   label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</div><div class="line">w   file 写并追加模板块到file末尾。  </div><div class="line">W   file 写并追加模板块的第一行到file末尾。  </div><div class="line">!   表示后面的命令对所有没有被选定的行发生作用。  </div><div class="line">=   打印当前行号码。  </div><div class="line">#   把注释扩展到下一个换行符以前。</div></pre></td></tr></table></figure></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>1.替换文本中的字符串</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/hello/world/'</span> file</div><div class="line"><span class="comment"># 显示发生更改的行</span></div><div class="line">sed -n <span class="string">'s/test/TEST/p'</span> file</div><div class="line"><span class="comment"># 在源文件中更改 /g对符合条件全部替换</span></div><div class="line">sed -i <span class="string">'s/hello/world/g'</span> file</div><div class="line"><span class="comment"># 从第N处匹配开始替换使用 /Ng</span></div><div class="line"><span class="built_in">echo</span> hhhhhhhh | sed <span class="string">'s/h/H/3g'</span> <span class="comment"># 从第三个h开始替换</span></div></pre></td></tr></table></figure></p>
<p><strong>2.删除文本中信息</strong>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 删除空白行</span></div><div class="line">sed <span class="string">'/^$/d'</span> file</div><div class="line"><span class="comment"># 删除文件的第二行</span></div><div class="line">sed <span class="string">'2d'</span> file</div><div class="line"><span class="comment"># 删除文件第二行到末尾</span></div><div class="line">sed <span class="string">'2,$d'</span> file</div><div class="line"><span class="comment"># 删除文件最后一行</span></div><div class="line">sed <span class="string">'$d'</span> file</div><div class="line"><span class="comment"># 删除所有 test开头的行</span></div><div class="line">sed <span class="string">'/^test/d'</span> file</div></pre></td></tr></table></figure></p>
<h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>用于显示指定文件中末尾的几行内容，如果表示字符或行数的N数值之后有<code>+</code>时，则表示从N行开始，到文件尾。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-c [+]NUM 输出结尾的NUM个字节数，+NUM 表示输出从NUM字节开始到文件尾的信息，可以在其后加上单位，如k，kB，K，MB；</div><div class="line">-n [+]NUM 输出最后NUM行的信息，+NUM 表示从NUM行开始到结尾的数据输出；</div><div class="line">-v 显示文件头信息</div><div class="line">-q 不显示文件头信息</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/93310029.jpg" alt="">  </p>
<h1 id="head"><a href="#head" class="headerlink" title="head"></a>head</h1><p>用于显示给定文件的前几行，默认10行，用途与<code>tail</code>正好相反，用管道结合起来可以显示文件中间的几行。用法<code>head 选项 参数</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-n&lt;数字&gt;：指定显示头部内容的行数；</div><div class="line">-c&lt;字符数&gt;：指定显示头部内容的字符数；</div><div class="line">-v：总是显示文件名的头信息；</div><div class="line">-q：不显示文件名的头信息。</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/49603155.jpg" alt="">  </p>
<p>结合<code>tail</code>显示中间的文件<code>cat file1.md | tail -n +10 | head 10</code>，输出10行开始到19行结束。</p>
<h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1><p>字符字节统计命令，利用wc指令我们可以计算文件的Byte数、字数或是列数。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-c或--bytes或——chars：只显示Bytes数；</div><div class="line">-m 统计字符数目</div><div class="line"><span class="_">-l</span> lines：只显示列数；</div><div class="line">-w words：只显示字数。</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-17/72464158.jpg" alt="">  </p>
<h1 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h1><p><code>tr</code> 命令，对来自标准输入的字符进行替换、删除和压缩处理，将一组字符变成另一组字符。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-c或--complerment：取代所有不属于第一字符集的字符；</div><div class="line"><span class="_">-d</span>或--delete：删除所有属于第一字符集的字符；</div><div class="line"><span class="_">-s</span>或--squeeze-repeats：把连续重复的字符以单独一个字符表示；</div><div class="line">-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。</div><div class="line"><span class="comment"># 字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</span></div><div class="line"><span class="comment"># 字符集2：指定要转换成的目标字符集。</span></div></pre></td></tr></table></figure></p>
<p><strong>tr 可以使用的字符类：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[:alnum:]：字母和数字</div><div class="line">[:alpha:]：字母</div><div class="line">[:cntrl:]：控制（非打印）字符</div><div class="line">[:digit:]：数字</div><div class="line">[:graph:]：图形字符</div><div class="line">[:lower:]：小写字母</div><div class="line">[:<span class="built_in">print</span>:]：可打印字符</div><div class="line">[:punct:]：标点符号</div><div class="line">[:space:]：空白字符</div><div class="line">[:upper:]：大写字母</div><div class="line">[:xdigit:]：十六进制字符</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-18/90763520.jpg" alt="">  </p>
<h1 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h1><blockquote>
<p>用来输出某一个数到另一个数之间的所有整数序列</p>
</blockquote>
<p>主要参数：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用法</span></div><div class="line">seq [选项]... 尾数</div><div class="line">seq [选项]... 首数 尾数</div><div class="line">seq [选项]... 首数 增量 尾数</div><div class="line"></div><div class="line"><span class="comment"># 选项</span></div><div class="line"><span class="_">-f</span>, --format=格式        使用<span class="built_in">printf</span> 样式的浮点格式</div><div class="line"><span class="_">-s</span>, --separator=字符串   使用指定字符串分隔数字（默认使用：\n）</div><div class="line">-w, --equal-width        在列前添加0 使得宽度相同 不能和<span class="_">-f</span>同时使用</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-18/9882993.jpg" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 下命令行练习，旨在熟悉Linux下的命令，以及常用的工具。题目来源一个好玩的网站，&lt;a href=&quot;https://cmdchallenge.com/&quot;&gt;cmdchallenge&lt;/a&gt;，以挑战的形式对各种命令进行练习。  &lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://abumaster.com/categories/linux/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="cmd" scheme="http://abumaster.com/tags/cmd/"/>
    
      <category term="linux" scheme="http://abumaster.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>工具集</title>
    <link href="http://abumaster.com/2018/06/13/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <id>http://abumaster.com/2018/06/13/工具集/</id>
    <published>2018-06-13T12:57:58.000Z</published>
    <updated>2018-06-13T13:38:20.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>提高效率工具集汇总，备忘，装机必备。</p>
</blockquote>
<a id="more"></a>
<h3 id="Windows-高效工具集合"><a href="#Windows-高效工具集合" class="headerlink" title="Windows 高效工具集合"></a>Windows 高效工具集合</h3><h4 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h4><p><strong>C++</strong>：  </p>
<ul>
<li>宇宙最强IDE <strong>visual studio 2015</strong>，<a href="https://msdn.itellyou.cn/">下载</a>，专业版的密钥<code>HMGNV-WCYXV-X7G9W-YCX63-B98R2</code>，网上可以随处找到。 </li>
<li>开源跨平台 Qt ，<a href="http://download.qt.io/archive/qt/">下载列表</a>，可以选择 <em>MinGW</em> 或者 <em>vc</em> 作为编译器。</li>
<li>gVim sublime txt 3 with MinGW <a href="https://keelii.github.io/2016/06/13/awsome-window-vimrc/">配置好看的界面</a>。</li>
<li>文本编辑器  <ul>
<li><a href="http://www.sublimetextcn.com/3/">sublimetext3</a>  </li>
<li><a href="https://code.visualstudio.com/">vscode</a> </li>
<li><a href="https://ivarptr.github.io/yu-writer.site/">yuwrite</a></li>
</ul>
</li>
<li>Windows C++开发依赖工具包管理 <a href="https://github.com/Microsoft/vcpkg">vcpkg.exe</a></li>
<li>帮助文档  <a href="https://zealdocs.org/">Zeal</a></li>
</ul>
<p><strong>Python</strong>：  </p>
<ul>
<li>Python 工具包 <a href="https://repo.continuum.io/archive/">Anaconda3</a></li>
<li>IDE JetBrains PyCharm 太卡了，改用 vscode 或者 sublime text3 配置Python开发环境。</li>
</ul>
<p><strong>JavaScript相关</strong>：  </p>
<ul>
<li><a href="https://nodejs.org/zh-cn/">node.js</a> Windows版</li>
<li>好玩的前端框架:<ul>
<li><a href="&quot;https://alibaba.github.io/ice&quot;">ICE</a></li>
<li>react</li>
</ul>
</li>
</ul>
<p><strong>版本控制</strong>：</p>
<ul>
<li>git cmd </li>
<li>github Windows版</li>
<li>好用的终端 cmder</li>
</ul>
<p><strong>数据库</strong>：</p>
<ul>
<li>MySQL Redis MongoDB sqlite</li>
<li>数据库可视化 Navicat</li>
</ul>
<h4 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h4><p><strong>文档处理</strong>：</p>
<ul>
<li>office 2015</li>
<li>Visio 2015</li>
<li>极速PDF阅读器</li>
<li>officebox 万彩办公</li>
<li>Endnote 文献管理</li>
<li>iSlide PPT插件</li>
</ul>
<p><strong>小工具</strong>: </p>
<ul>
<li>快速启动小工具 launchy 和 cerebro</li>
<li>快速截图工具 Snipaster</li>
</ul>
<p><strong>下载</strong>: </p>
<ul>
<li>FDM</li>
</ul>
<h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h4><ul>
<li>搬瓦工 购买国外服务器，并且创建sserver</li>
<li>Shadowsocks 登录sserver</li>
<li>Chrome 好用插件集合</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提高效率工具集汇总，备忘，装机必备。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="http://abumaster.com/categories/other/"/>
    
    
      <category term="工具" scheme="http://abumaster.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="效率" scheme="http://abumaster.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Feature Pyramid Networks for Object Detection</title>
    <link href="http://abumaster.com/2018/06/09/Detection/"/>
    <id>http://abumaster.com/2018/06/09/Detection/</id>
    <published>2018-06-09T01:26:26.000Z</published>
    <updated>2018-06-09T12:41:09.826Z</updated>
    
    <content type="html"><![CDATA[<p>用于物体检测的特征金字塔网络，由 FAIR 发表。特征金字塔是识别系统中检测不同尺度大小目标的基础组件，最近的基于深度学习的物体监测器中，避免使用金字塔表示，一个原因是对内存和计算敏感。本文使用固有的多尺度和金字塔形的卷积网络，构建特征金字塔，尽可能减少了额外的代价。一个自顶向下的有侧边连接的网络模型，用于为各个尺度构建高层次语义特征图。作为一个模块嵌入到其他物体检测模型中，有着很好的实验结果，为多尺度物体检测提供了一种解决方案。<br><a id="more"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>多尺度物体的检测是计算机视觉任务中一个基本的挑战。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-9/27376237.jpg" alt="几种方式对比">  </p>
<ul>
<li>第一种，将原始图像缩放为不同的尺度，分别提取出特征图，进行预测；</li>
<li>第二种，单一的图像放入网络中，输出预测结果；</li>
<li>第三种，单张图像放入网络中，对不同层次，预测；</li>
<li>第四种，从不同层次中提取出特征图，构建成金字塔型的特征图，并预测。</li>
</ul>
<h1 id="特征金字塔网络"><a href="#特征金字塔网络" class="headerlink" title="特征金字塔网络"></a>特征金字塔网络</h1><p>本文提出了一种结构 <strong>Feature Pyramid Network（FPN）</strong> ，如下：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-6-9/69223848.jpg" alt="网络结构">  </p>
<ul>
<li><strong>Bottom-up pathway</strong>，自下而上的路径，与传统的卷积网络类似，分层次获得图像特征组合，特征图逐层缩小，而特征图的数量在增加，每一个层次被称为一个阶段，同时也是一个金字塔层次级别。  </li>
<li><strong>Top-down pathway and lateral connections</strong>，自顶下下的路径，通过上采样获得更大的分辨率特征图，很粗糙，但是从高层金字塔层次获得的语义更强。通过横向连接去优化这个分割图，横向连接将两条路径上，大小相同的特征图连接，自底向上的特征图包含了低层次的语义。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用于物体检测的特征金字塔网络，由 FAIR 发表。特征金字塔是识别系统中检测不同尺度大小目标的基础组件，最近的基于深度学习的物体监测器中，避免使用金字塔表示，一个原因是对内存和计算敏感。本文使用固有的多尺度和金字塔形的卷积网络，构建特征金字塔，尽可能减少了额外的代价。一个自顶向下的有侧边连接的网络模型，用于为各个尺度构建高层次语义特征图。作为一个模块嵌入到其他物体检测模型中，有着很好的实验结果，为多尺度物体检测提供了一种解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
      <category term="论文" scheme="http://abumaster.com/tags/lunwen/"/>
    
      <category term="CV" scheme="http://abumaster.com/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>优秀架构师必须掌握的架构思维（转）</title>
    <link href="http://abumaster.com/2018/05/25/%E4%BC%98%E7%A7%80%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://abumaster.com/2018/05/25/优秀架构师必须掌握的架构思维（转）/</id>
    <published>2018-05-25T09:02:05.000Z</published>
    <updated>2018-05-25T11:41:11.142Z</updated>
    
    <content type="html"><![CDATA[<p>架构的本质是管理复杂性，<strong>抽象</strong>、<strong>分层</strong>、<strong>分治</strong> 和 <strong>演化</strong> 思维是我们工程师/架构师应对和管理复杂性的四种最基本武器。<a href="http://www.infoq.com/cn/articles/architecture-thought?utm_source=tuicool&amp;utm_medium=referral">原文地址</a>。</p>
<a id="more"></a>
<h4 id="抽象思维"><a href="#抽象思维" class="headerlink" title="抽象思维"></a>抽象思维</h4><p><strong>对某种事物进行简化描述或表示的过程，只关注要素而忽略具体的细节</strong>。<br>在系统架构和设计中，抽象帮助我们从大处着眼（get our mind about big picture），隐藏细节（temporarily hide details）。抽象能力的强弱，直接决定我们所能解决问题的复杂性和规模大小。<br>关于抽象层次的跳跃性，开发过程应该保证代码的抽象层次一致性，保证代码清晰明了。如在电商处理订单过程中，需要的流程如下：  </p>
<ul>
<li>更新库存信息；  </li>
<li>打折计算；  </li>
<li>支付卡校验；  </li>
<li>支付；  </li>
<li>送货。<br>上述流程处于同一个抽象层次上，在编写代码的时候，不应该出现一些细节性的问题，如在支付卡校验过程中，出现调用某一银行卡的支付api，这是不正确的，应该调用一个抽象的支付api，而不是细节。  </li>
</ul>
<h4 id="分层思维"><a href="#分层思维" class="headerlink" title="分层思维"></a>分层思维</h4><p>分层抽象，系统分为若干层次化的模块，每一个层次负责解决一个问题，下层向上层提供服务，一些层次贯穿所有层，被称为共享层。常见的分层模式有TCP/IP协议，操作系统等。  </p>
<h4 id="分治思维"><a href="#分治思维" class="headerlink" title="分治思维"></a>分治思维</h4><p>分而治之也是一种应对和管理复杂性的一般性方法，一次无法解决的大问题，划分成多个子问题，然后将子问题划分为更小的子问题，直到分解成可解的小问题集合，将这些解组合拼接成子问题的解，在以次拼成原问题的解。<br>面试时为了考察候选人的分治思维，我经常会面一个分治题：给你一台8G内存/500G磁盘空间的普通电脑，如何对一个100G的大文件进行排序？假定文件中都是字符串记录，一行约100个字符。<br>这是一个典型的分治问题，100G的大文件肯定无法一次加载到内存直接排序，所以需要先切分成若干小问题来解决。那么8G内存的计算机一次大概能排多大的数据量，可以在有限的时间内排完呢？也就是100G的大文件要怎么切法，切成多少份比较合适？这个是考察候选人的时间空间复杂度估算能力，需要一定的计算机组织和算法功底，也需要一定实战经验和sense。实际上8G内存的话，操作系统要用掉一部分，如果用Java开发排序程序，大致JVM可用2~4G内存，基于一般的经验值，一次排1G左右的数据应该没有问题（我实际在计算机上干过1G数据的排序，是OK的）。所以100G的文件需要先切分成100份，每份1G，这样每个子文件可以直接加载到内存进行排序。对于1G数据量的字符串排序，采用Java里头提供的快速排序算法是比较合适的。<br>好，经过有限时间的排序（取决于计算机性能，快的一天内能排完），假定100个1G的文件都已经排好了，相当于现在硬盘上有100个已经排好序的文件，但是我们最终需要的是一个排好序的文件，下面该怎么做？这个时候我们需要把已经解决的子问题组合起来，合并成我们需要的最终结果文件。这个时候该采用什么算法呢？这里考察候选人对外排序和归并排序算法的掌握程度，我们可以将100个排好序的文件进行两两归并排序，这样不断重复，我们就会得到50个排好序的文件，每个大小是2G。然后再两两归并，不断重复，直到最后两个文件归并成目标文件，这个文件就是100G并且是排好序的。因为是外排序+归并排序，每次只需要读取当前索引指向的文件记录到内存，进行比较，小的那个输出到目标文件，内存占用极少。另外，上面的算法是两路归并，也可以采用多路归并，甚至是采用堆排序进行优化，但是总体分治思路没有变化。<br>总体上这是一个非常好的面试题，除了考察候选人的分治思维之外，还考察对各种排序算法（快排，外排序，归并排序，堆排序）的理解，计算的时间空间复杂度估算，计算机的内外存特性和组织，文件操作等等。实际上能完全回答清楚这个问题的候选人极少，如果有幸被我面到一个，我会如获至宝，因为这个人有成长为优秀架构师的潜质。<br>另外，递归也是一种特殊的分治技术，掌握递归技术的开发人员，相当于掌握了一种强大的编程武器，可以解决一些一般开发人员无法解决的问题。比方说最近我的团队在研发一款新的服务框架，其中包括契约解析器(parser)，代码生产器(code generator)，序列化器(serializer)等组件，里头大量需要用到递归的思维和技术，没有这个思维的开发人员就干不了这个事情。所以我在面试候选人的时候，一般都会出递归相关的编程题，考察候选人的递归思维。  </p>
<h4 id="演化思维"><a href="#演化思维" class="headerlink" title="演化思维"></a>演化思维</h4><p>设计开发之初，无法对全局业务进行掌握，并且随着业务量的增加和业务的变更，设计架构需要根据业务需求不断演化。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构的本质是管理复杂性，&lt;strong&gt;抽象&lt;/strong&gt;、&lt;strong&gt;分层&lt;/strong&gt;、&lt;strong&gt;分治&lt;/strong&gt; 和 &lt;strong&gt;演化&lt;/strong&gt; 思维是我们工程师/架构师应对和管理复杂性的四种最基本武器。&lt;a href=&quot;http://www.infoq.com/cn/articles/architecture-thought?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;原文地址&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="架构" scheme="http://abumaster.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="思维" scheme="http://abumaster.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>去看墙外的世界</title>
    <link href="http://abumaster.com/2018/05/08/%E5%8E%BB%E7%9C%8B%E5%A2%99%E5%A4%96%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://abumaster.com/2018/05/08/去看墙外的世界/</id>
    <published>2018-05-08T06:33:45.000Z</published>
    <updated>2018-05-30T11:57:36.124Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间使用非常方便的Chrome翻墙插件 <strong>快速安全通道</strong> 不再可以免费使用，VIP价格挺高的，决定使用国外vps作为代理搭建翻墙服务器，折腾。  </p>
<a id="more"></a>
<p><strong>使用工具：</strong>  </p>
<ul>
<li>搬瓦工 VPS  </li>
<li><strong>Shadowsocks</strong> 服务端和客户端  </li>
<li><del><strong>Openvpn</strong> 服务端和客户端（这种方案体验过不是太好，全局代理，导致国内网站访问缓慢）</del>。</li>
</ul>
<p><strong>搬瓦工 VPS 购买攻略</strong><br><a href="http://banwagong.cn/">搬瓦工非官方中文网站</a> 提供了优惠的 VPS 购买，以及优惠券。可以在上面找到合适的服务器，一般作为代理服务器配置基本够用。我选用的是最便宜的一年需要 19.9$ ，打完折优惠了1刀。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-5-8/44022811.jpg" alt=""><br>按官网的步骤购买，支付完毕后，可以进入管理界面，界面非常清晰，只是终端命令输入太卡，故在Windows上使用 <em>putty</em> 可以远程连接到服务器。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-5-8/79363014.jpg" alt=""><br>默认安装的是Centos，可以自己根据需要安装Ubuntu或者其他发行版本。密码会通过注册的邮箱发过来，是一个随机生成的密码，貌似很安全，用户名为root。  </p>
<p><strong>安装代理服务</strong><br>搬瓦工默认提供了OpenVPN服务的安装选项，可以直接在线安装，安装完毕后，会默认生成一个用户的key，其中包含了生成的公钥和证书。同时也提供了Windows客户端的下载，下载安装后，将这个key解压到openvpn客户端的配置目录下，这是启动openvpn可以连接到远程的服务器上，本机所有的请求都通过代理服务器进行转发，隐藏了本机的IP地址。这种方法的缺点非常明显了，没被墙的网站还要先翻到墙外再翻回来，速度可想而知，另外毕竟不是无限流量。<em>不使用这种</em>。<br>另一种方式：<strong>Shadowsocks</strong>，其原理是将被墙的请求，伪装成普通的流量包，绕过 <strong><a href="https://zh.wikipedia.org/wiki/%E9%87%91%E7%9B%BE%E5%B7%A5%E7%A8%8B">GFW</a></strong> 的检测。  </p>
<p><strong>服务端的部署，安装：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ubuntu/Debian</span></div><div class="line">apt-get install python-pip</div><div class="line">pip install shadowsocks</div><div class="line"></div><div class="line"><span class="comment"># CentOS</span></div><div class="line">yum install python-setuptools &amp;&amp; easy_install pip</div><div class="line">pip install shadowsocks</div></pre></td></tr></table></figure></p>
<p>首先优化Shadowsocks的性能，创建一个 <code>/etc/sysctl.d/local.conf</code> 文件，输入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"># max open files</div><div class="line">fs.file-max = 1024000</div><div class="line"># max read buffer</div><div class="line">net.core.rmem_max = 67108864</div><div class="line"># max write buffer</div><div class="line">net.core.wmem_max = 67108864</div><div class="line"># default read buffer</div><div class="line">net.core.rmem_default = 65536</div><div class="line"># default write buffer</div><div class="line">net.core.wmem_default = 65536</div><div class="line"># max processor input queue</div><div class="line">net.core.netdev_max_backlog = 4096</div><div class="line"># max backlog</div><div class="line">net.core.somaxconn = 4096</div><div class="line"></div><div class="line"># resist SYN flood attacks</div><div class="line">net.ipv4.tcp_syncookies = 1</div><div class="line"># reuse timewait sockets when safe</div><div class="line">net.ipv4.tcp_tw_reuse = 1</div><div class="line"># turn off fast timewait sockets recycling</div><div class="line">net.ipv4.tcp_tw_recycle = 0</div><div class="line"># short FIN timeout</div><div class="line">net.ipv4.tcp_fin_timeout = 30</div><div class="line"># short keepalive time</div><div class="line">net.ipv4.tcp_keepalive_time = 1200</div><div class="line"># outbound port range</div><div class="line">net.ipv4.ip_local_port_range = 10000 65000</div><div class="line"># max SYN backlog</div><div class="line">net.ipv4.tcp_max_syn_backlog = 4096</div><div class="line"># max timewait sockets held by system simultaneously</div><div class="line">net.ipv4.tcp_max_tw_buckets = 5000</div><div class="line"># TCP receive buffer</div><div class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</div><div class="line"># TCP write buffer</div><div class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</div><div class="line"># turn on path MTU discovery</div><div class="line">net.ipv4.tcp_mtu_probing = 1</div><div class="line"></div><div class="line"># for high-latency network</div><div class="line">net.ipv4.tcp_congestion_control = hybla</div><div class="line"># forward ivp4</div><div class="line">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure></p>
<p>然后，创建一个Shadowsocks的配置文件，是一个json文件，<code>/etc/shadowsocks.json</code>，内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    "server":"my_server_ip",  #填入你的IP地址</div><div class="line">    "local_address": "127.0.0.1",</div><div class="line">    "local_port":1080,</div><div class="line">    "port_password": &#123;</div><div class="line">        "8381": "foobar1",    #端口号，密码</div><div class="line">        "8382": "foobar2",</div><div class="line">        "8383": "foobar3",</div><div class="line">        "8384": "foobar4"</div><div class="line">    &#125;,</div><div class="line">    # 单用户配置 "server_port" "password"</div><div class="line">    "timeout":300,</div><div class="line">    "method":"aes-256-cfb",</div><div class="line">    "fast_open": false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个多用户的配置文件，一个端口配置一个密码。<br>启动Shadowsocks服务：  </p>
<ul>
<li>前端启动，<code>ssserver -c /etc/shadowsocks.json</code> ;</li>
<li>后端启动，<code>ssserver -c /etc/shadowsocks.json -d start</code> ；</li>
<li>停止，<code>ssserver -c /etc/shadowsocks.json -d stop</code> ;</li>
<li>重启，<code>ssserver -c /etc/shadowsocks.json -d restart</code> .</li>
</ul>
<p>设置为开机启动：<br>编辑 <code>/etc/rc.local</code> 文件，在其中加上 <code>ssserver -c /etc/shadowsocks.json -d start</code> ，保存退出。<br><strong>客户端的配置：</strong><br>下载<a href="https://github.com/shadowsocks/shadowsocks-windows/releases">Shadowsocks客户端</a>。打开文件，然后编辑服务器。<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-5-8/46616172.jpg" alt=""><br>为服务器端配置的ip和端口号以及密码信息。然后右键，选择启动代理，代理模式选择PAC模式，PAC文件可以选择从GFWList更新到本地PAC文件。这样PAC中的网站走代理，其他网站走本地ip。速度很快。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间使用非常方便的Chrome翻墙插件 &lt;strong&gt;快速安全通道&lt;/strong&gt; 不再可以免费使用，VIP价格挺高的，决定使用国外vps作为代理搭建翻墙服务器，折腾。  &lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://abumaster.com/categories/life/"/>
    
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="Shadowsocks" scheme="http://abumaster.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简介</title>
    <link href="http://abumaster.com/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>http://abumaster.com/2018/04/24/设计模式简介/</id>
    <published>2018-04-24T02:34:40.000Z</published>
    <updated>2018-04-25T06:49:36.358Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计模式</strong>（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。阅读开源书籍<a href="https://github.com/me115/design_patterns">图说设计模式</a>的总结。</p>
<a id="more"></a>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><strong>适用场景：</strong><br>一个工厂Factory中生产不同种类的产品ProductA和ProductB，然后他们继承一个抽象基类，使用这些产品时，通过工厂提供的一个接口，根据参数返回对应的产品对象，而隔离具体的产品。<br>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。<br><strong>模式结构：</strong><br>简单工厂模式包含以下角色  </p>
<ul>
<li>Factory： 工厂角色<br>负责创建内部所有实例的逻辑  </li>
<li>Product： 抽象产品角色<br>抽象基类，负责所有具体类的公共接口和描述  </li>
<li>ConcreteProduct： 具体产品角色<br>具体的产品子类  </li>
</ul>
<p><strong>实例</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//抽象基类</span></div><div class="line"><span class="keyword">class</span> Product</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Product()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"abstract product construct"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数 接口</span></div><div class="line">    <span class="keyword">virtual</span> ~Product()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"abstract product deconstruct"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 产品A</span></div><div class="line"><span class="keyword">class</span> ProductA :<span class="keyword">public</span> Product</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ProductA()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品A的构造函数\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Product A ...\n"</span>;</div><div class="line">    &#125;</div><div class="line">    ~ProductA()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品B的析构函数\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 产品B</span></div><div class="line"><span class="keyword">class</span> ProductB :<span class="keyword">public</span> Product</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ProductB()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品B的构造函数\n"</span>;</div><div class="line">    &#125;</div><div class="line">    ~ProductB()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"产品B的析构函数\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是产品B\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 工厂</span></div><div class="line"><span class="keyword">class</span> Factory</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">Product* <span class="title">creatProduct</span><span class="params">(<span class="built_in">string</span> productname)</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (productname == <span class="string">"A"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (productname == <span class="string">"B"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 用于测试</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MY_TEST</span><span class="params">(<span class="built_in">string</span> name)</span></div><div class="line"></span>&#123;</div><div class="line">    Factory factory;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------TEST product = "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    Product * product = factory.creatProduct(name);</div><div class="line">    <span class="keyword">if</span> (product == <span class="literal">NULL</span>) &#123; </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no the product\n"</span>; </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------END TEST PASS ---------\n"</span>;</div><div class="line">        <span class="keyword">return</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        product-&gt;print();</div><div class="line">    <span class="keyword">delete</span> product;</div><div class="line">    product = <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------END TEST PASS ---------\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    MY_TEST(<span class="string">"A"</span>);</div><div class="line">    MY_TEST(<span class="string">"B"</span>);</div><div class="line">    MY_TEST(<span class="string">"err"</span>);</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><em>具体的产品由具体的工厂生产，而不是一个工厂生产多样产品。</em><br>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。<br>是对简单工厂模式的一种改进，所有的产品不再由单一的工厂创建，而是从一个抽象工厂中继承生产某一产品的工厂，增加新的产品的时候不用修改工厂角色，只需要从抽象工厂中派生一个具体的工厂子类。<br><strong>适用情况：</strong>   </p>
<ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。  </li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。  </li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。  </li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt="">  </p>
<ul>
<li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。  </li>
<li>抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。  </li>
<li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。  </li>
<li>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。  </li>
<li>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。  </li>
</ul>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>建造者模式（Builder Pattern）</strong> 将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。一步一步创建一个复杂对象，允许用户只通过指定复杂对象的类型和内容就可以创建他们，不需要知道内部具体的创建细节。属于对象创建型模式。  </p>
<p><strong>优点：</strong>  </p>
<ul>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。  </li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。  </li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。  </li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。  </li>
</ul>
<p><strong>缺点：</strong>  </p>
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。  </li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。  </li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>系统运行过程中保持一个实例是非常重要的，比如日志记录。单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。<br>单利模式保证某一个类只有一个实例，并且这个实例是自行创建的，并且向整个系统提供这个实例。  </p>
<ul>
<li>单例类的构造函数私有  </li>
<li>提供一个自身的静态私有成员变量  </li>
<li>提供一个公有的静态工厂方法  </li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;设计模式&lt;/strong&gt;（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。阅读开源书籍&lt;a href=&quot;https://github.com/me115/design_patterns&quot;&gt;图说设计模式&lt;/a&gt;的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="设计模式" scheme="http://abumaster.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Boost学习01</title>
    <link href="http://abumaster.com/2018/04/20/Boost%E5%AD%A6%E4%B9%A001/"/>
    <id>http://abumaster.com/2018/04/20/Boost学习01/</id>
    <published>2018-04-20T03:33:50.000Z</published>
    <updated>2018-04-25T08:51:38.274Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Boost.Asio的特性和使用。  </p>
<a id="more"></a>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>Boost.Asio 是使用 Proactor 设计模式实现的，设计模式如下图所示：<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-20/77149905.jpg" alt="Proactor pattern"><br><strong>各个模块介绍：</strong>  </p>
<ul>
<li>Asynchronous Operation 异步操作<br>定义异步操作，比如在套接字上的异步读写  </li>
</ul>
<ul>
<li>Asynchronous Operation Processor 异步操作处理器<br>执行异步操作，并把操作完成的事件放入完成事件队列中</li>
<li>Completion Event Queue 完成事件队列<br>缓冲着完成事件队列，等待被异步事件分离器调用</li>
<li>Completion Hander 完成函数<br>用来处理异步操作返回的结果，是函数对象，回调函数</li>
<li>Asynchronous Event Demultiplexer 异步事件分离器<br>阻塞等待完成事件队列，并将完成事件返回给调用者</li>
<li>Proactor 前摄器<br>调用异步事件分离器</li>
<li>Initiator 初始化<br>开始异步操作，分发回调函数</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h4 id="基本技能"><a href="#基本技能" class="headerlink" title="基本技能"></a>基本技能</h4><p><strong>使用定时器观察同步和异步</strong><br>首先包含头文件 <code>boost/asio.hpp</code> ，然后定义一个核心IO操作对象 <code>boost::asio::io_context io;</code> 将一个定时器绑定到IO对象上 <code>boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));</code> 。同步io只需要调用 <code>t.wait()</code> 会等待5s的时间才执行下面的内容。如果是非同步io需要提供一个回调函数，不影响接下来行的执行，调用<code>t.async_wait(&amp;hander);</code> 异步执行回调函数，接下来等待函数的结束，接下来的行继续执行使用 <code>io.run()</code> 阻塞等待回调函数执行结束。  </p>
<p><strong>绑定参数</strong><br>为了使用asio实现重复定时器，需要更改回调函数定时器的到期时间，然后启动新的异步等待。
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;boost/asio.hpp&gt;</div><div class="line">#include &lt;boost/bind.hpp&gt;</div><div class="line"></div><div class="line">//传入定时器对象和控制结束的计数</div><div class="line">void MyPrint(const boost::system::error_code&amp;,</div><div class="line">    boost::asio::steady_timer*t, int *count)</div><div class="line">&#123;</div><div class="line">    if (*count &lt; 5)</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; *count &lt;&lt; std::endl;</div><div class="line">        ++(*count);</div><div class="line">        t-&gt;expires_at(t-&gt;expiry() + boost::asio::chrono::seconds(1));//定时器的到期时间往后推迟1s</div><div class="line">        t-&gt;async_wait(boost::bind(MyPrint, boost::asio::placeholders::error, t, count));//重新开始一个异步等待</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    boost::asio::io_context io;</div><div class="line">    boost::asio::steady_timer t(io, boost::asio::chrono::seconds(1));</div><div class="line">    int count = 0;</div><div class="line">    </div><div class="line">    t.async_wait(boost::bind(MyPrint, boost::asio::placeholders::error, &amp;t, &amp;count));</div><div class="line">    std::cout &lt;&lt; "start...\n";</div><div class="line">    io.run();</div><div class="line">    </div><div class="line">    std::cout &lt;&lt; "Final count is " &lt;&lt; count &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    std::system("pause");</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>使用类的成员函数作为回调函数的句柄</strong><br>主函数更加简洁<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/************************************************************************/</span></div><div class="line"><span class="comment">/* 成员函数作为回调函数的句柄                                           */</span></div><div class="line"><span class="comment">/************************************************************************/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//定义一个类，用io对象构造</span></div><div class="line"><span class="keyword">class</span> printer</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">//构造函数 初始化定时器，并且异步等待</span></div><div class="line">    printer(boost::asio::io_context&amp; io)</div><div class="line">        :m_timer(io,boost::asio::chrono::seconds(<span class="number">1</span>)),m_count(<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        m_timer.async_wait(boost::bind(&amp;printer::myprint, <span class="keyword">this</span>));</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"start sync wait...\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//析构函数</span></div><div class="line">    ~printer()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Finaly the count is "</span> &lt;&lt; m_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//成员函数，用于更新定时器和重新绑定异步事件</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (m_count &lt; <span class="number">5</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"now count is "</span> &lt;&lt; m_count++ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">            <span class="comment">//定时器的到期时间延长1s</span></div><div class="line">            m_timer.expires_at(m_timer.expiry() + boost::asio::chrono::seconds(<span class="number">1</span>));</div><div class="line">            <span class="comment">//重置异步等待</span></div><div class="line">            m_timer.async_wait(boost::bind(&amp;printer::myprint, <span class="keyword">this</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    boost::asio::steady_timer m_timer;</div><div class="line">    <span class="keyword">int</span> m_count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    boost::asio::io_context io;</div><div class="line">    <span class="function">printer <span class="title">p</span><span class="params">(io)</span></span>;<span class="comment">//用io对象构造一个打印对象</span></div><div class="line">    io.run();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end\n"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>多线程环境下的同步处理</strong><br>使用 <code>io_context::strand</code> 类来同步多线程程序中的回调处理函数。如果处理需要很长的时间响应，或者考虑在多处理器上进行扩展，可以使用多线程，将处理函数同步化，共享访问。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;boost/asio.hpp&gt;</div><div class="line">#include &lt;boost/thread/thread.hpp&gt;</div><div class="line">#include &lt;boost/bind.hpp&gt;</div><div class="line"></div><div class="line">//定义一个类，不同进程共享一个类的对象，分别对一个对象进行操作</div><div class="line">class printer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    printer(boost::asio::io_context&amp; io)</div><div class="line">        : strand_(io),</div><div class="line">        timer1_(io, boost::asio::chrono::seconds(1)),</div><div class="line">        timer2_(io, boost::asio::chrono::seconds(1)),</div><div class="line">        count_(0)</div><div class="line">    &#123;</div><div class="line">        //绑定到一个io_context::strand对象上，由此对象分发其中的函数句柄</div><div class="line">        //保证了不会同时执行</div><div class="line">        timer1_.async_wait(boost::asio::bind_executor(strand_,</div><div class="line">            boost::bind(&amp;printer::print1, this)));</div><div class="line"></div><div class="line">        timer2_.async_wait(boost::asio::bind_executor(strand_,</div><div class="line">            boost::bind(&amp;printer::print2, this)));</div><div class="line">    &#125;</div><div class="line">    ~printer()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; "Final count is " &lt;&lt; count_ &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void print1()</div><div class="line">    &#123;</div><div class="line">        if (count_ &lt; 10)</div><div class="line">        &#123;</div><div class="line">            std::cout &lt;&lt;boost::this_thread::get_id() &lt;&lt;" Timer 1: " &lt;&lt; count_ &lt;&lt; std::endl;</div><div class="line">            ++count_;</div><div class="line"></div><div class="line">            timer1_.expires_at(timer1_.expiry() + boost::asio::chrono::seconds(1));</div><div class="line"></div><div class="line">            timer1_.async_wait(boost::asio::bind_executor(strand_,</div><div class="line">                boost::bind(&amp;printer::print1, this)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void print2()</div><div class="line">    &#123;</div><div class="line">        if (count_ &lt; 10)</div><div class="line">        &#123;</div><div class="line">            std::cout &lt;&lt;boost::this_thread::get_id()&lt;&lt; " Timer 2: " &lt;&lt; count_ &lt;&lt; std::endl;</div><div class="line">            ++count_;</div><div class="line"></div><div class="line">            timer2_.expires_at(timer2_.expiry() + boost::asio::chrono::seconds(1));</div><div class="line"></div><div class="line">            timer2_.async_wait(boost::asio::bind_executor(strand_,</div><div class="line">                boost::bind(&amp;printer::print2, this)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    boost::asio::io_context::strand strand_;</div><div class="line">    boost::asio::steady_timer timer1_;</div><div class="line">    boost::asio::steady_timer timer2_;</div><div class="line">    int count_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    boost::asio::io_context io;</div><div class="line">    printer p(io);</div><div class="line">    std::cout &lt;&lt; "main thread id :" &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;</div><div class="line">    boost::thread t(boost::bind(&amp;boost::asio::io_context::run, &amp;io));</div><div class="line">    std::cout &lt;&lt; "child thread id: " &lt;&lt; t.get_id() &lt;&lt; std::endl;</div><div class="line">    io.run();</div><div class="line">    t.join();</div><div class="line"></div><div class="line">    std:system("pause");</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Sockets-编程"><a href="#Sockets-编程" class="headerlink" title="Sockets 编程"></a>Sockets 编程</h4><h5 id="同步-TCP-服务器和客户端"><a href="#同步-TCP-服务器和客户端" class="headerlink" title="同步 TCP 服务器和客户端"></a>同步 TCP 服务器和客户端</h5><p>以 <strong>daytime</strong> 服务器为例，占据13端口，获取服务器当前时间，返回给客户端程序的服务。<br>使用 Boost.Asio TCP daytime server 的设计过程：<br>使用头文件和命名空间<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/asio.hpp&gt;       //包含头文件</span></span></div><div class="line"><span class="keyword">using</span> boost::asio::ip::tcp;     <span class="comment">//使用tcp传输协议</span></div></pre></td></tr></table></figure></p>
<p>创建一个acceptor接收器，用于接收客户端的连接请求<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">boost::asio::io_context io_context;</div><div class="line">tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 13));</div><div class="line"></div><div class="line">//也可以使用以下的初始化过程</div><div class="line">tcp::acceptor acceptor(io_context);</div><div class="line">tcp::endpoint endpoint(tcp::v4(),13);</div><div class="line">acceptor.open(endpoint.protocol());</div><div class="line">acceptor.set_option(tcp::acceptor::reuse_address(true));</div><div class="line">acceptor.bind(endpoint);</div><div class="line">acceptor.listen();</div><div class="line"></div><div class="line">//可以看出，创建的acceptor对象，相当于调用了标准套接字中的bind和listen</div></pre></td></tr></table></figure></p>
<p>接收连接请求并处理
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tcp::<span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;             <span class="comment">//连接套接字</span></div><div class="line">acceptor.accept(socket);                    <span class="comment">//阻塞于此，等待客户端的连接</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> message = make_daytime_string();</div><div class="line">boost::system::error_code ignored_error;</div><div class="line">boost::asio::write(socket, boost::asio::buffer(message), ignored_error);</div></pre></td></tr></table></figure></p>
<p><strong>客户端程序</strong><br>连接服务器，获得连接套接字，然后从连接套接字中读取或写入信息。<br>使用 <code>tcp::resolver</code> 解析服务的端点信息 <code>endpoint</code> ，然后调用 <code>connect(socket,endpoint)</code> 与服务器建立连接，调用 <code>socket.read_some(...)</code> 读取一定长度的信息。  </p>
<h5 id="异步-TCP-服务器"><a href="#异步-TCP-服务器" class="headerlink" title="异步 TCP 服务器"></a>异步 TCP 服务器</h5><p><strong>首先</strong>，创建一个服务器对象，用于接收来自客户端的连接请求，为构造函数提供一个 <code>io_context</code> 对象，用于提供IO服务，然后运行 <code>io_context.run()</code> 代表你执行异步io操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boost::asio::io_context io_context;</div><div class="line"><span class="function">tcp_server <span class="title">server</span><span class="params">(io_context)</span></span>;</div><div class="line">io_context.run();</div></pre></td></tr></table></figure></p>
<p><strong><code>tcp_server</code></strong>类，构造函数使它在13端口开始监听连接的到来：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tcp_server(boost::asio::io_context&amp; io_context)</div><div class="line">    : acceptor_(io_context, tcp::endpoint(tcp::v4(), <span class="number">13</span>))</div><div class="line">  &#123;</div><div class="line">    start_accept();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>start_accept()函数用于创建一个套接字，并且异步等待接收一个连接
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_accept</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    tcp_connection::pointer new_connection =</div><div class="line">      tcp_connection::create(acceptor_.get_executor().context());</div><div class="line"></div><div class="line">    acceptor_.async_accept(new_connection-&gt;socket(),</div><div class="line">        boost::bind(&amp;tcp_server::handle_accept, <span class="keyword">this</span>, new_connection,</div><div class="line">          boost::asio::placeholders::error));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(tcp_connection::pointer new_connection,</div><div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (!error)</div><div class="line">    &#123;</div><div class="line">      new_connection-&gt;start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    start_accept();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是tcp连接类，获取连接的套接字，并向连接套接字中写入信息。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> tcp_connection</div><div class="line">  : <span class="keyword">public</span> boost::enable_shared_from_this&lt;tcp_connection&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;tcp_connection&gt; pointer;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> pointer <span class="title">create</span><span class="params">(boost::asio::io_context&amp; io_context)</span></div><div class="line">  </span>&#123;</div><div class="line">    <span class="keyword">return</span> pointer(<span class="keyword">new</span> tcp_connection(io_context));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  tcp::<span class="function">socket&amp; <span class="title">socket</span><span class="params">()</span></div><div class="line">  </span>&#123;</div><div class="line">    <span class="keyword">return</span> socket_;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></div><div class="line">  </span>&#123;</div><div class="line">    message_ = make_daytime_string();</div><div class="line"></div><div class="line">    boost::asio::async_write(socket_, boost::asio::buffer(message_),</div><div class="line">        boost::bind(&amp;tcp_connection::handle_write, shared_from_this(),</div><div class="line">          boost::asio::placeholders::error,</div><div class="line">          boost::asio::placeholders::bytes_transferred));</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  tcp_connection(boost::asio::io_context&amp; io_context)</div><div class="line">    : socket_(io_context)</div><div class="line">  &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_write</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; <span class="comment">/*error*/</span>,</div><div class="line">      <span class="keyword">size_t</span> <span class="comment">/*bytes_transferred*/</span>)</span></div><div class="line">  </span>&#123;</div><div class="line">  &#125;</div><div class="line">  tcp::socket socket_;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> message_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Boost.Asio的特性和使用。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="Boost" scheme="http://abumaster.com/tags/Boost/"/>
    
      <category term="Asio" scheme="http://abumaster.com/tags/Asio/"/>
    
  </entry>
  
  <entry>
    <title>深刻理解Reactor和Proactor</title>
    <link href="http://abumaster.com/2018/04/19/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3Reactor%E5%92%8CProactor/"/>
    <id>http://abumaster.com/2018/04/19/深刻理解Reactor和Proactor/</id>
    <published>2018-04-19T09:07:28.000Z</published>
    <updated>2018-04-20T03:26:44.859Z</updated>
    
    <content type="html"><![CDATA[<p>对两种 I/O 多路复用的模式 Reactor 和 Proactor 进行介绍。</p>
<a id="more"></a>
<p><a href="http://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html">参考链接1</a><br><a href="https://www.zhihu.com/question/26943938">参考链接2</a>  </p>
<p>I/O 多路复用是为了应对高并发情况下对于客户端连接服务器请求时出现的一种技术，不用为每个连接开一个线程或者进程监听连接套接字读写数据，而是使用单个进程监听所有的套接字，当可以读写时通知开始进行 I/O 操作。多路复用机制通常依赖一个 <strong>事件多路分离器（Event Demultiplexer）</strong> ，将来自事件源的 I/O 事件分离出来，并分发到对应的 read/write 事件处理器（Event Handler）上。开发人员需要注册需要处理的事件及其回调函数，事件分离器负责将事件分发到对应的回调函数上，与事件分离器相关的模式是 <strong>Reactor</strong> 采用同步IO， <strong>Proactor</strong>采用的是异步IO。  </p>
<p><em>Reactor</em> 模式，事件分离器等待文件描述符或套接字读写就绪，然后将事件分发给对应的事件处理器（回调函数），然后由回调函数进行读写操作。<br><em>Proactor</em> 模式，事件分离器捕获IO操作完成事件，然后传递给对应的事件处理器。  </p>
<p>两种模式下的读操作过程：<br><strong>Reactor 模式实现读：</strong>  </p>
<ul>
<li>注册读就绪事件和对应的事件处理器  </li>
<li>事件分离器等待事件  </li>
<li>事件到来，激活分离器，分离器将事件分发到对应的事件处理器上  </li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新事件，返还控制权</li>
</ul>
<p><strong>Proactor 模式实现读：</strong>  </p>
<ul>
<li>处理器发起异步读操作（OS支持），处理器无视IO就绪状态，只关注完成事件  </li>
<li>事件分离器等待 <em>操作完成事件</em>  </li>
<li>在分离器等待过程中，操作系统 <em>利用并行的内核线程执行实际的读操作</em>，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成  </li>
<li>事件分离器呼唤事件处理器  </li>
<li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器  </li>
</ul>
<p>两者之间一个重要的不同点就是：前者发起回调函数时表示IO可以操作，后者发起回调时表示IO已经完成了。Reactor框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要向一个SOCKET写数据，那么当该SOCKET可以接收数据的时候，你的操作就会被调用；而Proactor框架中用户定义的操作是在实际操作之后调用的。比如你定义了一个操作要显示从SOCKET中读入的数据，那么当读操作完成以后，你的操作才会被调用。一个异步IO，一个是同步IO。  </p>
<p>使用 Reactor 的库和应用有：<br>libev、libevent、libuv、Nginx…<br>使用 Proactor 的库和应用有：<br>Booost.Asio、IOCP、ACE…  </p>
<p><a href="https://www.zhihu.com/question/26393784">关于异步和同步</a><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-20/55538714.jpg" alt=""><br>图片来自知乎</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对两种 I/O 多路复用的模式 Reactor 和 Proactor 进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="设计模式" scheme="http://abumaster.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>vcpkg：vc++ 的包管理器</title>
    <link href="http://abumaster.com/2018/04/15/vcpkg%EF%BC%9Avc-%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://abumaster.com/2018/04/15/vcpkg：vc-的包管理器/</id>
    <published>2018-04-15T07:22:32.000Z</published>
    <updated>2018-04-16T06:49:39.890Z</updated>
    
    <content type="html"><![CDATA[<p><a href=""><strong>vcpkg</strong></a> 是一个Windows下vc++的第三方库管理工具，提供了第三方库的快速安装和配置，为Windows下C++开发提供了一种有效的工具。  </p>
<a id="more"></a>
<p><strong>vcpkg</strong> 可以在Windows上安装C、C++第三方的库。通常Windows下使用第三方库时，没有在Linux下使用方便，需要自己下源码编译，并在项目中加入库和头文件的目录，十分麻烦，并且vc++的版本不同也可能出现库的不兼容问题，而vcpkg可以很好的解决这个问题。可以使用简单的几条命令安装第三方库，使用时只需要包含头文件，不再需要配置头文件目录和链接库的目录。  </p>
<hr>
<p><strong>安装需求：</strong>  </p>
<ul>
<li>Windows 10,8 或 7；  </li>
<li>vs2017或vs2015 update3；  </li>
<li>Git 2.10.x 以上；  </li>
<li>Cmake 3.10 以上。  </li>
</ul>
<hr>
<p><strong>简单使用：</strong><br><strong>1.安装</strong><br>从Microsoft的Github仓库找到vcpkg的仓库，clone到本地<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/Microsoft/vcpkg.git</div></pre></td></tr></table></figure></p>
<p>进入根目录下运行一下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.\bootstrap-vcpkg.bat       #生成vcpkg.exe</div><div class="line">.\vcpkg integrate install   #连接到用户集成中</div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-15/8337753.jpg" alt=""><br>然后，安装的库直接可以在自己的项目中使用，只需要包含头文件。  </p>
<p><strong>2.安装第三方库</strong><br>常用的几个命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vcpkg list                  <span class="comment"># 列出安装的第三方库</span></div><div class="line">vcpkg search xxxlib         <span class="comment"># 查找可以安装的库</span></div><div class="line">vcpkg install xxxlib        <span class="comment"># 安装xxxlib库</span></div></pre></td></tr></table></figure></p>
<p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-15/11870040.jpg" alt=""><br>安装完第三方库后，可以加入头文件，直接编译使用，不再需要繁琐的目录配置。<br><strong>注意</strong>：安装第三方库的时候，可能会出现库的编译错误<code>BUILD_FAILD</code>，可能是因为没有安装英文版本的VS语言包，安装过后问题解决。</p>
<p><strong>3.高级应用</strong><br><a href="https://github.com/Microsoft/vcpkg/blob/master/docs/examples/packaging-zlib.md">打包第三方库</a>，当无法搜到需要的库的时候，可以自己通过源码打包，配置，然后安装到本地。暂时没用到，用到时详细参考文档。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;&quot;&gt;&lt;strong&gt;vcpkg&lt;/strong&gt;&lt;/a&gt; 是一个Windows下vc++的第三方库管理工具，提供了第三方库的快速安装和配置，为Windows下C++开发提供了一种有效的工具。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
      <category term="包管理" scheme="http://abumaster.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的使用</title>
    <link href="http://abumaster.com/2018/04/13/mongoDB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2018/04/13/mongoDB的使用/</id>
    <published>2018-04-13T06:25:47.000Z</published>
    <updated>2018-04-13T08:06:26.854Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是一种非关系数据库，是一种 NoSQL 型数据库，用于应对大数据和分布式系统的数据库，具有高扩展性和分布式，没有复杂的关系模型。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<a id="more"></a>
<h3 id="MongoDB-简介和安装"><a href="#MongoDB-简介和安装" class="headerlink" title="MongoDB 简介和安装"></a>MongoDB 简介和安装</h3><p>MongoDB 是一种<a href="http://www.runoob.com/mongodb/nosql.html">NoSQL</a>型数据库，使用C++编写，基于分布式文件存储的开源数据库系统。<br><a href="https://www.mongodb.com/download-center#community">官方下载地址</a>。<br>在 Windows 系统环境下，可以下载安装包或者压缩包，解压后在 <code>bin</code> 目录下找到可执行的文件，其中 <code>mongod.exe</code> 是数据库服务，使用时需要打开，<code>mongo.exe</code> 是MongoDB数据库的控制台，命令终端。另外，该目录下还提供了数据库的状态查看和管理小程序。  </p>
<h4 id="MongoDB-服务器的运行"><a href="#MongoDB-服务器的运行" class="headerlink" title="MongoDB 服务器的运行"></a>MongoDB 服务器的运行</h4><p><strong>有两种方式运行：<em>命令行</em> 和 <em>配置服务</em> </strong><br>第一种方法是从终端运行 MongoDB 服务器，需要指定数据库的存储路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod.exe --dbpath mydbpath\db</div></pre></td></tr></table></figure></p>
<p>第二种方法是编写Windows下的服务程序，使MongoDB服务器以服务的形式存在，创建一个 <code>mongodd.cfg</code> 文件，在其中指定日志路径和数据库路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">systemLog:</div><div class="line">    destination: file</div><div class="line">    path: D:\Program Files (x86)\mongodb-win32-x86_64\bin\log\mongod.log</div><div class="line">storage:</div><div class="line">    dbPath: D:\Program Files (x86)\mongodb-win32-x86_64\bin\db</div></pre></td></tr></table></figure></p>
<p>然后以管理员的身份运行：<code>mongod.exe --config &quot;path\mongod.cfg&quot; --install</code> 安装服务，这时可以在Windows服务中看到一个名为MongoDB的服务，可以手动启动或者使用命令启动和关闭：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">net start MongoDB   <span class="comment"># 启动服务</span></div><div class="line">net stop MongoDB    <span class="comment"># 关闭服务</span></div><div class="line">mongod.exe --remove <span class="comment"># 移除服务</span></div></pre></td></tr></table></figure></p>
<h4 id="连接-MongoDB-服务器"><a href="#连接-MongoDB-服务器" class="headerlink" title="连接 MongoDB 服务器"></a>连接 MongoDB 服务器</h4><p>使用 <code>mongo</code> 命令进入 MongoDB 后台管理的shell，默认连接到其中的test数据库，可以使用一些简单的JavaScript语句。  </p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="创建和删除数据库"><a href="#创建和删除数据库" class="headerlink" title="创建和删除数据库"></a>创建和删除数据库</h4><p>查看所有包含数据的数据库： <code>show dbs</code><br>查看当前使用的数据库： <code>db</code><br>切换和创建数据库 <code>use DB_NAME</code> 不存在会创建
需要删除某一个数据库，可以先切换到某一个数据库下，然后执行 <code>db.dropDatabase()</code> </p>
<h4 id="创建和删除集合"><a href="#创建和删除集合" class="headerlink" title="创建和删除集合"></a>创建和删除集合</h4><p>创建的基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createCollection(name, options)</div></pre></td></tr></table></figure></p>
<p>name 为名称，options为选项用来指定集合的大小和文档的最大数量。<br>删除集合 <code>db.collection.drop()</code> ，删除前使用 <code>show collections</code> 或者 <code>show tables</code> 查看集合，然后调用具体的集合删除。  </p>
<h4 id="文档的操作"><a href="#文档的操作" class="headerlink" title="文档的操作"></a>文档的操作</h4><p><strong>插入文档的基本操作</strong>，文档相当于一个json数据结构的文件。插入的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.COLLECTION_NAME.insert(document)</div></pre></td></tr></table></figure></p>
<p>其中要指定插入到的集合，document是一个json格式如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">"title"</span> : <span class="string">"MongoDB 教程"</span>,</div><div class="line">        <span class="attr">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</div><div class="line">        <span class="attr">"by"</span> : <span class="string">"菜鸟教程"</span>,</div><div class="line">        <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</div><div class="line">        <span class="attr">"tags"</span> : [</div><div class="line">                <span class="string">"mongodb"</span>,</div><div class="line">                <span class="string">"database"</span>,</div><div class="line">                <span class="string">"NoSQL"</span></div><div class="line">        ],</div><div class="line">        <span class="attr">"likes"</span> : <span class="number">100</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 <code>db.col.find()</code> 可以查找插入的文档。  </p>
<p><strong>更新文档</strong> 通过 <code>update</code> 语句，基本语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.collection.update(</div><div class="line">   &lt;query&gt;,     # 类似SQL中where后面的 找到要更改的记录</div><div class="line">   &lt;update&gt;,    # set后面的内容 更改的内容</div><div class="line">   &#123;</div><div class="line">     upsert: &lt;boolean&gt;, #没有修改记录是否插入新的</div><div class="line">     multi: &lt;boolean&gt;, # 插入多条记录</div><div class="line">     writeConcern: &lt;document&gt; #抛出异常级别</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>通过 <code>save()</code> 方法，可以通过传入一个文档替换现有的文档。</p>
<p><strong>删除文档</strong> 通过 <code>remove</code> 来删除，基本语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.collection.remove(</div><div class="line">   &lt;query&gt;,</div><div class="line">   &#123;</div><div class="line">     justOne: &lt;boolean&gt;,</div><div class="line">     writeConcern: &lt;document&gt;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>使用更新的方法 <code>deleteOne()</code> 和 <code>deleteMany()</code> 方法删除文档：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.deleteMany(&#123;&#125;)  <span class="comment"># 删除所有的文档</span></div><div class="line">db.collection.deleteMany(&#123;status:<span class="string">"A"</span>&#125;) <span class="comment"># 删除所有status为A的文档</span></div><div class="line">db.collection.deleteOne(&#123;status:<span class="string">"A"</span>&#125;)  <span class="comment"># 删除一条</span></div></pre></td></tr></table></figure></p>
<p><strong>查询文档</strong> 简单的查询方式一种非结构化和一种结构化的输出方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.collection.find(query, projection)</div><div class="line">db.collection.find(query, projection).pretty()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 是一种非关系数据库，是一种 NoSQL 型数据库，用于应对大数据和分布式系统的数据库，具有高扩展性和分布式，没有复杂的关系模型。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://abumaster.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="NoSql" scheme="http://abumaster.com/tags/NoSql/"/>
    
      <category term="MongoDB" scheme="http://abumaster.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-4</title>
    <link href="http://abumaster.com/2018/04/08/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-4/"/>
    <id>http://abumaster.com/2018/04/08/高效使用STL-4/</id>
    <published>2018-04-08T07:07:38.000Z</published>
    <updated>2018-04-12T13:20:41.172Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，使用STL编程。</p>
</div>
<a id="more"></a>
<h4 id="条款43：尽量用算法取代循环"><a href="#条款43：尽量用算法取代循环" class="headerlink" title="条款43：尽量用算法取代循环"></a>条款43：尽量用算法取代循环</h4><p>每个算法至少接收一组迭代器来表示容器的区间，如查找最大最小值，查找满足某一条件的元素，这时用内置的一些算法可以解决，不需要手写一些循环，效率更高，即使在算法的内部遍历也是由循环来搞定的。优点包括：  </p>
<ul>
<li><strong>效率</strong>：通常算法比循环更高效；  </li>
<li><strong>正确性</strong>：写循环更容易出错，且代码较算法来的复杂；  </li>
<li><strong>可维护性</strong>：算法代码简洁，便于维护。  </li>
</ul>
<h4 id="条款44：尽量使用成员函数替代同名算法"><a href="#条款44：尽量使用成员函数替代同名算法" class="headerlink" title="条款44：尽量使用成员函数替代同名算法"></a>条款44：尽量使用成员函数替代同名算法</h4><p>出于效率考虑，可以使用容器的成员函数替代同名的算法，成员函数的速度相对较快。  </p>
<h4 id="条款45：注意-count、find、binary-search、lower-bound、upper-bound和equal-range-的区别"><a href="#条款45：注意-count、find、binary-search、lower-bound、upper-bound和equal-range-的区别" class="headerlink" title="条款45：注意 count、find、binary_search、lower_bound、upper_bound和equal_range 的区别"></a>条款45：注意 <code>count、find、binary_search、lower_bound、upper_bound和equal_range</code> 的区别</h4><p><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-12/37444869.jpg" alt="">  </p>
<h4 id="条款46：考虑使用函数对象代替函数作算法的参数"><a href="#条款46：考虑使用函数对象代替函数作算法的参数" class="headerlink" title="条款46：考虑使用函数对象代替函数作算法的参数"></a>条款46：考虑使用函数对象代替函数作算法的参数</h4><p>将函数对象传递给STL算法的效率比传递真的函数高。如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对容器中数据进行降序排序</span></div><div class="line"><span class="comment">//1.使用函数对象greater</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</div><div class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">double</span>&gt;());</div><div class="line"><span class="comment">//2.使用函数</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">doubleGreater</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span></div><div class="line"></span>&#123;</div><div class="line">    <span class="keyword">return</span> dl &gt; d2;</div><div class="line">&#125;</div><div class="line">sort(v.begin(), v.end(), doubleGreater);</div></pre></td></tr></table></figure></p>
<p>函数作为参数实际上是传递的函数指针，在每一次调用的时候编译器产生一个间接函数调用，通过指针调用。  </p>
<h4 id="条款47：避免产生只写代码"><a href="#条款47：避免产生只写代码" class="headerlink" title="条款47：避免产生只写代码"></a>条款47：避免产生只写代码</h4><p>灵感的乍现，让写代码变得容易，但是后期很难从代码中领会其真正所要表达的意思，称之为只写代码。<br>原书中说道：  </p>
<blockquote>
<p>代码的读比写更经常，这是软件工程的真理。也就是说软件的维护比开发花费多得多的时间。不能读和理解的软件不能被维护，不能维护的软件几乎没有不值得拥有。你用STL越多，你会感到它越来越舒适，而且你会越来越多的使用嵌套函数调用和即时（on the fly）建立函数对象。这没有什么错的，但永远记住你今天写的代码会被某个人——也可能是你——在未来的某一天读到。为那天做准备吧。</p>
</blockquote>
<h4 id="条款48：总是-include适当的头文件"><a href="#条款48：总是-include适当的头文件" class="headerlink" title="条款48：总是#include适当的头文件"></a>条款48：总是<code>#include</code>适当的头文件</h4><p>包含正确的头文件，谨记以下几条：  </p>
<ul>
<li>几乎所有的容器都在其同名的头文件中；  </li>
<li>算法常在 <code>algorithm</code> 头文件中，除了 <code>accumulate inner_product、adjacent_difference和partial_sum</code> 在 <code>numeric</code>；  </li>
<li>特殊的迭代器在 <code>iterator</code> 中，流迭代器和缓冲迭代器；  </li>
<li>标准仿函数和仿函数适配器在 <code>functional</code> 头文件中。  </li>
</ul>
<h4 id="条款49：学习破解有关STL的编译器诊断信息"><a href="#条款49：学习破解有关STL的编译器诊断信息" class="headerlink" title="条款49：学习破解有关STL的编译器诊断信息"></a>条款49：学习破解有关STL的编译器诊断信息</h4><h4 id="条款50：不断学习"><a href="#条款50：不断学习" class="headerlink" title="条款50：不断学习"></a>条款50：不断学习</h4><p>善于利用网络资源：  </p>
<ul>
<li>SGI STL网站: <a href="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>   </li>
<li>STLport网站， <a href="http://www.stlport.org/">http://www.stlport.org/</a>   </li>
<li>Boost网站， <a href="http://www.boost.org/">http://www.boost.org/</a>  或者 <a href="http://boost.sourceforge.net/">http://boost.sourceforge.net/</a> </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，使用STL编程。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-3</title>
    <link href="http://abumaster.com/2018/04/08/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-3/"/>
    <id>http://abumaster.com/2018/04/08/高效使用STL-3/</id>
    <published>2018-04-08T07:07:12.000Z</published>
    <updated>2018-04-11T12:15:48.657Z</updated>
    
    <content type="html"><![CDATA[<div class="note success"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第五章算法和第六章仿函数的介绍。</p>
</div>
<a id="more"></a>
<h4 id="条款30：确保目标空间足够大"><a href="#条款30：确保目标空间足够大" class="headerlink" title="条款30：确保目标空间足够大"></a>条款30：确保目标空间足够大</h4><p>使用算法插入时插入的是不存在的空即迭代器的尾部，编译出错。  </p>
<h4 id="条款31：排序选择"><a href="#条款31：排序选择" class="headerlink" title="条款31：排序选择"></a>条款31：排序选择</h4><p>根据实际的需求选择合适的排序算法：  </p>
<ul>
<li>如果你需要在vector、string、deque或数组上进行完全排序，你可以使用 <code>sort</code> 或 <code>stable_sort</code>。  </li>
<li>如果你有一个vector、string、deque或数组，你只需要排序前n个元素，应该用 <code>partial_sort</code>。  </li>
<li>如果你有一个vector、string、deque或数组，你需要鉴别出第n个元素或你需要鉴别出最前的n个元素，而不用知道它们的顺序，<code>nth_element</code>是你应该注意和调用的。  </li>
<li>如果你需要把标准序列容器的元素或数组分隔为满足和不满足某个标准，你大概就要找 <code>partition</code> 或 <code>stable_partition</code>。  </li>
<li>如果你的数据是在list中，你可以直接使用 <code>partition</code> 和 <code>stable_partition</code>，你可以使用list的 <code>sort</code>来代替 <code>sort</code> 和<code>stable_sort</code>。   </li>
<li>如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务，但正如我
在上面勾画的，会有很多选择。  </li>
</ul>
<h4 id="条款32：如果真要删除东西，在remove-后加上-erase"><a href="#条款32：如果真要删除东西，在remove-后加上-erase" class="headerlink" title="条款32：如果真要删除东西，在remove 后加上 erase"></a>条款32：如果真要删除东西，在<code>remove</code> 后加上 <code>erase</code></h4><p>STL 算法 <code>remove</code> 不是真正意义上的删除元素，而是遇见一个满足条件的元素，然后将其后的元素向前移动，元素的个数是不变的。而想真正删除，需要使用 <code>erase</code> 函数，将指定迭代器的元素删除。  </p>
<h4 id="条款33：避免在指针容器上使用-remove"><a href="#条款33：避免在指针容器上使用-remove" class="headerlink" title="条款33：避免在指针容器上使用 remove"></a>条款33：避免在指针容器上使用 <code>remove</code></h4><p>如上条款一样，这个算法不是真正意义上的删除，而是将元素向前移动，在指针容器上使用，可能会导致内存的泄漏。  </p>
<h4 id="条款34：注意哪个算法需要使用有序空间"><a href="#条款34：注意哪个算法需要使用有序空间" class="headerlink" title="条款34：注意哪个算法需要使用有序空间"></a>条款34：注意哪个算法需要使用有序空间</h4><h4 id="条款35：使用-mismatch-和-lexicographical-compare-实现简单的忽略大小写字符串比较"><a href="#条款35：使用-mismatch-和-lexicographical-compare-实现简单的忽略大小写字符串比较" class="headerlink" title="条款35：使用 mismatch 和 lexicographical_compare 实现简单的忽略大小写字符串比较"></a>条款35：使用 <code>mismatch</code> 和 <code>lexicographical_compare</code> 实现简单的忽略大小写字符串比较</h4><h4 id="条款36：了解-copy-if-的正确实现"><a href="#条款36：了解-copy-if-的正确实现" class="headerlink" title="条款36：了解 copy_if 的正确实现"></a>条款36：了解 <code>copy_if</code> 的正确实现</h4><h4 id="条款37：统计区间"><a href="#条款37：统计区间" class="headerlink" title="条款37：统计区间"></a>条款37：统计区间</h4><p>STL中提供了一些用于统计的算法，如 <code>count</code> 用来统计具有某一值的元素的个数，<code>count_if</code> 用于统计满足某一判别式的元素个数，区间中的最大最小值可以使用 <code>max_element</code> 和 <code>min_element</code> 得到。如果需要对某一区间中的元素定制更加复杂的操作，比如容器中元素求和，乘积和平均，可以使用 <code>accumulate</code> 和 <code>for_each</code> 定制仿函数，对容器进行操作。  </p>
<h4 id="条款38：把仿函数设计为用于值传递"><a href="#条款38：把仿函数设计为用于值传递" class="headerlink" title="条款38：把仿函数设计为用于值传递"></a>条款38：把仿函数设计为用于值传递</h4><p>在C和CPP中不允许将函数作为参数传递给函数，需要传递一个函数指针作为参数。如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">///最后一个参数是一个函数指针</div><div class="line">void qsort(void *base, size_t nmemb, size_t size,</div><div class="line">            int (*cmpfcn)(const void*, const void*));</div></pre></td></tr></table></figure></p>
<h4 id="条款39：用纯函数做判断式"><a href="#条款39：用纯函数做判断式" class="headerlink" title="条款39：用纯函数做判断式"></a>条款39：用纯函数做判断式</h4><h4 id="条款40：使仿函数类可以适配"><a href="#条款40：使仿函数类可以适配" class="headerlink" title="条款40：使仿函数类可以适配"></a>条款40：使仿函数类可以适配</h4><h4 id="条款41：了解使用-ptr-fun-、mem-fun-的原因"><a href="#条款41：了解使用-ptr-fun-、mem-fun-的原因" class="headerlink" title="条款41：了解使用 ptr_fun 、mem_fun 的原因"></a>条款41：了解使用 <code>ptr_fun</code> 、<code>mem_fun</code> 的原因</h4><h4 id="条款42：确定-less-lt-T-gt-表示-operator-lt"><a href="#条款42：确定-less-lt-T-gt-表示-operator-lt" class="headerlink" title="条款42：确定 less&lt;T&gt; 表示 operator&lt;"></a>条款42：确定 <code>less&lt;T&gt;</code> 表示 <code>operator&lt;</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note success&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第五章算法和第六章仿函数的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-2</title>
    <link href="http://abumaster.com/2018/04/07/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8STL-2/"/>
    <id>http://abumaster.com/2018/04/07/高效使用STL-2/</id>
    <published>2018-04-07T10:55:12.000Z</published>
    <updated>2018-04-10T06:40:02.434Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第二章 <code>vector</code> 和 <code>string</code> 和第三章的关联容器的介绍。</p>
</div>
<a id="more"></a>
<h4 id="条款13：使用-vector-和-string-替代动态分配的数组"><a href="#条款13：使用-vector-和-string-替代动态分配的数组" class="headerlink" title="条款13：使用 vector 和 string 替代动态分配的数组"></a>条款13：使用 <code>vector</code> 和 <code>string</code> 替代动态分配的数组</h4><p><strong>动态申请空间的弊端：</strong>  </p>
<ul>
<li>保证 <code>new</code> 和 <code>delete</code> 的成对出现，否则容易造成内存泄漏；  </li>
<li>保证 <code>delete</code> 的正确使用对象使用 <code>delete</code> ，而数组则要使用 <code>delete []</code> 形式；</li>
<li>保证 <code>delete</code> 只使用一次，以免发生错误。  </li>
</ul>
<p>因此，如果需要使用 <strong>动态分配数组</strong> 形式的数据结构可以考虑使用 <code>vector</code> 或者 <code>string</code> 容器，其有安全的内存管理机制，可以保证不会发生内存泄漏的问题。</p>
<h4 id="条款14：使用-reserve-来避免不必要的重新分配"><a href="#条款14：使用-reserve-来避免不必要的重新分配" class="headerlink" title="条款14：使用 reserve 来避免不必要的重新分配"></a>条款14：使用 <code>reserve</code> 来避免不必要的重新分配</h4><p>像 <code>vector</code> 这样的容器，其可以最大容纳元素的数量 <code>capacity()</code> 往往要大于当前大小 <code>size()</code> 这保证其不需要插入一个元素就要申请空间，更加高效。然而当我们频繁插入元素的时候，往往是大于所能够容纳的最大元素，这时需要重新分配空间，其步骤如下：  </p>
<ul>
<li>分配新的内存空间，一般是当前容量的倍数；   </li>
<li>将旧空间的元素拷贝到新的空间中；  </li>
<li>销毁旧空间上的对象；  </li>
<li>回收旧空间。<br>开销非常大，并且会让迭代器、指针和引用失效。这时为了避免这种不需要的代价，可以预估所需空间一次分配足够大的空间。<br>通常有两个成员函数可以使用：  </li>
<li><code>resize(size_type n)</code> 通常返回设置的新大小 <code>n</code> ，需要注意的是，这个函数将会在容器中构造新的元素，当 <code>n</code> 大于当前容器大小时，如果小于，则会将尾部的元素销毁，大于最大容量时，会发生重新分配；  </li>
<li><code>reserve(size_type n)</code> 函数通常设置容器的最大空间和大小为 <code>n</code> ，当 <code>n</code> 大于当前最大容量时才会发生内存的重新配置。<br>因此可以使用 <code>reserve</code> 函数来通过预估使用空间的大小申请足够大的空间，来避免频繁申请配置空间。  </li>
</ul>
<h4 id="条款15：小心-string-实现的多样性"><a href="#条款15：小心-string-实现的多样性" class="headerlink" title="条款15：小心 string 实现的多样性"></a>条款15：小心 <code>string</code> 实现的多样性</h4><p><code>string</code> 类型在各个平台下的实现是不同的，如果使用 <code>sizeof(string)</code> 来获得其大小会发现，它的大小为 1 或者 7 倍 <code>char *</code> 。</p>
<h4 id="条款16：如何将-vector-和-string-的数据传递遗留的-API"><a href="#条款16：如何将-vector-和-string-的数据传递遗留的-API" class="headerlink" title="条款16：如何将 vector 和 string 的数据传递遗留的 API"></a>条款16：如何将 <code>vector</code> 和 <code>string</code> 的数据传递遗留的 API</h4><p>对一些旧的API传递的参数是数组或者指针，当使用 <code>vector</code> 或者 <code>string</code> 作为参数传递时，要发生一定的转变。<br>通常，由于如 <code>vector</code> 容器那样，内存分布是连续的与普通的数组没有两样，可以用首元素的地址当做是数组名称，当然需对容器非空进行判断。一个技巧是，当使用 <code>C</code> 风格的API时，参数是数组的情况下，需要将数据传递给其他容器，可以使用 <code>vector</code> 作为中介，然后用它去初始化其他容器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从 C API 中获得数据 传递到其他容器中</span></div><div class="line"><span class="keyword">size_t</span> fillArray(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize); <span class="comment">// C API</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd(maxNumDoubles);</div><div class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.size()));</div><div class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到deque</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; l(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到list</span></div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; s(vd.begin(), vd.end()); <span class="comment">// 拷贝数据到set</span></div><div class="line"></div><div class="line"><span class="comment">// 将其他容器中的数据传递到 C API 中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pints, <span class="keyword">size_t</span> numInts)</span></span>; <span class="comment">// C API (同上)</span></div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet; <span class="comment">// 保存要传递给API数据的set</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(intSet.begin(), intSet.end()); <span class="comment">// 拷贝set数据到vector</span></div><div class="line"><span class="keyword">if</span> (!v.empty()) doSomething(&amp;v[<span class="number">0</span>], v.size()); <span class="comment">// 传递数据到API</span></div></pre></td></tr></table></figure></p>
<h4 id="条款17：使用交换来修整过剩容量"><a href="#条款17：使用交换来修整过剩容量" class="headerlink" title="条款17：使用交换来修整过剩容量"></a>条款17：使用交换来修整过剩容量</h4><p>当使用容器时，插入数据可以使最大容量增加，但是当删除一部分元素时，多余的空间并不会自己归还给系统，需要手动收缩到合适的范围，一个做法是使用 <code>swap</code> 函数，构造一个与原始容器大小相同的临时容器，通过交换将元素填充到原始容器，互换而不会持有多余的空间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;Contestant&gt;(contestants).swap(contestants);</div></pre></td></tr></table></figure></p>
<p>在 <code>C++11</code> 后提供了一个函数来调整过剩的空间大小，<code>shrink_to_fit()</code> 将多余的空间归还给系统。  </p>
<h4 id="条款18：避免使用-vector-lt-bool-gt"><a href="#条款18：避免使用-vector-lt-bool-gt" class="headerlink" title="条款18：避免使用 vector&lt;bool&gt;"></a>条款18：避免使用 <code>vector&lt;bool&gt;</code></h4><p>它不是一个 STL 容器，不保存 bool 类型。<code>vector&lt;bool&gt;</code> 不满足STL容器的必要条件，你最好不要使用它；而<code>deque&lt;bool&gt;</code> 和 <code>bitset</code> 是基本能满足你对 <code>vector&lt;bool&gt;</code> 提供的性能的需要的替代数据结构。  </p>
<h4 id="条款19：了解相等和等价的区别"><a href="#条款19：了解相等和等价的区别" class="headerlink" title="条款19：了解相等和等价的区别"></a>条款19：了解相等和等价的区别</h4><p>在标准的关联容器中，如<code>set</code>当插入新的元素时，是用等价判断的，而不是相等，通过自定义的比较函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!c.key_comp()(x, y) &amp;&amp; !c.key_comp()(y, x) <span class="comment">// 在c的排序顺序中</span></div><div class="line"><span class="comment">// 如果x在y之前它非真，</span></div><div class="line"><span class="comment">// 同时在c的排序顺序中</span></div><div class="line"><span class="comment">// 如果y在x之前它非真</span></div></pre></td></tr></table></figure></p>
<p>使用等价作为比较的标准，可以避免使用排序和相等两个比较函数造成的问题。  </p>
<h4 id="条款20：为指针的关联容器指定比较类型"><a href="#条款20：为指针的关联容器指定比较类型" class="headerlink" title="条款20：为指针的关联容器指定比较类型"></a>条款20：为指针的关联容器指定比较类型</h4><p>使用一个 <code>string*</code> 类型的 <code>set</code> 容器的时候，其比较类型默认为比较容器中指针的大小，如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp; <span class="comment">// ssp = “set of string ptrs”</span></div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Anteater"</span>));</div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Wombat"</span>));</div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Lemur"</span>));</div><div class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Penguin"</span>));</div><div class="line"></div><div class="line"><span class="comment">//可以使用以下自定义函数来按字符串的值比较大小，而不是只比较指针的大小</span></div><div class="line"><span class="keyword">struct</span> StringPtrLess: </div><div class="line"><span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></div><div class="line">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> *ps1 &lt; *ps2;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="条款21：永远让比较函数对相等的值返回-false"><a href="#条款21：永远让比较函数对相等的值返回-false" class="headerlink" title="条款21：永远让比较函数对相等的值返回 false"></a>条款21：永远让比较函数对相等的值返回 false</h4><h4 id="条款22：避免原地修改-set-的键值"><a href="#条款22：避免原地修改-set-的键值" class="headerlink" title="条款22：避免原地修改 set 的键值"></a>条款22：避免原地修改 set 的键值</h4><p>set 容器需要保证元素的有序性，任何对于键值的修改都会改变这种有序性，简单来说不要改变容器中影响排序的键值。  </p>
<h4 id="条款23：考虑有序的-vector-替代关联容器"><a href="#条款23：考虑有序的-vector-替代关联容器" class="headerlink" title="条款23：考虑有序的 vector 替代关联容器"></a>条款23：考虑有序的 vector 替代关联容器</h4><h4 id="条款24：关乎效率的考虑"><a href="#条款24：关乎效率的考虑" class="headerlink" title="条款24：关乎效率的考虑"></a>条款24：关乎效率的考虑</h4><h4 id="条款25：熟悉非标准散列容器"><a href="#条款25：熟悉非标准散列容器" class="headerlink" title="条款25：熟悉非标准散列容器"></a>条款25：熟悉非标准散列容器</h4><h4 id="条款26：使用迭代器"><a href="#条款26：使用迭代器" class="headerlink" title="条款26：使用迭代器"></a>条款26：使用迭代器</h4><p>迭代器和常量迭代器之间的转换关系<br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-4-10/12775061.jpg" alt=""><br>由图可以看出，迭代器可以隐式转换成常量迭代器，而常量迭代器却不可以转换成非常亮迭代器，一些容器的成员函数接收的是非常量迭代器，只能尽量使用非常量的迭代器。  </p>
<h4 id="条款27：常量迭代器转换成非常量迭代器"><a href="#条款27：常量迭代器转换成非常量迭代器" class="headerlink" title="条款27：常量迭代器转换成非常量迭代器"></a>条款27：常量迭代器转换成非常量迭代器</h4><p>使用 <code>distance</code> 和 <code>advance</code> 把 <code>const_iterator</code> 转换成 <code>iterator</code> 。为了在容器当前常量迭代器上插入一个元素，需要使其非常量化。通常的做法是，使用一个非常量的迭代器使其移动到常量迭代器的位置。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef deque&lt;int&gt; IntDeque; // 和以前一样</div><div class="line">typedef IntDeque::iterator Iter;        // 非常量迭代器</div><div class="line">typedef IntDeque::const_iterator ConstIter; // 常量迭代器</div><div class="line">IntDeque d;</div><div class="line">ConstIter ci;</div><div class="line">... // 让ci指向d</div><div class="line">Iter i(d.begin()); // 初始化i为d.begin()</div><div class="line">advance(i, distance(i, ci)); // 把i移到指向ci位置</div><div class="line">// （但请留意下面关于为什么</div><div class="line">// 在它编译前要调整的原因）</div></pre></td></tr></table></figure></p>
<h4 id="条款28：-base-迭代器之间的转换"><a href="#条款28：-base-迭代器之间的转换" class="headerlink" title="条款28： base 迭代器之间的转换"></a>条款28： <code>base</code> 迭代器之间的转换</h4><p><code>base</code> 可以将 <code>reverse_iterator</code> 转换成 <code>iterator</code>，其是如何实现这种转换的呢？  </p>
<h4 id="条款29：需要一个一个字符输入时考虑使用-istreambuf-iterator"><a href="#条款29：需要一个一个字符输入时考虑使用-istreambuf-iterator" class="headerlink" title="条款29：需要一个一个字符输入时考虑使用 istreambuf_iterator"></a>条款29：需要一个一个字符输入时考虑使用 <code>istreambuf_iterator</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第二章 &lt;code&gt;vector&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 和第三章的关联容器的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>高效使用STL-1</title>
    <link href="http://abumaster.com/2018/04/06/%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8STL-1/"/>
    <id>http://abumaster.com/2018/04/06/高效实用STL-1/</id>
    <published>2018-04-06T07:53:39.000Z</published>
    <updated>2018-04-07T11:00:27.125Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>英文书籍 <code>Effective STL</code> 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 <code>C++</code>顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第一章容器的介绍。</p>
</div>
<a id="more"></a>
<h4 id="条款1：小心选择容器"><a href="#条款1：小心选择容器" class="headerlink" title="条款1：小心选择容器"></a>条款1：小心选择容器</h4><p><strong>容器的分类：</strong>  </p>
<ul>
<li>标准STL序列容器：<code>vector</code>、<code>string</code>、<code>deque</code>和<code>list</code>。  </li>
<li>标准STL关联容器：<code>map</code>、<code>set</code>和<code>multiset</code>、<code>multimap</code>。  </li>
<li>非标准序列容器：<code>slist</code>和<code>rope</code>，单向链表和重型字符串。  </li>
<li>非标准关联容器：包括基于散列表的容器<code>hash_**</code>。  </li>
<li>标准非STL容器：数组、<code>bitset</code>、<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。  </li>
</ul>
<p>容器的选择可以考虑使用场景需要的算法的复杂度高低，如需要在容器的中间频繁插入删除元素，这时需要的容器可能是<code>list</code>，当需要在头尾插入删除元素，那么<code>deque</code>则是一个好的选择。<br>同时，也应该考虑到迭代器的能力，内存布局的兼容能力容器操作复杂度等等。  </p>
<h4 id="条款2：容器无关代码？"><a href="#条款2：容器无关代码？" class="headerlink" title="条款2：容器无关代码？"></a>条款2：容器无关代码？</h4><p>容器的使用真的与代码无关吗？考虑以下场景，<code>vector</code>和<code>list</code>在使用过程中，迭代器和内存布局是不一样的，因此，两个容器在使用过程中完全是不兼容的，许多方法是特有的，不能同时使用。当代码中的一个容器替换成另一个容器的时候，要考虑旧的代码对新的容器的适用性，保证不出现错误的使用，而导致编译错误。<br>一个比较方便的做法是使用 <code>typedef</code> 自定义迭代器类型。如代码不应这样写：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123;...&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</div><div class="line">Widget bestWidget;</div><div class="line"><span class="comment">// 给bestWidget一个值</span></div><div class="line"><span class="built_in">vector</span>&lt;Widget&gt;::iterator i = <span class="comment">// 寻找和bestWidget相等的Widget</span></div><div class="line">    find(vw.begin(), vw.end(), bestWidget);</div></pre></td></tr></table></figure></p>
<p>其中如果更换迭代器的话，需要查找所有的 <code>vector&lt;Widget&gt;</code> 然后改成新的容器，高效的写法是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123; ... &#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Widget&gt; WidgetContainer;         <span class="comment">//Widget类型的容器类型</span></div><div class="line"><span class="keyword">typedef</span> WidgetContainer::iterator WCIterator;   <span class="comment">//迭代器</span></div><div class="line">WidgetContainer cw;</div><div class="line">Widget bestWidget;</div><div class="line"><span class="comment">//</span></div><div class="line">WCIterator i = find(cw.begin(), cw.end(), bestWidget);</div></pre></td></tr></table></figure></p>
<p>这种做法，直接改 <code>typedef</code> 那两行就行。<br>如果不想用 <code>typedef</code> 将使用的容器暴露给用户，那么可以使用 <code>class</code> 将内部使用的容器私有化，只对用户提供统一的调用接口，当根据需求需要改变容器时，对用户代码不必进行过多的更改。  </p>
<h4 id="条款3：容器内对象的拷贝"><a href="#条款3：容器内对象的拷贝" class="headerlink" title="条款3：容器内对象的拷贝"></a>条款3：容器内对象的拷贝</h4><div class="note info"><p>主旨：使容器内对象拷贝操作的轻量而正确。</p>
</div>  
<p>一个好的做法是，将对象数组（容器）改为指针的数组（容器），毕竟指针的拷贝比对象的拷贝要快。</p>
<h4 id="条款4：用-empty-替换-size-0"><a href="#条款4：用-empty-替换-size-0" class="headerlink" title="条款4：用 empty 替换 size()==0"></a>条款4：用 <code>empty</code> 替换 <code>size()==0</code></h4><p>当判断一个容器中元素是否为空时，通常使用 <code>empty()</code> 它是常数时间的，而用 <code>size()==0</code> 来判断则是线性时间。  </p>
<h4 id="条款5：使用空间成员函数"><a href="#条款5：使用空间成员函数" class="headerlink" title="条款5：使用空间成员函数"></a>条款5：使用空间成员函数</h4><p>空间成员函数可以操作一个区间内的元素，而不是使用循环来对单个元素进行操作，具体的应用场景为，将容器内的元素用另一个容器中的元素替代，成段拷贝，区间赋值等等如。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( size_type count, <span class="keyword">const</span> T&amp; value )</span></span>;</div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( InputIt first, InputIt last )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; ilist )</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="条款6：C-的解析"><a href="#条款6：C-的解析" class="headerlink" title="条款6：C++的解析"></a>条款6：C++的解析</h4><blockquote>
<p>C++里面的一条通用规则，几乎任何东西都能被分析为函数声明  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123;...&#125;; <span class="comment">// 假设Widget有默认构造函数</span></div><div class="line"><span class="function">Widget <span class="title">w</span><span class="params">()</span></span>; <span class="comment">// 函数名w，返回一个Widget类型</span></div></pre></td></tr></table></figure>
<p>造成这种歧义出现的主要原因是，编译器无法知道你是调用构造还是函数声明，当有一个含有<code>int</code>类型的文件，需要从中读出放入<code>list</code>中，有如下代码：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.不正确的写法</span></div><div class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</div><div class="line"><span class="comment">//想用迭代器构造这个list，但实际上却是在声明一个函数</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile), istream_iterator&lt;<span class="keyword">int</span>&gt;());</div><div class="line"></div><div class="line"><span class="comment">//2.正确的写法</span></div><div class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</div><div class="line"><span class="comment">//定义两个迭代器</span></div><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; dataBegin(dataFile);</div><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; dataEnd;</div><div class="line"><span class="comment">//用迭代器初始化list</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(dataBegin, dataEnd);</div></pre></td></tr></table></figure></p>
<h4 id="条款7：销毁容器前记得释放动态申请的空间"><a href="#条款7：销毁容器前记得释放动态申请的空间" class="headerlink" title="条款7：销毁容器前记得释放动态申请的空间"></a>条款7：销毁容器前记得释放动态申请的空间</h4><p>当容器中保存着的是 <code>new</code> 申请到的动态对象时，当作用域失效后，容器自己的空间会由系统回收，但是动态申请的空间不会回收，这时需要手动回收空间。需要注意的是：手动释放以及异常处理。比较好的一种做法是使用智能指针，来智能管理内存空间。  </p>
<h4 id="条款8：永不建立-auto-ptr-的容器"><a href="#条款8：永不建立-auto-ptr-的容器" class="headerlink" title="条款8：永不建立 auto_ptr 的容器"></a>条款8：永不建立 <code>auto_ptr</code> 的容器</h4><p><code>auto_ptr</code> 的容器（COAPs）是被 <strong>禁止</strong> 的。  </p>
<h4 id="条款9：删除选项中仔细选择"><a href="#条款9：删除选项中仔细选择" class="headerlink" title="条款9：删除选项中仔细选择"></a>条款9：删除选项中仔细选择</h4><ul>
<li>去除一个容器中有特定值的所有对象：<br>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove</code>惯用法。
如果容器是<code>list</code>，使用<code>list::remove</code>。
如果容器是标准关联容器，使用它的<code>erase</code>成员函数。</li>
<li>去除一个容器中满足一个特定判定式的所有对象：<br>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove_if</code>惯用法。
如果容器是<code>list</code>，使用<code>list::remove_if</code>。
如果容器是标准关联容器，使用<code>remove_copy_if</code>和<code>swap</code>，或写一个循环来遍历容器元素，当你把迭代器传给<code>erase</code>时记得后置递增它。</li>
<li>在循环内做某些事情（除了删除对象之外）：<br>如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用<code>erase</code>时记得都用它的返回值更新你
的迭代器。
如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给<code>erase</code>时记得后置递增它。</li>
</ul>
<h4 id="条款10：注意分配器的协定和约束"><a href="#条款10：注意分配器的协定和约束" class="headerlink" title="条款10：注意分配器的协定和约束"></a>条款10：注意分配器的协定和约束</h4><h4 id="条款11：理解自定义分配器的正确用法"><a href="#条款11：理解自定义分配器的正确用法" class="headerlink" title="条款11：理解自定义分配器的正确用法"></a>条款11：理解自定义分配器的正确用法</h4><h4 id="条款12：STL容器线程安全性考虑"><a href="#条款12：STL容器线程安全性考虑" class="headerlink" title="条款12：STL容器线程安全性考虑"></a>条款12：STL容器线程安全性考虑</h4><p>多线程环境下对容器的操作如果没有特殊的处理是不安全的，不安全的处理应该包括以下方面：  </p>
<ul>
<li>保证多个线程读取容器内容时正确并且不能有写线程</li>
<li>多线程写时的互斥操作</li>
</ul>
<p>为了保证线程安全需要做的是通过 <strong>信号量</strong>、<strong>互斥锁</strong> 等线程同步原语，对容器的操作进行封装，常见的做法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//定义一个锁类，构造时加锁，析构时自动释放</div><div class="line">class Lock &#123; // 的类的模板核心；</div><div class="line">public: // 忽略了很多细节</div><div class="line">    Lock(const Containers container): c(container)</div><div class="line">    &#123;</div><div class="line">        getMutexFor(c); //在构造函数获取互斥量</div><div class="line">    &#125;</div><div class="line">    ~Lock()</div><div class="line">    &#123;</div><div class="line">        releaseMutexFor(c); //在析构函数里释放它</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    const Container&amp; c;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//使用</div><div class="line">vector&lt;int&gt; v;</div><div class="line">&#123; //建立新代码块；</div><div class="line">    Lock&lt;vector&lt;int&gt; &gt; lock(v); //获取互斥量</div><div class="line">    vector&lt;int&gt;::iterator first5(find(v.begin(), v.end(), 5));</div><div class="line">    if (first5 != v.end()) &#123;</div><div class="line">        *first5 = 0;</div><div class="line">    &#125;</div><div class="line">&#125; //离开作用域，自动释放锁</div></pre></td></tr></table></figure></p>
<p>这种做法的优势是可以保证加锁和释放锁是成对出现的，同时也可以保证异常出现时可以正确释放锁。因为是局部变量，当作用域消失时就会自动释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;英文书籍 &lt;code&gt;Effective STL&lt;/code&gt; 阅读笔记，该书提出了使用标准模板库的 50 条建议。是由 &lt;code&gt;C++&lt;/code&gt;顶级技术开发专家 Scott Meyers 著，也是 《Effective C++》和《More Effective C++》的作者，主要第一章容器的介绍。&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="STL" scheme="http://abumaster.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>日志库easyloggingpp使用</title>
    <link href="http://abumaster.com/2018/03/28/%E6%97%A5%E5%BF%97%E5%BA%93easyloggingpp%E4%BD%BF%E7%94%A8/"/>
    <id>http://abumaster.com/2018/03/28/日志库easyloggingpp使用/</id>
    <published>2018-03-28T12:59:03.000Z</published>
    <updated>2018-03-29T08:29:07.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://github.com/muflihun/easyloggingpp">easyloggingpp</a> 是一个只需引用一个头文件的 <code>C++</code> 日志库，它具有轻量高效、可扩展、线程安全、可嵌入到自己开发模块等等特性。  </p>
</blockquote>
<a id="more"></a>
<pre>
<a href="#下载使用">下载使用</a>
<a href="#自定义配置">自定义配置</a>
    <a href="#日志级别">日志级别</a>
    <a href="使用配置文件">使用配置文件</a>
<a href="记录日志">记录日志</a>
    <a href="基本操作">基本操作</a>
</pre>

<h3 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h3><p>从<a href="https://github.com/muflihun/easyloggingpp">easyloggingpp</a>下载最新的代码，通过 <code>CMake</code> 编译成独立的链接库，或者直接将 <code>easylogging++.h</code> 和 <code>easylogging++.cc</code> 源文件拷贝到自己的项目中，一起编译。官方示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"easylogging++.h"</span>              <span class="comment">//包含头文件</span></span></div><div class="line"></div><div class="line">INITIALIZE_EASYLOGGINGPP                <span class="comment">//用宏来表示初始化日志文件</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </div><div class="line"></span>&#123;</div><div class="line">   LOG(INFO) &lt;&lt; <span class="string">"My first info log using default logger"</span>;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后使用以下命令编译生成可执行文件，日志在控制台中显示，并且在项目目录下有日志文件生成。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ main.cc easylogging++.cc -o prog -std=c++11</div></pre></td></tr></table></figure></p>
<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>它最大的特性就是日志的高度可配置性，通过配置宏参数可以设置日志的级别和格式。以下列出了日志级别分类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Level</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Global</td>
<td style="text-align:left">通用日志级别，全局设置时使用</td>
</tr>
<tr>
<td style="text-align:left">Trace</td>
<td style="text-align:left">回溯某个特定事件的信息，比调试日志更有用</td>
</tr>
</tbody>
</table>
<p>Debug  | 开发过程中调试应用程序，调试开关要打开
Fatal  | 可能导致应用程序中断的非常严重的错误事件
Error   |  程序运行过程中的错误信息，程序继续运行
Warning |  程序运行过程中的错误信息
Info    |   应用程序当前的运行信息
Verbose |   处理冗长的日志信息
Unknown |   适用分层日志记录，完全关闭日志记录</p>
<h4 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##  log_conf.conf 配置文件</span></div><div class="line">* GLOBAL:</div><div class="line">    ENABLED                     = <span class="literal">true</span></div><div class="line">    TO_FILE                     = <span class="literal">true</span></div><div class="line">    TO_STANDARD_OUTPUT          = <span class="literal">true</span></div><div class="line">    FORMAT                      = <span class="string">"[%level | %datetime] | %msg"</span></div><div class="line">    FILENAME                    = <span class="string">"log\\log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line">    SUBSECOND_PRECISION         =  6</div><div class="line">    PERFORMANCE_TRACKING        =  <span class="literal">true</span></div><div class="line">    MAX_LOG_FILE_SIZE           =  2097152 <span class="comment">## 2MB - Comment starts with two hashe</span></div><div class="line">    LOG_FLUSH_THRESHOLD         =  100 <span class="comment">## Flush after every 100 logs</span></div><div class="line"></div><div class="line">* TRACE:</div><div class="line">    FILENAME                    =   <span class="string">"log\\trace_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* DEBUG:</div><div class="line">    FORMAT                      = <span class="string">"%datetime&#123;%d/%M&#125; %func %msg"</span></div><div class="line">    FILENAME                    = <span class="string">"log\\debug_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* FATAL:</div><div class="line">    ENABLED                     = <span class="literal">false</span></div><div class="line"></div><div class="line">* ERROR:</div><div class="line">    FILENAME                    = <span class="string">"log\\error_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* WARNING:</div><div class="line">    FILENAME                    = <span class="string">"log\\warning_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line"></div><div class="line">* INFO:</div><div class="line">    FILENAME                    = <span class="string">"log\\info_log_%datetime&#123;%Y%M%d&#125;.log"</span></div><div class="line">    FORMAT                      = <span class="string">"[%host : %user] | %msg"</span></div><div class="line"></div><div class="line">* VERBOSE:</div><div class="line">    ENABLED                     = <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>通过构造日志记录器来加载配置文件完成对日志的自定义，使用：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"easylogging++.h"</span></span></div><div class="line"></div><div class="line"><span class="function">INITIALIZE_EASYLOGGINGPP</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">    <span class="comment">// 加载配置文件，构造一个配置器对象</span></div><div class="line">    el::<span class="function">Configurations <span class="title">conf</span><span class="params">(<span class="string">"/path/to/my-conf.conf"</span>)</span></span>;</div><div class="line">    <span class="comment">// 重新配置一个单一日志记录器</span></div><div class="line">    el::Loggers::reconfigureLogger(<span class="string">"default"</span>, conf);</div><div class="line">    <span class="comment">// 用配置文件配置所有的日志记录器</span></div><div class="line">    el::Loggers::reconfigureAllLoggers(conf);</div><div class="line">    <span class="comment">// 所有的日志记录器都是从文件中配置完成的，可以使用</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="日志格式说明符"><a href="#日志格式说明符" class="headerlink" title="日志格式说明符"></a>日志格式说明符</h4><p>日志的输出格式可以自定义，库中提供了一些说明符来表示不同的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>%logger</code></td>
<td style="text-align:left">loggger ID  </td>
</tr>
<tr>
<td style="text-align:left"><code>%thread</code></td>
<td style="text-align:left">thread ID</td>
</tr>
<tr>
<td style="text-align:left"><code>%thread_name</code></td>
<td style="text-align:left">用来获取线程的名称，是使用 <code>el::Helpers::setThreadName(&quot;name1&quot;)</code> 来设置的线程标识名</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%level</code></strong></td>
<td style="text-align:left">日志的级别，诸如 <code>DEBUG</code>、<code>INFO</code>、<code>WARNING</code>等</td>
</tr>
<tr>
<td style="text-align:left"><code>%levshort</code></td>
<td style="text-align:left">日志级别的缩写</td>
</tr>
<tr>
<td style="text-align:left"><code>%vlevel</code></td>
<td style="text-align:left">使用详细记录，冗长记录级别</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%datetime</code></strong></td>
<td style="text-align:left">当前的时间，可以自定义时间的格式</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%user</code></strong></td>
<td style="text-align:left">当前运行程序的用户名</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%host</code></strong></td>
<td style="text-align:left">运行程序的机器名称</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%file</code></strong></td>
<td style="text-align:left">源程序的名称，包含完整的路径信息</td>
</tr>
<tr>
<td style="text-align:left"><code>%fbase</code></td>
<td style="text-align:left">只有文件的名称</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%line</code></strong></td>
<td style="text-align:left">运行到此处的代码行</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%func</code></strong></td>
<td style="text-align:left">函数的名称</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%loc</code></strong></td>
<td style="text-align:left">函数的名称以及行号</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>%msg</code></strong></td>
<td style="text-align:left">日志信息</td>
</tr>
<tr>
<td style="text-align:left"><em><code>%</code></em></td>
<td style="text-align:left">转义字符</td>
</tr>
</tbody>
</table>
<p><strong>日期的格式</strong><br>通过上述的符号 <code>%datetime</code> 获取了时间，可以通过自定义的方式来格式化时间，常用的格式符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>%d</code></td>
<td style="text-align:left">一月中的几号</td>
</tr>
<tr>
<td style="text-align:left"><code>%a</code></td>
<td style="text-align:left">简写的星期几</td>
</tr>
<tr>
<td style="text-align:left"><code>%A</code></td>
<td style="text-align:left">全称星期几</td>
</tr>
<tr>
<td style="text-align:left"><code>%Y %M %d %H %m %s</code></td>
<td style="text-align:left">年月日时分秒</td>
</tr>
</tbody>
</table>
<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>有两种方式来记录日志
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOG(LEVEL) &lt;&lt; <span class="string">"info"</span>;               <span class="comment">//第一种：使用默认的日志记录器</span></div><div class="line">CLOG(LEVEL, logger ID) &lt;&lt; <span class="string">"info"</span>;   <span class="comment">//第二种：指定特定的日志记录器，可以自己注册</span></div></pre></td></tr></table></figure></p>
<p>库中注册的有三种：</p>
<ul>
<li>默认的日志记录器 ID: <code>dfault</code> ；</li>
<li>性能日志记录器 ID: <code>performance</code> ；</li>
<li>系统日志记录器 ID: <code>syslog</code>
可以使用以下方式注册自己的日志记录器：<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册一个ID为business的日志记录器，没有会自动创建</span></div><div class="line">el::Logger* businessLogger = el::Loggers::getLogger(<span class="string">"business"</span>);</div><div class="line"><span class="comment">//businessLogger -&gt;</span></div><div class="line"><span class="comment">//info(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//warn(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//error(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//debug(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//fatal(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//trace(const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//verbose(int vlevel, const char*, const T&amp;, const Args&amp;...)</span></div><div class="line"><span class="comment">//来记录日志 可以使用 %v 来格式化数据</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="条件日志记录"><a href="#条件日志记录" class="headerlink" title="条件日志记录"></a>条件日志记录</h4><p>满足条件后，开始记录日志，不满足条件不会记录，使用如下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOG_IF(condition, LEVEL)</div><div class="line">CLOG_IF(condition, LEVEL, logger ID)</div></pre></td></tr></table></figure></p>
<h4 id="记录特定次数日志"><a href="#记录特定次数日志" class="headerlink" title="记录特定次数日志"></a>记录特定次数日志</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LOG_EVERY_N(n, LEVEL)</div><div class="line">CLOG_EVERY_N(n, LEVEL, logger ID)</div><div class="line"></div><div class="line">LOG_AFTER_N(n, LEVEL); <span class="comment">//Only logs when we have reached hit counts of n</span></div><div class="line">LOG_N_TIMES(n, LEVEL); <span class="comment">//Logs n times</span></div></pre></td></tr></table></figure>
<p>源文件 <code>sample</code> 下有使用示例。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/muflihun/easyloggingpp&quot;&gt;easyloggingpp&lt;/a&gt; 是一个只需引用一个头文件的 &lt;code&gt;C++&lt;/code&gt; 日志库，它具有轻量高效、可扩展、线程安全、可嵌入到自己开发模块等等特性。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="日志库" scheme="http://abumaster.com/tags/%E6%97%A5%E5%BF%97%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>cpr阅读笔记</title>
    <link href="http://abumaster.com/2018/03/18/cpr%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2018/03/18/cpr阅读笔记/</id>
    <published>2018-03-18T13:15:22.000Z</published>
    <updated>2018-03-24T08:18:10.225Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://github.com/whoshuu/cpr">C++ Request: Curl for prople request</a></strong> 是一个将<a href="https://github.com/curl/curl">curl</a>用 C++11 标准封装过之后的版本，使得发送网络请求更加方便，本文对源码阅读到库的编译使用做一个详细的总结，对一些 C++ 11 的新标准做一个回顾。  </p>
<a id="more"></a>
<h3 id="cpr-源码结构和安装"><a href="#cpr-源码结构和安装" class="headerlink" title="cpr 源码结构和安装"></a>cpr 源码结构和安装</h3><p><strong>cpr源码结构：</strong><br><img src="http://oo7zsi4t8.bkt.clouddn.com/18-3-20/58201427.jpg" alt="">  </p>
<ul>
<li>cpr中是cpp文件；  </li>
<li><code>include</code> 下是头文件，用到此库需要包含的；  </li>
<li><code>opt</code> 中使用的是第三方库，包括了 <code>curl</code> ，用于测试的 <code>googletest</code> 以及web服务端程序；  </li>
<li><code>test</code> 中包含了单元测试文件  </li>
</ul>
<p><strong>编译安装</strong><br>使用 <code>cmake</code> 源码安装，首先下载 <code>opt</code> 下的第三方依赖库到指定目录。然后，在<code>cpr</code>根目录下新建文件夹 <code>build</code> 输入一下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> build</div><div class="line">cmake ..</div><div class="line"><span class="comment"># 等待cmake完成后</span></div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">make        <span class="comment"># 构建项目</span></div><div class="line">make <span class="built_in">test</span>   <span class="comment"># 进行测试</span></div></pre></td></tr></table></figure></p>
<p>一切完成后，在 <code>build</code> 目录下生成了 <code>lib</code> 库。  </p>
<h3 id="cpp-的知识备忘"><a href="#cpp-的知识备忘" class="headerlink" title="cpp 的知识备忘"></a>cpp 的知识备忘</h3><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><code>initializer_list</code> 初始化的列表，C++ 11中添加的用于列表初始化的模板类型，列表初始化如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//定义并初始化</span></div><div class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;   <span class="comment">//列表初始化</span></div><div class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;<span class="comment">//列表初始化</span></div></pre></td></tr></table></figure></p>
<p><code>initializer_list</code> 的出现丰富了这种列表初始化的应用范围，可以使用如下构造函数来构造初始化列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst;                <span class="comment">//默认初始化；T类型元素的空列表</span></div><div class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst&#123;a,b,c...&#125;;      <span class="comment">//</span></div><div class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst = &#123;a,b,c...&#125;;   <span class="comment">//</span></div><div class="line">lst2(lst1);</div></pre></td></tr></table></figure></p>
<p>注意在初始化列表中其元素是一个常量，无法更改和插入。拷贝和赋值的时候只会发生引用，而不会复制元素。<br>例子：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//自定义结构体，支持使用列表初始化</span></div><div class="line"><span class="comment">//1.template class</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> MyS &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;T&gt; vec_;</div><div class="line">    MyS(<span class="built_in">initializer_list</span>&lt;T&gt; lst) :vec_(lst)&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"initializer with "</span> &lt;&lt; lst.size() &lt;&lt; <span class="string">" elements\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">initializer_list</span>&lt;T&gt; lst)</span></div><div class="line">    </span>&#123;</div><div class="line">        vec_.insert(vec_.end(), lst.begin(), lst.end());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></div><div class="line">    </span>&#123;</div><div class="line">    &#125;</div><div class="line">    pair&lt;T*, <span class="keyword">size_t</span>&gt; c_arr() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>&#123; &amp;vec_[<span class="number">0</span>], vec_.size() &#125;;<span class="comment">//返回初始化列表的一个副本</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">//2.template function</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">template_fn</span><span class="params">(T)</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line"></span>&#123;</div><div class="line">    MyS&lt;<span class="keyword">int</span>&gt; S = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;<span class="comment">//列表初始化</span></div><div class="line">    S.print();</div><div class="line">    S.append(&#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;);<span class="comment">//初始化列表添加元素</span></div><div class="line">    S.print();</div><div class="line">    <span class="comment">//template_fn(&#123; 1, 2, 3, 4 &#125;);//无法推导出正确的类型</span></div><div class="line">    template_fn&lt;<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;);</div><div class="line">    template_fn&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</div><div class="line">    </div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="左值和右值-分发"><a href="#左值和右值-分发" class="headerlink" title="左值和右值 分发"></a>左值和右值 分发</h4><p><strong>左值：</strong>是即能放在等号的左边又能放在等号的右边，是在内存中有实体的存在，占有内存空间；<br><strong>右值：</strong>是只能放在等号的右边，不能被赋值，只是一个临时变量，存放在寄存器中，没有分配存储空间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;      <span class="comment">//a是左值</span></div><div class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">//a+1是右值</span></div></pre></td></tr></table></figure></p>
<p><strong>左值引用</strong> 使用 <code>Type &amp;左值引用名 = 左值表达式;</code> 是左值的一个别名，本质是一个指针；<br><strong>右值引用</strong>  用法 <code>Type &amp;&amp;右值引用名 = 右值表达式;</code> 由于右值在内存中没有具体的内存空间，所以不能复制给左值引用，使用右值引用，如在函数的声明过程中
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;&#125;<span class="comment">//函数</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">function(i+<span class="number">1</span>);          <span class="comment">//会出现错误</span></div><div class="line"><span class="comment">//可以将函数的定义改为：</span></div><div class="line"><span class="comment">//1 void function(const int &amp;a)&#123;&#125;   常量引用</span></div><div class="line"><span class="comment">//2 void function(int &amp;&amp;a)&#123;&#125;        右值引用</span></div><div class="line"><span class="comment">//也可以在调用前使用 int &amp;&amp;rval = move(a+1); 将其变为右值引用</span></div></pre></td></tr></table></figure></p>
<p><strong>所谓的 <code>forward</code> 完美转发</strong><br>根据类型T是左值或者右值来转发，在右值引用作为函数的形参的时候，在函数内部，右值引用变为了左值引用，无法保留原始的类型，所以需要使用 <code>forward</code> 来完美转发。原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </div><div class="line"></span>&#123;</div><div class="line">    <span class="comment">// arg is always lvalue</span></div><div class="line">    foo(<span class="built_in">std</span>::forward&lt;T&gt;(arg)); <span class="comment">// Forward as lvalue or as rvalue, depending on T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常要将原始的类型转发参数。如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">//重载了两个函数，分别以左值引用和右值引用作为参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> &amp;&amp;a)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> A&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">(A &amp;&amp;a)</span> </span>&#123;               <span class="comment">//使用G函数转发参数</span></div><div class="line">    <span class="comment">//return F(std::forward&lt;A&gt;(a));     //1 完美转发</span></div><div class="line">    <span class="keyword">return</span> F(a);                        <span class="comment">//2 将a作为了左值转发</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">    G(i);</div><div class="line">    G(<span class="number">1</span>);</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/whoshuu/cpr&quot;&gt;C++ Request: Curl for prople request&lt;/a&gt;&lt;/strong&gt; 是一个将&lt;a href=&quot;https://github.com/curl/curl&quot;&gt;curl&lt;/a&gt;用 C++11 标准封装过之后的版本，使得发送网络请求更加方便，本文对源码阅读到库的编译使用做一个详细的总结，对一些 C++ 11 的新标准做一个回顾。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用笔记</title>
    <link href="http://abumaster.com/2018/03/08/Git-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://abumaster.com/2018/03/08/Git-使用笔记/</id>
    <published>2018-03-08T11:31:17.000Z</published>
    <updated>2018-03-28T08:55:43.790Z</updated>
    
    <content type="html"><![CDATA[<p>Git 使用简单总结。
<a id="more"></a></p>
<h4 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h4><p>代码库中有一个主分支 <code>master</code> ，用于保存稳定的版本，自动随仓库建立的，默认在此分支上开发。日常的开发要在一个开发分支上进行，不直接修改 <code>master</code> 分支，需要更新时向主分支合并开发分支。<br>Git创建开发分支 <code>devvelop</code> 的命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取 master 的最新代码</span></div><div class="line">git checkout master</div><div class="line">git pull</div><div class="line"><span class="comment"># 为 master 创建一个名为 develop 的分支</span></div><div class="line">git checkout -b develop master</div></pre></td></tr></table></figure></p>
<h4 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h4><p>分支在修改后，需要提交到本地仓库，和远程仓库中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将修改的文件加入</span></div><div class="line">git add .</div><div class="line"><span class="comment"># 查看文件变化状态</span></div><div class="line">git status</div><div class="line"><span class="comment"># 提交修改</span></div><div class="line">git commit -m<span class="string">'message'</span></div></pre></td></tr></table></figure></p>
<h4 id="第三步：与主分支保持一致"><a href="#第三步：与主分支保持一致" class="headerlink" title="第三步：与主分支保持一致"></a>第三步：与主分支保持一致</h4><p>开发过程中需要与主分支的代码保持一致，命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git rebase origin/master</div></pre></td></tr></table></figure></p>
<h4 id="第四步：合并到-master分支"><a href="#第四步：合并到-master分支" class="headerlink" title="第四步：合并到 master分支"></a>第四步：合并到 master分支</h4><p>当 <code>develop</code> 分支测试没有问题后，合并到 <code>master</code> 中，命令：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先切换到 master 分支中</span></div><div class="line">git checkout master</div><div class="line"><span class="comment"># 对 develop 分支进行合并</span></div><div class="line">git merge --no-ff develop</div></pre></td></tr></table></figure></p>
<p>合并的参数 <code>--no-ff</code> 是在 <code>master</code> 分支中生成一个新节点，将 <code>develop</code> 分支连接到前一个节点和新生成的节点之间。  </p>
<h4 id="第五步：-推送到远程仓库"><a href="#第五步：-推送到远程仓库" class="headerlink" title="第五步： 推送到远程仓库"></a>第五步： 推送到远程仓库</h4><p><strong>两种情况：</strong><br><strong>自己的仓库：</strong>如果在<code>master</code>分支上合并开发分支后，可以直接推送<code>master</code>到远程仓库中，命令如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --force origin master</div></pre></td></tr></table></figure></p>
<p><strong>fork的别人的仓库：</strong>在 <code>develop</code> 分支上进行修改后，没有在 <code>master</code> 上进行合并，需要向主分支提交一个新的分支，表明自己的修改状况，向主分支发送合并的请求，命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --force origin develop-myfeature</div></pre></td></tr></table></figure></p>
<p>提交代码到远程仓库中后，发起 <code>Pull Request</code> 到 <code>master</code> ，请求别人确认合并到 <code>master</code>。  </p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">参考链接</a></p>
<h4 id="fork的代码如何与源保持一致"><a href="#fork的代码如何与源保持一致" class="headerlink" title="fork的代码如何与源保持一致"></a>fork的代码如何与源保持一致</h4><p>从别人仓库中 <code>forke</code> 的一个项目并 <code>clone</code> 到本地进行开发，当源仓库的代码发生更新时，也需要用到最新的代码，一个思路是从源仓库拉取最新的代码到本地，然后合并本地仓库，最后推送到远程自己的仓库中。  </p>
<ul>
<li>首先，创建一个远程仓库，指定源仓库所在的地址，语法为 <code>git remote add [shotname] [url]</code>，可以使用 <code>git remote -v</code> 查看远程仓库的信息，一般会有一个 <code>fetch</code> 和 <code>push</code> 匹配，分别用于取代码和推送代码；  </li>
<li>然后从远程仓库抓取数据，<code>git fetch [remote-name]</code> ，<code>fetch</code> 相当于从远程仓库中 <code>pull</code> 了最新的代码并 <code>merge</code> 到当前本地仓库；  </li>
<li>再切换到本地的<code>master</code>分支，并将这个远程仓库的本地仓库与主分支合并，<code>git merge [remote-name/origin] master</code> ，这时可能主仓库的代码更改与本地仓库的更改冲突，需要解决<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000">合并冲突</a>。按照提示解决冲突文件重新提交即可。  </li>
<li>推送到远程仓库，与源仓库的代码保持一致 <code>git push [remote-name] [branch-name]</code> 。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 使用简单总结。
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="Git" scheme="http://abumaster.com/tags/Git/"/>
    
      <category term="技巧" scheme="http://abumaster.com/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>ACE学习笔记4：任务和主动对象</title>
    <link href="http://abumaster.com/2017/11/17/ACE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%B8%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1/"/>
    <id>http://abumaster.com/2017/11/17/ACE学习笔记4：任务和主动对象/</id>
    <published>2017-11-17T03:03:02.000Z</published>
    <updated>2017-11-27T13:09:10.186Z</updated>
    
    <content type="html"><![CDATA[<p>主动对象区别于被动对象，被动对象的方法代码是在调用线程中执行的。主动对象持有自己的线程用于执行自己的方法。在对象中封装一个或一组线程的对象，称为 <em>主动对象</em>。  任务。  </p>
<a id="more"></a>
<h4 id="任务的简单使用"><a href="#任务的简单使用" class="headerlink" title="任务的简单使用"></a>任务的简单使用</h4><p>要创建任务和主动对象，要从 <code>ACE_Task</code> 中派生一个任务子类，然后必须进行以下的工作：  </p>
<ul>
<li><strong>实现初始化和终止方法</strong>：<code>open()</code> 方法实现专属任务的初始化代码，连接控制块、锁以及内存资源，<code>close()</code> 则是终止方法；  </li>
<li><strong>调用启动方法</strong>：主动对象实例化必须调用 <code>activate()</code> 方法，要在主动对象中创建的线程数目及其他的一些信息作为参数传递给此函数；  </li>
<li><strong>实现任务专有的处理方法</strong>：主动对象启动后，各个线程在 <code>svc()</code> 中启动，必须定义此方法。  </li>
</ul>
<p><strong>任务间的通信</strong>  每个任务底层都有一个消息队列，通常被用作任务间进行通信的一种方式。当一个任务想要与其他任务进行通信的时候会将消息放入与之谈话的消息队列中，通过调用 <code>getq()</code> 函数来获取消息，没有消息则进行睡眠，有消息到达时会自动唤醒并处理此消息。<br>使用：假设任务A和任务B之间通信，<code>A-&gt;B</code> 发送消息。首先，定义一个 <code>ACE_Message_Block</code> 类型的消息块<code>*mb</code>，可以是单一的类型，也可以是数据结构，然后，在A中通过调用 <code>B-&gt;putq(mb)</code> 向底层消息管道中压入一个消息快；然后B中用 <code>getq(mb)</code> 获取消息队列中的消息。实现两个任务之间的通信。  </p>
<h4 id="主动对象"><a href="#主动对象" class="headerlink" title="主动对象"></a>主动对象</h4><blockquote>
<p>主动对象模式用于降低方法执行和方法调用之间的耦合。该模式描述了另外一种更为透明的任务间通信方法。<br>传统上，所有的对象都是被动的代码段，对象中的代码是在对它发出方法调用的线程中执行的，当方法被调用时，调用线程将阻塞，直至调用结束。而主动对象却不一样。这些对象具有自己的命令执行线程，主动对象的方法将在自己的执行线程中执行，不会阻塞调用方法。</p>
</blockquote>
<p><strong>ACE主动对象模式实现至少涉及3个类模块:</strong>  </p>
<ul>
<li>提供多线程池 <code>ACE_Task_Base</code> 或者 <code>ACE_Task</code> 或者 <code>ACE_Thread_Manager</code> ；  </li>
<li>提供请求排队的 <code>ACE_Activation_Queue</code>，其内部维护了 <code>ACE_Message_Queue</code> 的 <code>message_block</code> 消息指针队列；  </li>
<li>提供了 <code>ACE_Activation_Queue</code> 队列操作实例的 <code>ACE_Method_Request</code> ，<code>ACE_Method_Request</code>是command模式，最低消耗仅为实现其内部的call方法。  </li>
</ul>
<p><strong>ACE主动对象实现需要依赖以上3个模块，至少构建2个类:</strong></p>
<ul>
<li>分发器，负责将请求参数排队，并提供数个执行线程。</li>
<li>分发对象。请求队列的排队实例。</li>
</ul>
<p><a href="https://www.cnblogs.com/TianFang/archive/2006/12/11/589168.html">ACE 主动对象参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主动对象区别于被动对象，被动对象的方法代码是在调用线程中执行的。主动对象持有自己的线程用于执行自己的方法。在对象中封装一个或一组线程的对象，称为 &lt;em&gt;主动对象&lt;/em&gt;。  任务。  &lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://abumaster.com/categories/programming/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="ACE" scheme="http://abumaster.com/tags/ACE/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 Caffe 深度学习框架</title>
    <link href="http://abumaster.com/2017/11/17/Ubuntu%E5%AE%89%E8%A3%85caffe/"/>
    <id>http://abumaster.com/2017/11/17/Ubuntu安装caffe/</id>
    <published>2017-11-17T03:03:02.000Z</published>
    <updated>2018-01-30T07:00:16.126Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>详细介绍了Ubuntu系统下安装caffe深度学习框架的过程。</p>
</blockquote>
<a id="more"></a>
<h2 id="Ubuntu14-04-Caffe-CPU版"><a href="#Ubuntu14-04-Caffe-CPU版" class="headerlink" title="Ubuntu14.04 + Caffe CPU版"></a>Ubuntu14.04 + Caffe CPU版</h2><p><strong>1.安装依赖项</strong><br>包括了Caffe使用的第三方库
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler  </div><div class="line">sudo apt-get install --no-install-recommends libboost-all-dev</div><div class="line">sudo apt-get install libatlas-base-dev</div></pre></td></tr></table></figure></p>
<p><strong>2.安装python环境</strong><br>使用<a href="https://www.anaconda.com/download/">Anaconda</a>集成的python环境，其中打包了python的很多包，用conda管理python包是一个很好的选择。 </p>
<p><strong>3.安装OpenCV</strong>  </p>
<ul>
<li><p><a href="https://github.com/jayrambhia/Install-OpenCV">从网上下载安装脚本</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/jayrambhia/Install-OpenCV</div></pre></td></tr></table></figure>
</li>
<li><p>进入其中的 <code>Ubuntu</code> 目录下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo sh ./dependencies.sh</div><div class="line">cd 2.4</div><div class="line">sudo sh opencv2_4_10.sh</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong>虚拟机环境下CPU核数的限制会发生卡顿死机，要将 <code>opencv_2_4_10.sh</code> 中的一条命令 <code>make -j</code> 改为 <code>make</code> 即可。  </p>
<p><strong>4.caffe的配置</strong></p>
<ul>
<li>从<a href="https://github.com/BVLC/caffe.git">github</a>上下载caffe源码；</li>
<li><p>拷贝根目录下的 <code>config</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp Makefile.config.example Makefile.config</div></pre></td></tr></table></figure>
</li>
<li><p>配置其中的信息，使用cpu，注释掉 cuda的目录等，主要注意如果使用python层，要配置python的相关路径，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">## Refer to http://caffe.berkeleyvision.org/installation.html</div><div class="line"># Contributions simplifying and improving our build system are welcome!</div><div class="line"></div><div class="line"># cuDNN acceleration switch (uncomment to build with cuDNN).</div><div class="line"># USE_CUDNN := 1</div><div class="line"></div><div class="line"># CPU-only switch (uncomment to build without GPU support).</div><div class="line">CPU_ONLY := 1</div><div class="line"></div><div class="line"># To customize your choice of compiler, uncomment and set the following.</div><div class="line"># N.B. the default for Linux is g++ and the default for OSX is clang++</div><div class="line"># CUSTOM_CXX := g++</div><div class="line"></div><div class="line"># CUDA directory contains bin/ and lib/ directories that we need.</div><div class="line"># CUDA_DIR := /usr/local/cuda</div><div class="line"># On Ubuntu 14.04, if cuda tools are installed via</div><div class="line"># "sudo apt-get install nvidia-cuda-toolkit" then use this instead:</div><div class="line"># CUDA_DIR := /usr</div><div class="line"></div><div class="line"># CUDA architecture setting: going with all of them.</div><div class="line"># For CUDA &lt; 6.0, comment the *_50 lines for compatibility.</div><div class="line">#CUDA_ARCH := -gencode arch=compute_20,code=sm_20 \</div><div class="line">#       -gencode arch=compute_20,code=sm_21 \</div><div class="line">#       -gencode arch=compute_30,code=sm_30 \</div><div class="line">#       -gencode arch=compute_35,code=sm_35 \</div><div class="line">#       -gencode arch=compute_50,code=sm_50 \</div><div class="line">#       -gencode arch=compute_50,code=compute_50</div><div class="line">#</div><div class="line"># BLAS choice:</div><div class="line"># atlas for ATLAS (default)</div><div class="line"># mkl for MKL</div><div class="line"># open for OpenBlas</div><div class="line">BLAS := atlas</div><div class="line"># Custom (MKL/ATLAS/OpenBLAS) include and lib directories.</div><div class="line"># Leave commented to accept the defaults for your choice of BLAS</div><div class="line"># (which should work)!</div><div class="line"># BLAS_INCLUDE := /path/to/your/blas</div><div class="line"># BLAS_LIB := /path/to/your/blas</div><div class="line"></div><div class="line"># Homebrew puts openblas in a directory that is not on the standard search path</div><div class="line"># BLAS_INCLUDE := $(shell brew --prefix openblas)/include</div><div class="line"># BLAS_LIB := $(shell brew --prefix openblas)/lib</div><div class="line"></div><div class="line"># This is required only if you will compile the matlab interface.</div><div class="line"># MATLAB directory should contain the mex binary in /bin.</div><div class="line"># MATLAB_DIR := /usr/local</div><div class="line"># MATLAB_DIR := /Applications/MATLAB_R2012b.app</div><div class="line"></div><div class="line"># NOTE: this is required only if you will compile the python interface.</div><div class="line"># We need to be able to find Python.h and numpy/arrayobject.h.</div><div class="line">#PYTHON_INCLUDE := /usr/include/python2.7 \</div><div class="line">#       /usr/lib/python2.7/dist-packages/numpy/core/include</div><div class="line"># Anaconda Python distribution is quite popular. Include path:</div><div class="line"># Verify anaconda location, sometimes it's in root.</div><div class="line"> ANACONDA_HOME := $(HOME)/anaconda2</div><div class="line"> PYTHON_INCLUDE := $(ANACONDA_HOME)/include \</div><div class="line">         $(ANACONDA_HOME)/include/python2.7 \</div><div class="line">         $(ANACONDA_HOME)/lib/python2.7/site-packages/numpy/core/include \</div><div class="line"></div><div class="line"># We need to be able to find libpythonX.X.so or .dylib.</div><div class="line"># PYTHON_LIB := /usr/lib</div><div class="line"> PYTHON_LIB := $(ANACONDA_HOME)/lib</div><div class="line"></div><div class="line"># Homebrew installs numpy in a non standard path (keg only)</div><div class="line"># PYTHON_INCLUDE += $(dir $(shell python -c 'import numpy.core; print(numpy.core.__file__)'))/include</div><div class="line"># PYTHON_LIB += $(shell brew --prefix numpy)/lib</div><div class="line"></div><div class="line"># Uncomment to support layers written in Python (will link against Python libs)</div><div class="line">WITH_PYTHON_LAYER := 1</div><div class="line"></div><div class="line"># Whatever else you find you need goes here.</div><div class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include</div><div class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib</div><div class="line"></div><div class="line"># If Homebrew is installed at a non standard location (for example your home directory) and you use it for general dependencies</div><div class="line"># INCLUDE_DIRS += $(shell brew --prefix)/include</div><div class="line"># LIBRARY_DIRS += $(shell brew --prefix)/lib</div><div class="line"></div><div class="line"># Uncomment to use `pkg-config` to specify OpenCV library paths.</div><div class="line"># (Usually not necessary -- OpenCV libraries are normally installed in one of the above $LIBRARY_DIRS.)</div><div class="line"># USE_PKG_CONFIG := 1</div><div class="line"></div><div class="line">BUILD_DIR := build</div><div class="line">DISTRIBUTE_DIR := distribute</div><div class="line"></div><div class="line"># Uncomment for debugging. Does not work on OSX due to https://github.com/BVLC/caffe/issues/171</div><div class="line"># DEBUG := 1</div><div class="line"></div><div class="line"># The ID of the GPU that 'make runtest' will use to run unit tests.</div><div class="line">#TEST_GPUID := 0</div><div class="line"></div><div class="line"># enable pretty build (comment to see full commands)</div><div class="line">Q ?= @</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>5.安装caffe</strong><br>编译安装caffe
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">make all   </div><div class="line">make test  </div><div class="line">make runtest  </div><div class="line">make pycaffe</div></pre></td></tr></table></figure></p>
<h3 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h3><ul>
<li><p><code>Cannot build caffe with anaconda. Error: while loading shared libraries: libhdf5_hl.so.10</code> 不能找到hdf5链接库，由于使用的是Anaconda发行版的python，所以要将其链接库目录加入到链接库中，具体命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&#123;anaconda_dir&#125;/lib</div><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p>使用python接口是出错提示没有protobuf模块，解决方法，使用<code>conda install protobuf</code>安装最新的protobuf python模块，<code>exportPYTHONPATH=/home/zero/Documents/caffe-master/python:$PYTHONPATH</code>。</p>
</li>
</ul>
<h2 id="Ubuntu14-04-Caffe-GPU版"><a href="#Ubuntu14-04-Caffe-GPU版" class="headerlink" title="Ubuntu14.04 + Caffe GPU版"></a>Ubuntu14.04 + Caffe GPU版</h2><p><a href="http://blog.csdn.net/ubunfans/article/details/47724341">参考</a><br><strong>1.安装GPU驱动程序和工具包</strong><br>驱动程序也可以在安装CUDA过程中安装，NVIDIA官网注册下载CUDAV8.0或者CUDA7.5工具包，安装。再下载cudnn v5.0，一般这个版本比较主流不会在安装一些变种caffe版本时出错。<br><strong>2.安装cudnn</strong><br>下载过，解压，将头文件放入到指定文件夹下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar -zxvf cudnn-7.5-linux-x64-v5.0-ga.tgz  </div><div class="line">cd cuda  </div><div class="line">sudo cp lib/lib* /usr/local/cuda/lib64/  </div><div class="line">sudo cp include/cudnn.h /usr/local/cuda/include/</div></pre></td></tr></table></figure></p>
<p>更新链接信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/cuda/lib64/</div><div class="line">sudo chmod +r libcudnn.so.5.0.5</div><div class="line">sudo ln -sf libcudnn.so.5.0.5 libcudnn.so.5</div><div class="line">sudo ln -sf libcudnn.so.5 libcudnn.so</div><div class="line">sudo ldconfig</div></pre></td></tr></table></figure></p>
<p>添加cuda环境变量
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/profile</div><div class="line">PATH = /usr/local/cuda/bin:$PATH</div><div class="line">export PATH</div><div class="line">source /etc/profile #使环境变量生效</div></pre></td></tr></table></figure></p>
<p>添加lib库路径,在 <code>/etc/ld.so.conf.d/</code> 加入文件 <code>cuda.conf</code>，内容为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/local/cuda/lib64  </div><div class="line">sudo ldconfig #使路径生效</div></pre></td></tr></table></figure></p>
<p>接下来的caffe安装与CPU版本一样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;详细介绍了Ubuntu系统下安装caffe深度学习框架的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://abumaster.com/categories/deeplearning/"/>
    
    
      <category term="C++" scheme="http://abumaster.com/tags/C/"/>
    
      <category term="框架" scheme="http://abumaster.com/tags/frame/"/>
    
      <category term="深度学习" scheme="http://abumaster.com/tags/deeplearn/"/>
    
  </entry>
  
</feed>
